<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Vex-manual.fm</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="generator" content="pdftohtml 0.36">
<META name="author" content="paolof">
<META name="date" content="2003-10-08T13:21:04+00:00">
</HEAD>
<BODY bgcolor="#A0A0A0" vlink="blue" link="blue">
    <A name="outline"></a><h1>The VEX System</h1>
<ul><li><A href="vex.html#1">The VEX System</A>
<ul><li><A href="vex.html#2">1 The VEX Instruction Set Architecture</A>
<ul><li><A href="vex.html#3">1.1 Clusters</A>
<li><A href="vex.html#4">1.2 Execution Model</A>
<li><A href="vex.html#4">1.3 Architecture State</A>
<li><A href="vex.html#4">1.4 Arithmetic and Logic Operations</A>
<li><A href="vex.html#7">1.5 Intercluster Communication</A>
<li><A href="vex.html#7">1.6 Memory Operations</A>
<li><A href="vex.html#8">1.7 Control Operations</A>
<li><A href="vex.html#10">1.8 Structure of the default VEX Cluster</A>
<li><A href="vex.html#11">1.9 VEX Semantics</A>
</ul><li><A href="vex.html#12">2 The VEX Run-Time Architecture</A>
<ul><li><A href="vex.html#13">2.1 Data Allocation and Layout</A>
<li><A href="vex.html#13">2.2 Register Usage</A>
<li><A href="vex.html#15">2.3 Stack Layout and Procedure Linkage</A>
</ul><li><A href="vex.html#17">3 The VEX C Compiler</A>
<ul><li><A href="vex.html#19">3.1 Command-line Options</A>
<li><A href="vex.html#24">3.2 Compiler Pragmas</A>
<li><A href="vex.html#28">3.3 Inline Expansion</A>
<ul><li><A href="vex.html#28">Multiflow-style inlining.</A>
<li><A href="vex.html#29">C99-style inlining.</A>
</ul><li><A href="vex.html#29">3.4 Machine Model Parameters</A>
<li><A href="vex.html#30">3.5 Custom Instructions</A>
</ul><li><A href="vex.html#31">4 Visualization Tools</A>
<li><A href="vex.html#33">5 The VEX Simulation System</A>
<li><A href="vex.html#36">6 Customizing the VEX Toolchain</A>
<ul><li><A href="vex.html#37">Computational MEs</A>
<li><A href="vex.html#37">Register Bank MEs</A>
<li><A href="vex.html#37">Machine Resources</A>
</ul><li><A href="vex.html#38">7 Examples of tool usage</A>
<ul><li><A href="vex.html#38">7.1 Compile and run</A>
<li><A href="vex.html#39">7.2 Profiling</A>
<li><A href="vex.html#40">7.3 Custom architectures</A>
</ul></ul></ul></BODY>
<!-- Page 1 -->
<a name="1"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft0{font-size:25px;font-family:Helvetica;color:#000000;}
	.ft1{font-size:12px;font-family:Times;color:#000000;}
	.ft2{font-size:12px;font-family:Times;color:#000000;}
	.ft3{font-size:12px;font-family:Times;color:#000000;}
	.ft4{font-size:16px;font-family:Times;color:#000000;}
	.ft5{font-size:12px;line-height:17px;font-family:Times;color:#000000;}
	.ft6{font-size:12px;line-height:17px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="white.png" alt="background image">
<DIV style="position:absolute;top:80;left:352"><nobr><span class="ft0"><b>The VEX System</b></span></nobr></DIV>
<DIV style="position:absolute;top:141;left:81"><nobr><span class="ft1">This manual describes the VEX ("<i>VLIW Example") </i>system. VEX includes three basic components:</span></nobr></DIV>
<DIV style="position:absolute;top:159;left:94"><nobr><span class="ft1">1.</span></nobr></DIV>
<DIV style="position:absolute;top:159;left:121"><nobr><span class="ft5"><b>The VEX Instruction Set Architecture</b>. VEX defines a 32-bit clustered VLIW ISA that is scalable and customizable<br>to individual application domains. The VEX ISA is loosely modeled upon the ISA of the HP/STMicroelectronics Lx/<br>ST200 family of VLIW embedded cores. Scalability includes the ability to change the number of clusters, execution<br>units, registers and latencies; customizability enables users to define <i>special-purpose </i>instructions in a structured way. </span></nobr></DIV>
<DIV style="position:absolute;top:231;left:94"><nobr><span class="ft1">2.</span></nobr></DIV>
<DIV style="position:absolute;top:231;left:121"><nobr><span class="ft5"><b>The VEX C Compiler</b>. The VEX C compiler is a derivation of the Lx/ST200 C compiler, itself a descendant of the<br><i>Multiflow</i> C compiler. It is a robust, ISO/C89 compiler that uses <i>Trace Scheduling</i> as its global scheduling engine. A<br>very flexible table-like machine model determines the target architecture. For VEX, we selectively expose some of the<br>parameters to allow architecture exploration by changing the number of clusters, execution units, issue width and oper-<br>ation latencies, without having to recompile the compiler.</span></nobr></DIV>
<DIV style="position:absolute;top:321;left:94"><nobr><span class="ft1">3.</span></nobr></DIV>
<DIV style="position:absolute;top:321;left:121"><nobr><span class="ft5"><b>The VEX Simulation System</b>. The VEX simulator is an architecture-level (functional) simulator that uses <i>compiled<br>simulator</i> technology to achieve a speed of many equivalent `MIPS'. The simulation system also comes with a fairly<br>complete set of POSIX-like <i>libc</i> and <i>libm </i>libraries (based on the GNU <i>newlib </i>libraries), a simple built-in cache simula-<br>tor (level-1 cache only), and an API that enables other plug-ins used for modeling the memory system.</span></nobr></DIV>
<DIV style="position:absolute;top:449;left:391"><nobr><span class="ft4"><b>Table of Contents</b></span></nobr></DIV>
<DIV style="position:absolute;top:480;left:135"><nobr><span class="ft1"><A href="vex.html#2">1</a></span></nobr></DIV>
<DIV style="position:absolute;top:480;left:189"><nobr><span class="ft5"><A href="vex.html#2">The VEX Instruction Set Architecture ................................................................................ 2<br></a><A href="vex.html#3">1.1</a></span></nobr></DIV>
<DIV style="position:absolute;top:498;left:243"><nobr><span class="ft1"><A href="vex.html#3">Clusters.................................................................................................................. 3</a></span></nobr></DIV>
<DIV style="position:absolute;top:516;left:189"><nobr><span class="ft1"><A href="vex.html#4">1.2</a></span></nobr></DIV>
<DIV style="position:absolute;top:516;left:243"><nobr><span class="ft1"><A href="vex.html#4">Execution Model ................................................................................................... 4</a></span></nobr></DIV>
<DIV style="position:absolute;top:534;left:189"><nobr><span class="ft1"><A href="vex.html#4">1.3</a></span></nobr></DIV>
<DIV style="position:absolute;top:534;left:243"><nobr><span class="ft1"><A href="vex.html#4">Architecture State .................................................................................................. 4</a></span></nobr></DIV>
<DIV style="position:absolute;top:552;left:189"><nobr><span class="ft1"><A href="vex.html#4">1.4</a></span></nobr></DIV>
<DIV style="position:absolute;top:552;left:243"><nobr><span class="ft1"><A href="vex.html#4">Arithmetic and Logic Operations.......................................................................... 4</a></span></nobr></DIV>
<DIV style="position:absolute;top:570;left:189"><nobr><span class="ft1"><A href="vex.html#7">1.5</a></span></nobr></DIV>
<DIV style="position:absolute;top:570;left:243"><nobr><span class="ft1"><A href="vex.html#7">Intercluster Communication.................................................................................. 7</a></span></nobr></DIV>
<DIV style="position:absolute;top:588;left:189"><nobr><span class="ft1"><A href="vex.html#7">1.6</a></span></nobr></DIV>
<DIV style="position:absolute;top:588;left:243"><nobr><span class="ft1"><A href="vex.html#7">Memory Operations .............................................................................................. 7</a></span></nobr></DIV>
<DIV style="position:absolute;top:606;left:189"><nobr><span class="ft1"><A href="vex.html#8">1.7</a></span></nobr></DIV>
<DIV style="position:absolute;top:606;left:243"><nobr><span class="ft1"><A href="vex.html#8">Control Operations ................................................................................................ 8</a></span></nobr></DIV>
<DIV style="position:absolute;top:624;left:189"><nobr><span class="ft1"><A href="vex.html#10">1.8</a></span></nobr></DIV>
<DIV style="position:absolute;top:624;left:243"><nobr><span class="ft1"><A href="vex.html#10">Structure of the default VEX Cluster .................................................................. 10</a></span></nobr></DIV>
<DIV style="position:absolute;top:642;left:189"><nobr><span class="ft1"><A href="vex.html#11">1.9</a></span></nobr></DIV>
<DIV style="position:absolute;top:642;left:243"><nobr><span class="ft1"><A href="vex.html#11">VEX Semantics ................................................................................................... 11</a></span></nobr></DIV>
<DIV style="position:absolute;top:663;left:135"><nobr><span class="ft1"><A href="vex.html#12">2</a></span></nobr></DIV>
<DIV style="position:absolute;top:663;left:189"><nobr><span class="ft5"><A href="vex.html#12">The VEX Run-Time Architecture ..................................................................................... 12<br></a><A href="vex.html#13">2.1</a></span></nobr></DIV>
<DIV style="position:absolute;top:681;left:243"><nobr><span class="ft1"><A href="vex.html#13">Data Allocation and Layout ................................................................................ 13</a></span></nobr></DIV>
<DIV style="position:absolute;top:699;left:189"><nobr><span class="ft1"><A href="vex.html#13">2.2</a></span></nobr></DIV>
<DIV style="position:absolute;top:699;left:243"><nobr><span class="ft1"><A href="vex.html#13">Register Usage .................................................................................................... 13</a></span></nobr></DIV>
<DIV style="position:absolute;top:717;left:189"><nobr><span class="ft1"><A href="vex.html#15">2.3</a></span></nobr></DIV>
<DIV style="position:absolute;top:717;left:243"><nobr><span class="ft1"><A href="vex.html#15">Stack Layout and Procedure Linkage ................................................................. 15</a></span></nobr></DIV>
<DIV style="position:absolute;top:738;left:135"><nobr><span class="ft1"><A href="vex.html#17">3</a></span></nobr></DIV>
<DIV style="position:absolute;top:738;left:189"><nobr><span class="ft5"><A href="vex.html#17">The VEX C Compiler........................................................................................................ 17<br></a><A href="vex.html#19">3.1</a></span></nobr></DIV>
<DIV style="position:absolute;top:756;left:243"><nobr><span class="ft1"><A href="vex.html#19">Command-line Options ....................................................................................... 19</a></span></nobr></DIV>
<DIV style="position:absolute;top:774;left:189"><nobr><span class="ft1"><A href="vex.html#24">3.2</a></span></nobr></DIV>
<DIV style="position:absolute;top:774;left:243"><nobr><span class="ft1"><A href="vex.html#24">Compiler Pragmas............................................................................................... 24</a></span></nobr></DIV>
<DIV style="position:absolute;top:792;left:189"><nobr><span class="ft1"><A href="vex.html#28">3.3</a></span></nobr></DIV>
<DIV style="position:absolute;top:792;left:243"><nobr><span class="ft1"><A href="vex.html#28">Inline Expansion ................................................................................................. 28</a></span></nobr></DIV>
<DIV style="position:absolute;top:810;left:189"><nobr><span class="ft1"><A href="vex.html#29">3.4</a></span></nobr></DIV>
<DIV style="position:absolute;top:810;left:243"><nobr><span class="ft1"><A href="vex.html#29">Machine Model Parameters ................................................................................ 29</a></span></nobr></DIV>
<DIV style="position:absolute;top:828;left:189"><nobr><span class="ft1"><A href="vex.html#30">3.5</a></span></nobr></DIV>
<DIV style="position:absolute;top:828;left:243"><nobr><span class="ft1"><A href="vex.html#30">Custom Instructions ............................................................................................ 30</a></span></nobr></DIV>
<DIV style="position:absolute;top:849;left:135"><nobr><span class="ft1"><A href="vex.html#31">4</a></span></nobr></DIV>
<DIV style="position:absolute;top:849;left:189"><nobr><span class="ft1"><A href="vex.html#31">Visualization Tools ............................................................................................................ 31</a></span></nobr></DIV>
<DIV style="position:absolute;top:870;left:135"><nobr><span class="ft1"><A href="vex.html#33">5</a></span></nobr></DIV>
<DIV style="position:absolute;top:870;left:189"><nobr><span class="ft1"><A href="vex.html#33">The VEX Simulation System ............................................................................................ 33</a></span></nobr></DIV>
<DIV style="position:absolute;top:891;left:135"><nobr><span class="ft1"><A href="vex.html#36">6</a></span></nobr></DIV>
<DIV style="position:absolute;top:891;left:189"><nobr><span class="ft1"><A href="vex.html#36">Customizing the VEX Toolchain....................................................................................... 36</a></span></nobr></DIV>
<DIV style="position:absolute;top:912;left:135"><nobr><span class="ft1"><A href="vex.html#38">7</a></span></nobr></DIV>
<DIV style="position:absolute;top:912;left:189"><nobr><span class="ft5"><A href="vex.html#38">Examples of tool usage...................................................................................................... 38<br>7.1</a></span></nobr></DIV>
<DIV style="position:absolute;top:930;left:243"><nobr><span class="ft1"><A href="vex.html#38">Compile and run.................................................................................................. 38</a></span></nobr></DIV>
<DIV style="position:absolute;top:948;left:189"><nobr><span class="ft1"><A href="vex.html#39">7.2</a></span></nobr></DIV>
<DIV style="position:absolute;top:948;left:243"><nobr><span class="ft1"><A href="vex.html#39">Profiling .............................................................................................................. 39</a></span></nobr></DIV>
<DIV style="position:absolute;top:966;left:189"><nobr><span class="ft1"><A href="vex.html#40">7.3</a></span></nobr></DIV>
<DIV style="position:absolute;top:966;left:243"><nobr><span class="ft1"><A href="vex.html#40">Custom architectures ........................................................................................... 40</a></span></nobr></DIV>
</DIV>
<!-- Page 2 -->
<a name="2"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft7{font-size:18px;font-family:Helvetica;color:#000000;}
	.ft8{font-size:16px;font-family:Times;color:#000000;}
	.ft9{font-size:12px;font-family:Helvetica;color:#000000;}
	.ft10{font-size:11px;font-family:Times;color:#000000;}
	.ft11{font-size:12px;font-family:Times;color:#000000;}
	.ft12{font-size:12px;font-family:Times;color:#000000;}
	.ft13{font-size:11px;font-family:Helvetica;color:#000000;}
	.ft14{font-size:11px;line-height:13px;font-family:Times;color:#000000;}
	.ft15{font-size:12px;line-height:16px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="vex002.png" alt="background image">
<DIV style="position:absolute;top:80;left:81"><nobr><span class="ft7"><b>1 The VEX Instruction Set Architecture</b></span></nobr></DIV>
<DIV style="position:absolute;top:123;left:81"><nobr><span class="ft5">VEX defines an ISA in terms of the <i>Visible Architecture, </i>that is the syntax, semantics and constraints of operations. Since<br>VEX is a flexible architecture, we can distinguish two types of constraints: the set of rules that all the implementations have to<br>obey (such as the base ISA, register connectivity, memory coherency, architecture state, etc.); and the set of rules of a specific<br>VEX instance (such as the issue width, the number of clusters, the mix of functional units, latencies and custom instructions).</span></nobr></DIV>
<DIV style="position:absolute;top:195;left:94"><nobr><span class="ft1">VEX models a scalable technology platform for embedded VLIW processors that allows variation in issue width, the num-</span></nobr></DIV>
<DIV style="position:absolute;top:213;left:81"><nobr><span class="ft5">ber and capabilities of structures such as functional units and register files, and the processor instruction set. In the spirit of<br>statically scheduled VLIW architectures, the compiler is responsible for schedule correctness. In addition to basic data and<br>operation semantics, VEX includes features to give the compiler greater flexibility in scheduling multiple concurrent opera-<br>tions. These include a complete exposure of all architecture latencies and resource constraints:</span></nobr></DIV>
<DIV style="position:absolute;top:290;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:291;left:102"><nobr><span class="ft1">Parallel execution units, including multiple integer ALUs and multipliers</span></nobr></DIV>
<DIV style="position:absolute;top:316;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:317;left:102"><nobr><span class="ft1">Parallel memory pipelines, including access to multiple data ports</span></nobr></DIV>
<DIV style="position:absolute;top:341;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:342;left:102"><nobr><span class="ft1">Architectural support for data prefetch and other locality hints</span></nobr></DIV>
<DIV style="position:absolute;top:367;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:368;left:102"><nobr><span class="ft1">A large architecturally visible register set</span></nobr></DIV>
<DIV style="position:absolute;top:392;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:393;left:102"><nobr><span class="ft1">Partial predication through <i>select </i>operations</span></nobr></DIV>
<DIV style="position:absolute;top:418;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:419;left:102"><nobr><span class="ft1">An efficient branch architecture with multiple condition registers</span></nobr></DIV>
<DIV style="position:absolute;top:443;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:444;left:102"><nobr><span class="ft1">Encoding of long immediate (32b) operands within the same instruction</span></nobr></DIV>
<DIV style="position:absolute;top:468;left:94"><nobr><span class="ft1">This section specifies the structure and behavior of the VEX Architecture, and it excludes most implementation and</span></nobr></DIV>
<DIV style="position:absolute;top:486;left:81"><nobr><span class="ft1">microarchitecture details except those embodied in VEX. </span></nobr></DIV>
<DIV style="position:absolute;top:504;left:94"><nobr><span class="ft1">VEX defines a parametric space of architectures that share a common set of application and system resources, such as regis-</span></nobr></DIV>
<DIV style="position:absolute;top:522;left:81"><nobr><span class="ft5">ters and operations. A VEX instance (that is, an individual processor) implements a variation of the base architecture, that we<br>obtain by specializing the set of customizable parameters, such as the issue width, the number and mix of functional units, etc.<br>The most basic unit of execution in VEX is an <b>operation</b>, similar to a typical RISC-style instruction. An encoded operation is<br>called a <b>syllable</b>, and a collection of syllables issued in a single cycle and executed in VLIW mode as an atomic unit is called<br>an <b>instruction</b>.</span></nobr></DIV>
<DIV style="position:absolute;top:626;left:81"><nobr><span class="ft9"><i>VEX Assembler Notation</i></span></nobr></DIV>
<DIV style="position:absolute;top:652;left:81"><nobr><span class="ft1">To understand the assembler notation for a VEX operation, consider the following example:</span></nobr></DIV>
<DIV style="position:absolute;top:671;left:135"><nobr><span class="ft14">c0 cmpne $b0.3 = $r0.4, $r0.5<br>;;</span></nobr></DIV>
<DIV style="position:absolute;top:711;left:81"><nobr><span class="ft5">The cluster identifier <i>c0</i> denotes the cluster upon which the operation is to be executed--0 in this case. The destination oper-<br>and(s) are given by a list to the left of the "=", while the source operands are listed to the right of the "=". In this case, the only<br>destination operand is <i>branch register #3</i> of <i>cluster 0</i>, and the source operands are <i>general-purpose registers #4</i> and <i>#5</i> of <i>clus-<br>ter 0</i>. In general, the cluster identifier is optional where registers are used as operands, since they uniquely identify the cluster<br>upon which the operation is to be executed. The instruction separator <i>";;" </i>indicates the end of a group of operations that are<br>issued in the same cycle.<A href=""> Figure 1 s</a>hows a more detailed breakdown of the notation for a VEX instruction.</span></nobr></DIV>
<DIV style="position:absolute;top:848;left:258"><nobr><span class="ft11"> <b>c0 </b></span></nobr></DIV>
<DIV style="position:absolute;top:848;left:321"><nobr><span class="ft12"><b>add   </b></span></nobr></DIV>
<DIV style="position:absolute;top:848;left:384"><nobr><span class="ft12"><b>$r0.1  =  $r0.1, 10</b></span></nobr></DIV>
<DIV style="position:absolute;top:866;left:244"><nobr><span class="ft12"><b>;;</b></span></nobr></DIV>
<DIV style="position:absolute;top:1005;left:238"><nobr><span class="ft15">Instruction<br>Separator</span></nobr></DIV>
<DIV style="position:absolute;top:924;left:276"><nobr><span class="ft15">Cluster<br>Specifier</span></nobr></DIV>
<DIV style="position:absolute;top:1001;left:370"><nobr><span class="ft15">Destination<br>Separator</span></nobr></DIV>
<DIV style="position:absolute;top:926;left:453"><nobr><span class="ft15">Register operand:<br>[$&lt;bank&gt;&lt;cluster&gt;.&lt;num&gt;]</span></nobr></DIV>
<DIV style="position:absolute;top:1000;left:511"><nobr><span class="ft11">Immediate operand</span></nobr></DIV>
<DIV style="position:absolute;top:897;left:374"><nobr><span class="ft11">Opcode</span></nobr></DIV>
<DIV style="position:absolute;top:1058;left:226"><nobr><span class="ft13"><b>Figure 1   Anatomy of the assembler notation for a VEX instruction</b></span></nobr></DIV>
</DIV>
<!-- Page 3 -->
<a name="3"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft16{font-size:11px;font-family:Times;color:#000000;}
	.ft17{font-size:14px;font-family:Helvetica;color:#000000;}
	.ft18{font-size:9px;font-family:Helvetica;color:#000000;}
	.ft19{font-size:7px;font-family:Helvetica;color:#000000;}
	.ft20{font-size:25px;font-family:Helvetica;color:#000000;}
	.ft21{font-size:11px;font-family:Helvetica;color:#000000;}
	.ft22{font-size:12px;line-height:18px;font-family:Times;color:#000000;}
	.ft23{font-size:9px;line-height:14px;font-family:Helvetica;color:#000000;}
	.ft24{font-size:9px;line-height:13px;font-family:Helvetica;color:#000000;}
	.ft25{font-size:25px;line-height:8px;font-family:Helvetica;color:#000000;}
	.ft26{font-size:11px;line-height:16px;font-family:Helvetica;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="vex003.png" alt="background image">
<DIV style="position:absolute;top:81;left:94"><nobr><span class="ft1">Instructions that include multiple operations simply list each operation on a separate line, with a double semicolon as a sep-</span></nobr></DIV>
<DIV style="position:absolute;top:99;left:81"><nobr><span class="ft5">arator of instructions. For example, the following assembler listing shows two instructions, the first one with two operations,<br>and the second one with three.</span></nobr></DIV>
<DIV style="position:absolute;top:149;left:159"><nobr><span class="ft10">c0 add $r0.13 = $r0.3, $r0.0</span></nobr></DIV>
<DIV style="position:absolute;top:149;left:410"><nobr><span class="ft10"># instr 0, op 0</span></nobr></DIV>
<DIV style="position:absolute;top:163;left:159"><nobr><span class="ft10">c0 sub $r0.16 = $r0.6, 3</span></nobr></DIV>
<DIV style="position:absolute;top:163;left:410"><nobr><span class="ft10"># instr 0, op 1</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:135"><nobr><span class="ft10">;; <i>## end of first instruction</i></span></nobr></DIV>
<DIV style="position:absolute;top:203;left:159"><nobr><span class="ft10">c0 shl $r0.13 = $r0.13, 3</span></nobr></DIV>
<DIV style="position:absolute;top:203;left:410"><nobr><span class="ft10"># instr 1, op 0</span></nobr></DIV>
<DIV style="position:absolute;top:217;left:159"><nobr><span class="ft10">c0 shr $r0.15 = $r0.15, 9</span></nobr></DIV>
<DIV style="position:absolute;top:217;left:410"><nobr><span class="ft10"># instr 1, op 1</span></nobr></DIV>
<DIV style="position:absolute;top:230;left:159"><nobr><span class="ft10">c0 ldw.d $r0.14 = 0[$r0.4]</span></nobr></DIV>
<DIV style="position:absolute;top:230;left:410"><nobr><span class="ft10"># instr 1, op 2</span></nobr></DIV>
<DIV style="position:absolute;top:244;left:135"><nobr><span class="ft10">;; <i>## end of second instruction</i></span></nobr></DIV>
<DIV style="position:absolute;top:275;left:81"><nobr><span class="ft17"><b>1.1 Clusters</b></span></nobr></DIV>
<DIV style="position:absolute;top:309;left:81"><nobr><span class="ft5">VEX is a <b>clustered</b> architecture<A href=""> (Figure 2):</a> it provides scalability of issue width and functionality using modular execution<br>clusters. A cluster is a collection of register files and a tightly coupled set of functional units. Functional units within a cluster<br>directly access only the cluster register files, with only a few exceptions. VEX clusters are architecturally visible and the code<br>contains explicit cluster assignments (to choose the execution cluster for an operation), and explicit inter-cluster copy opera-<br>tions (to move data across clusters). Inter-cluster copy operations may require more than one cycle (pipelined or not) and may<br>consume resources in both the source and the destination cluster. Since we can associate data cache ports and/or private mem-<br>ories with each cluster, VEX allows multiple memory accesses to execute simultaneously. Clusters obey the following set of</span></nobr></DIV>
<DIV style="position:absolute;top:849;left:81"><nobr><span class="ft1">rules:</span></nobr></DIV>
<DIV style="position:absolute;top:872;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:873;left:102"><nobr><span class="ft1">A single cluster can issue multiple operations in the same instruction</span></nobr></DIV>
<DIV style="position:absolute;top:898;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:899;left:102"><nobr><span class="ft1">Clusters can have different widths and different operation mixes</span></nobr></DIV>
<DIV style="position:absolute;top:923;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:924;left:102"><nobr><span class="ft1">Not all clusters have to support the entire VEX ISA</span></nobr></DIV>
<DIV style="position:absolute;top:949;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:950;left:102"><nobr><span class="ft5">Units within a single cluster are indistinguishable. In other words, a cluster can only execute a finite set of simultaneous<br>operations, but these operations do not have to be assigned to particular units within the cluster. The hardware assigns oper-<br>ations to units within a cluster</span></nobr></DIV>
<DIV style="position:absolute;top:1009;left:94"><nobr><span class="ft1">By convention, VEX clusters are numbered from zero. Control operations execute on Cluster 0, which is--in this sense--a</span></nobr></DIV>
<DIV style="position:absolute;top:1027;left:81"><nobr><span class="ft1">"special" cluster which must always be present in any VEX implementation.</span></nobr></DIV>
<DIV style="position:absolute;top:1045;left:94"><nobr><span class="ft1">At the architecture level, functional units are only connected to register files and not to other functional units. Microarchitec-</span></nobr></DIV>
<DIV style="position:absolute;top:1063;left:81"><nobr><span class="ft5">ture bypassing (forwarding) is not exposed at the architecture level, but translates into shorter producer-consumer latencies.<br>Functional units and register files within a single cluster are fully interconnected. In other words, it is always possible to write</span></nobr></DIV>
<DIV style="position:absolute;top:484;left:229"><nobr><span class="ft18">Ins truc tion </span></nobr></DIV>
<DIV style="position:absolute;top:498;left:243"><nobr><span class="ft18">Fetch </span></nobr></DIV>
<DIV style="position:absolute;top:512;left:260"><nobr><span class="ft24"> <br> <br> </span></nobr></DIV>
<DIV style="position:absolute;top:553;left:229"><nobr><span class="ft18">Expansio n </span></nobr></DIV>
<DIV style="position:absolute;top:567;left:248"><nobr><span class="ft18">Unit </span></nobr></DIV>
<DIV style="position:absolute;top:580;left:260"><nobr><span class="ft24"> <br> <br> <br> </span></nobr></DIV>
<DIV style="position:absolute;top:675;left:240"><nobr><span class="ft18">IC ac he  </span></nobr></DIV>
<DIV style="position:absolute;top:503;left:347"><nobr><span class="ft18">C luste r  0  </span></nobr></DIV>
<DIV style="position:absolute;top:503;left:534"><nobr><span class="ft18">D $ </span></nobr></DIV>
<DIV style="position:absolute;top:569;left:347"><nobr><span class="ft18">C luste r  1  </span></nobr></DIV>
<DIV style="position:absolute;top:571;left:534"><nobr><span class="ft18">D $ </span></nobr></DIV>
<DIV style="position:absolute;top:677;left:347"><nobr><span class="ft18">C luste r  N  </span></nobr></DIV>
<DIV style="position:absolute;top:677;left:534"><nobr><span class="ft18">D $ </span></nobr></DIV>
<DIV style="position:absolute;top:569;left:615"><nobr><span class="ft18">Memory </span></nobr></DIV>
<DIV style="position:absolute;top:583;left:610"><nobr><span class="ft18">C ontro ller </span></nobr></DIV>
<DIV style="position:absolute;top:597;left:639"><nobr><span class="ft23"> <br> </span></nobr></DIV>
<DIV style="position:absolute;top:625;left:625"><nobr><span class="ft18">Inter </span></nobr></DIV>
<DIV style="position:absolute;top:638;left:618"><nobr><span class="ft18">C luste r   </span></nobr></DIV>
<DIV style="position:absolute;top:652;left:622"><nobr><span class="ft18">Paths  </span></nobr></DIV>
<DIV style="position:absolute;top:447;left:280"><nobr><span class="ft19">B undle  P C  </span></nobr></DIV>
<DIV style="position:absolute;top:602;left:387"><nobr><span class="ft20">..</span></nobr></DIV>
<DIV style="position:absolute;top:617;left:387"><nobr><span class="ft25">.<br> </span></nobr></DIV>
<DIV style="position:absolute;top:589;left:503"><nobr><span class="ft18"> </span></nobr></DIV>
<DIV style="position:absolute;top:775;left:190"><nobr><span class="ft26"><b>Figure 2   Structure of a VEX multi-cluster implementation. </b>At the multi-cluster level,<br>VEX defines the infrastructure to fetch and decode instructions, to sequence programs, to<br>access memory and to move data across clusters.</span></nobr></DIV>
</DIV>
<!-- Page 4 -->
<a name="4"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft27{font-size:12px;line-height:19px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="white.png" alt="background image">
<DIV style="position:absolute;top:81;left:81"><nobr><span class="ft5">the result of a functional unit to a register in the same cluster without passing through intermediate storage. Functional units<br>and register files in different clusters may have limited connectivity: VEX only guarantees the minimal functionality to move<br>data between general-purpose register files in different clusters. Note that some functional units (such as the branch unit) may<br>read registers from other clusters.</span></nobr></DIV>
<DIV style="position:absolute;top:172;left:81"><nobr><span class="ft17"><b>1.2 Execution Model</b></span></nobr></DIV>
<DIV style="position:absolute;top:205;left:81"><nobr><span class="ft5">A VEX architecture issues multiple operations in an instruction in a single cycle, and these operations are executed as a single<br>atomic action (this is sometimes called <i>VLIW mode</i>). Instructions are executed strictly in program order, but within an instruc-<br>tion, <b>all operands are read before any results are written</b>. For example, it is possible to swap the value of a pair of registers<br>in a single instruction. Instructions cannot contain sequential constraints among their operations.</span></nobr></DIV>
<DIV style="position:absolute;top:277;left:94"><nobr><span class="ft1">The execution model treats instructions as atomic units. An exception caused by an instruction may not affect the execution</span></nobr></DIV>
<DIV style="position:absolute;top:295;left:81"><nobr><span class="ft5">of any instruction that was issued earlier and must prevent the instruction generating the exception from modifying the pro-<br>grammer visible state. The execution behavior is that of an <i>in-order</i> machine: each instruction executes to completion before<br>the start of the next one. In other words, all syllables of an instruction start together and commit their results together. Commit-<br>ting results includes modifying register state, updating memory, and generating exceptions.</span></nobr></DIV>
<DIV style="position:absolute;top:367;left:94"><nobr><span class="ft1">Operations may have architecturally visible non-unit latency (<i>Non-Uniform Assigned Latencies--NUAL--</i>model). Not all</span></nobr></DIV>
<DIV style="position:absolute;top:385;left:81"><nobr><span class="ft5">operations are required to have the same latency, and the compiler has to schedule the code while obeying latency constraints.<br>Operations may have a different latency, depending on the functional unit or the source/destination register pair. If the hard-<br>ware can complete an operation in the same number of cycles (or fewer) than assumed by the compiler, no stalls or interlocks<br>are required. If an operation requires longer than the assumed latency, the hardware stalls execution until the architectural<br>assumptions hold again (cache misses and branches fall into this category). In this sense VEX is a <i>less-than-or-equal--LEQ--<br></i>machine. When the hardware does not provide support to check for latency violations, the behavior of a code sequence that<br>violates latency constraints is undefined.</span></nobr></DIV>
<DIV style="position:absolute;top:511;left:94"><nobr><span class="ft1">Each VEX instance imposes limits on the number and type of operations that fit in a single instruction. When it is not possi-</span></nobr></DIV>
<DIV style="position:absolute;top:529;left:81"><nobr><span class="ft5">ble to fill every available operation "slot", the VEX encoding scheme ensures that no space is wasted. VEX encodes opera-<br>tions in 32-bit <i>syllables,</i> that include two reserved bits for sequencing and cluster encoding:</span></nobr></DIV>
<DIV style="position:absolute;top:571;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:572;left:102"><nobr><span class="ft22">The <b>instruction-stop bit</b> (set in the last syllable of an instruction) indicates the end of an instruction and is used by the<br>sequencing logic to identify the execution boundaries within a cycle</span></nobr></DIV>
<DIV style="position:absolute;top:614;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:615;left:102"><nobr><span class="ft5">The <b>cluster-start bit</b> (set in the first syllable of a cluster within an instruction) indicates the beginning of the section of the<br>instruction corresponding to a new cluster. Syllables of an instruction are required to be sorted in cluster order ­ from low<br>to high addresses. The cluster-start bit is used by the dispersal logic to route the proper section of the instruction to the cor-<br>responding cluster</span></nobr></DIV>
<DIV style="position:absolute;top:707;left:81"><nobr><span class="ft17"><b>1.3 Architecture State</b></span></nobr></DIV>
<DIV style="position:absolute;top:741;left:81"><nobr><span class="ft5">The architecturally visible state is composed of the collection of the state of all the architecturally visible <b>containers</b>. VEX<br>containers include general-purpose registers, branch registers, control registers and in general any non-volatile and addressable<br>storage element. VEX containers obey the following constraints.</span></nobr></DIV>
<DIV style="position:absolute;top:800;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:801;left:102"><nobr><span class="ft27">All architecturally visible containers must be individually addressable. In other words, no architecturally visible element<br>can be implicitly part of a larger container without an operation that allows it to be individually addressed</span></nobr></DIV>
<DIV style="position:absolute;top:844;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:845;left:102"><nobr><span class="ft27">Architecturally visible containers are never overwritten by operations that do not explicitly specify the container among<br>their destinations. Containers may not be implicitly overwritten (this would be an example of a <i>"hot spot"</i>).</span></nobr></DIV>
<DIV style="position:absolute;top:887;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:888;left:102"><nobr><span class="ft27">The architecture implementation must provide a "copy" mechanism to move data to and from any architecturally visible<br>container</span></nobr></DIV>
<DIV style="position:absolute;top:930;left:94"><nobr><span class="ft1">All VEX operations operate on 32-bit containers, and do not include specific support for non-32-bit values. For example, the</span></nobr></DIV>
<DIV style="position:absolute;top:948;left:81"><nobr><span class="ft5">memory architecture widens smaller accesses (8- and 16-bit) to 32-bit containers. Larger data types (e.g., 64-bit) are accessed<br>with multiple 32-bit memory operations. Operations on smaller data types require the compiler to execute the proper sign/zero<br>extensions. Note that, although they may appear as an exception of the previous rule, single-bit branch registers are actually a<br>concise representation of the integer values `1' and `0'. Operations that manipulate branch registers must perform the proper<br>conversions when moving values between general-purpose registers and branch registers.</span></nobr></DIV>
<DIV style="position:absolute;top:1057;left:81"><nobr><span class="ft17"><b>1.4 Arithmetic and Logic Operations</b></span></nobr></DIV>
<DIV style="position:absolute;top:1090;left:81"><nobr><span class="ft1">VEX supports a "traditional" set of RISC-style integer operations. Less traditional operations include <i>shift-and-add </i>(for effi-</span></nobr></DIV>
</DIV>
<!-- Page 5 -->
<a name="5"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft28{font-size:9px;font-family:Times;color:#000000;}
	.ft29{font-size:9px;font-family:Times;color:#000000;}
	.ft30{font-size:9px;line-height:15px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="vex005.png" alt="background image">
<DIV style="position:absolute;top:81;left:81"><nobr><span class="ft5">cient address computations), <i>select</i> (for partial predication), logical <i>and/or </i>operations (for control-flow simplification), <i>min/<br>max </i>operations and a rich set of <i>integer multiplication </i>operations. This version of VEX  focuses on <i>integer  </i>operations, and<br>does not include any specific hardware support for floating-point, which is emulated through a library of intrinsics derived<br>from the public-domain <i>SoftFloat</i></span></nobr></DIV>
<DIV style="position:absolute;top:131;left:283"><nobr><span class="ft28">1</span></nobr></DIV>
<DIV style="position:absolute;top:135;left:289"><nobr><span class="ft2"><i> </i>package.</span></nobr></DIV>
<DIV style="position:absolute;top:153;left:94"><nobr><span class="ft1"><A href="">Table 1, Table 2 a</a>n<A href="">d Table 3 li</a>st the VEX arithmetic and logical operation with a brief description of each. In<A href=""> Table 2 </a>we</span></nobr></DIV>
<DIV style="position:absolute;top:171;left:81"><nobr><span class="ft5">show the rich set of multiplication operations that VEX supports, as often required in DSP-like algorithms. In the tables, we<br>use the notations <i>s1, s2</i> to indicate a source general-purpose register, <i>t</i> for a target general-purpose register, <i>b</i> for a branch reg-<br>ister (source or destination), and <i>im</i> to indicate a source immediate (constant). VEX operations are semantics-based and for-<br>mat-independent, and the same opcode is used regardless of the type of operands and results. For example, VEX uses <i>add </i>for<br>additions between registers, or between register and immediates.</span></nobr></DIV>
<DIV style="position:absolute;top:1077;left:81"><nobr><span class="ft30">1. <i>SoftFloat </i>was written by John R. Hauser at the International Computer Science Institute (ICSI), in collaboration with the University of California at Berke-<br>ley. See http://www.cs.berkeley.edu/~jhauser/arithmetic/softfloat.html for more information.</span></nobr></DIV>
<DIV style="position:absolute;top:276;left:227"><nobr><span class="ft13"><b>Table 1: Integer Arithmetic Operations in VEX</b></span></nobr></DIV>
<DIV style="position:absolute;top:301;left:230"><nobr><span class="ft13"><b>Operation</b></span></nobr></DIV>
<DIV style="position:absolute;top:301;left:399"><nobr><span class="ft13"><b>Description</b></span></nobr></DIV>
<DIV style="position:absolute;top:321;left:230"><nobr><span class="ft21">ADD    t=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:321;left:399"><nobr><span class="ft21">Add</span></nobr></DIV>
<DIV style="position:absolute;top:340;left:230"><nobr><span class="ft21">ADDCG  t,b=b,s1,s2</span></nobr></DIV>
<DIV style="position:absolute;top:340;left:399"><nobr><span class="ft21">Add with Carry and Generate Carry</span></nobr></DIV>
<DIV style="position:absolute;top:360;left:230"><nobr><span class="ft21">AND    t=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:360;left:399"><nobr><span class="ft21">Bitwise AND</span></nobr></DIV>
<DIV style="position:absolute;top:379;left:230"><nobr><span class="ft21">ANDC   t=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:379;left:399"><nobr><span class="ft21">Bitwise Complement and AND</span></nobr></DIV>
<DIV style="position:absolute;top:398;left:230"><nobr><span class="ft21">DIVS   t,b=b,s1,s2</span></nobr></DIV>
<DIV style="position:absolute;top:398;left:399"><nobr><span class="ft21">Division step with Carry and Generate Carry</span></nobr></DIV>
<DIV style="position:absolute;top:418;left:230"><nobr><span class="ft21">MAX    t=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:418;left:399"><nobr><span class="ft21">Maximum signed</span></nobr></DIV>
<DIV style="position:absolute;top:438;left:230"><nobr><span class="ft21">MAXU   t=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:438;left:399"><nobr><span class="ft21">Maximum unsigned</span></nobr></DIV>
<DIV style="position:absolute;top:457;left:230"><nobr><span class="ft21">MIN    t=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:457;left:399"><nobr><span class="ft21">Minimum signed</span></nobr></DIV>
<DIV style="position:absolute;top:477;left:230"><nobr><span class="ft21">MINU   t=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:477;left:399"><nobr><span class="ft21">Minimum unsigned</span></nobr></DIV>
<DIV style="position:absolute;top:496;left:230"><nobr><span class="ft21">OR     t=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:496;left:399"><nobr><span class="ft21">Bitwise OR</span></nobr></DIV>
<DIV style="position:absolute;top:515;left:230"><nobr><span class="ft21">ORC    t=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:515;left:399"><nobr><span class="ft21">Bitwise complement and OR</span></nobr></DIV>
<DIV style="position:absolute;top:535;left:230"><nobr><span class="ft21">SH1ADD t=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:535;left:399"><nobr><span class="ft21">Shift left 1 and add</span></nobr></DIV>
<DIV style="position:absolute;top:555;left:230"><nobr><span class="ft21">SH2ADD t=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:555;left:399"><nobr><span class="ft21">Shift left 2 and add</span></nobr></DIV>
<DIV style="position:absolute;top:574;left:230"><nobr><span class="ft21">SH3ADD t=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:574;left:399"><nobr><span class="ft21">Shift left 3 and add</span></nobr></DIV>
<DIV style="position:absolute;top:594;left:230"><nobr><span class="ft21">SH4ADD t=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:594;left:399"><nobr><span class="ft21">Shift left 4 and add</span></nobr></DIV>
<DIV style="position:absolute;top:613;left:230"><nobr><span class="ft21">SHL    t=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:613;left:399"><nobr><span class="ft21">Shift left</span></nobr></DIV>
<DIV style="position:absolute;top:632;left:230"><nobr><span class="ft21">SHR    t=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:632;left:399"><nobr><span class="ft21">Shift right signed</span></nobr></DIV>
<DIV style="position:absolute;top:652;left:230"><nobr><span class="ft21">SHRU   t=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:652;left:399"><nobr><span class="ft21">Shift right unsigned</span></nobr></DIV>
<DIV style="position:absolute;top:672;left:230"><nobr><span class="ft21">SUB    t={s2|im},s1</span></nobr></DIV>
<DIV style="position:absolute;top:672;left:399"><nobr><span class="ft21">Subtract</span></nobr></DIV>
<DIV style="position:absolute;top:691;left:230"><nobr><span class="ft21">SXTB   t=s1</span></nobr></DIV>
<DIV style="position:absolute;top:691;left:399"><nobr><span class="ft21">Sign extend byte</span></nobr></DIV>
<DIV style="position:absolute;top:711;left:230"><nobr><span class="ft21">SXTH   t=s1</span></nobr></DIV>
<DIV style="position:absolute;top:711;left:399"><nobr><span class="ft21">Sign extend half</span></nobr></DIV>
<DIV style="position:absolute;top:730;left:230"><nobr><span class="ft21">ZXTB   t=s1</span></nobr></DIV>
<DIV style="position:absolute;top:730;left:399"><nobr><span class="ft21">Zero extend byte</span></nobr></DIV>
<DIV style="position:absolute;top:749;left:230"><nobr><span class="ft21">ZXTH   t=s1</span></nobr></DIV>
<DIV style="position:absolute;top:749;left:399"><nobr><span class="ft21">Zero extend half</span></nobr></DIV>
<DIV style="position:absolute;top:769;left:230"><nobr><span class="ft21">XOR    t=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:769;left:399"><nobr><span class="ft21">Bitwise Exclusive OR</span></nobr></DIV>
<DIV style="position:absolute;top:803;left:228"><nobr><span class="ft13"><b>Table 2: Multiplication Operations in VEX</b></span></nobr></DIV>
<DIV style="position:absolute;top:829;left:231"><nobr><span class="ft13"><b>Operation</b></span></nobr></DIV>
<DIV style="position:absolute;top:829;left:399"><nobr><span class="ft13"><b>Description</b></span></nobr></DIV>
<DIV style="position:absolute;top:848;left:231"><nobr><span class="ft21">MPYLL   t=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:848;left:399"><nobr><span class="ft21">Multiply Signed Low 16 x Low 16 bits</span></nobr></DIV>
<DIV style="position:absolute;top:868;left:231"><nobr><span class="ft21">MPYLLU  t=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:868;left:399"><nobr><span class="ft21">Multiply Unsigned Low 16 x Low 16 bits</span></nobr></DIV>
<DIV style="position:absolute;top:888;left:231"><nobr><span class="ft21">MPYLH   t=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:888;left:399"><nobr><span class="ft21">Multiply Signed Low 16 x High 16 bits</span></nobr></DIV>
<DIV style="position:absolute;top:907;left:231"><nobr><span class="ft21">MPYLHU  t=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:907;left:399"><nobr><span class="ft21">Multiply Unsigned Low 16 x High 16 bits</span></nobr></DIV>
<DIV style="position:absolute;top:927;left:231"><nobr><span class="ft21">MPYHH   t=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:927;left:399"><nobr><span class="ft21">Multiply Signed High 16 x High 16 bits</span></nobr></DIV>
<DIV style="position:absolute;top:946;left:231"><nobr><span class="ft21">MPYHHU  t=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:946;left:399"><nobr><span class="ft21">Multiply Unsigned High 16 x High 16 bits</span></nobr></DIV>
<DIV style="position:absolute;top:965;left:231"><nobr><span class="ft21">MPYL    t=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:965;left:399"><nobr><span class="ft21">Multiply Signed Low 16 x 32 bits</span></nobr></DIV>
<DIV style="position:absolute;top:985;left:231"><nobr><span class="ft21">MPYLU   t=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:985;left:399"><nobr><span class="ft21">Multiply Unsigned Low 16 x 32 bits</span></nobr></DIV>
<DIV style="position:absolute;top:1005;left:231"><nobr><span class="ft21">MPYH    t=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:1005;left:399"><nobr><span class="ft21">Multiply Signed High 16 x 32 bits</span></nobr></DIV>
</DIV>
<!-- Page 6 -->
<a name="6"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft31{font-size:11px;font-family:Helvetica;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="vex006.png" alt="background image">
<DIV style="position:absolute;top:509;left:81"><nobr><span class="ft9"><i>Examples</i></span></nobr></DIV>
<DIV style="position:absolute;top:535;left:81"><nobr><span class="ft5">The following example shows how to use <i>select</i> operations in a simple if-conversion (note that the VEX compiler would rec-<br>ognize this as <i>min</i> and <i>max</i>).</span></nobr></DIV>
<DIV style="position:absolute;top:572;left:135"><nobr><span class="ft14">## Implements: <br>## </span></nobr></DIV>
<DIV style="position:absolute;top:586;left:256"><nobr><span class="ft10">if (x &gt; 10) t = 10;</span></nobr></DIV>
<DIV style="position:absolute;top:599;left:135"><nobr><span class="ft10">##</span></nobr></DIV>
<DIV style="position:absolute;top:599;left:256"><nobr><span class="ft10">if (x &lt; 0) t = 0;</span></nobr></DIV>
<DIV style="position:absolute;top:613;left:135"><nobr><span class="ft14">## where x is in $r0.1 and t is in $r0.2<br>##</span></nobr></DIV>
<DIV style="position:absolute;top:640;left:162"><nobr><span class="ft14">c0 cmpgt $b0.0 = $r0.1, 10<br>c0 cmplt $b0.1 = $r0.1, 0</span></nobr></DIV>
<DIV style="position:absolute;top:667;left:135"><nobr><span class="ft10">;;</span></nobr></DIV>
<DIV style="position:absolute;top:680;left:162"><nobr><span class="ft10">c0 slctf $r0.2 = $b0.0, $r0.2, 10</span></nobr></DIV>
<DIV style="position:absolute;top:694;left:135"><nobr><span class="ft10">;;</span></nobr></DIV>
<DIV style="position:absolute;top:707;left:162"><nobr><span class="ft10">c0 slctf $r0.2 = $b0.1, $r0.2, 0</span></nobr></DIV>
<DIV style="position:absolute;top:721;left:135"><nobr><span class="ft10">;;</span></nobr></DIV>
<DIV style="position:absolute;top:747;left:81"><nobr><span class="ft5">The following example shows how to efficiently use the extensive multiplication repertoire in VEX (assumes a 2-cycle multi-<br>plication)</span></nobr></DIV>
<DIV style="position:absolute;top:784;left:135"><nobr><span class="ft14">## Implements:<br>## </span></nobr></DIV>
<DIV style="position:absolute;top:797;left:184"><nobr><span class="ft10">int t = ((short)a)*((short)b) + (a&gt;&gt;16)*(b&gt;&gt;16)</span></nobr></DIV>
<DIV style="position:absolute;top:811;left:135"><nobr><span class="ft14">## where a is in $r0.1, b in $r0.2 and t in $r0.3<br>##</span></nobr></DIV>
<DIV style="position:absolute;top:838;left:162"><nobr><span class="ft14">c0 mpyll $r0.4 = $r0.1, $r0.2<br>c0 mpyhh $r0.5 = $r0.1, $r0.2</span></nobr></DIV>
<DIV style="position:absolute;top:865;left:184"><nobr><span class="ft10">xnop 1</span></nobr></DIV>
<DIV style="position:absolute;top:878;left:135"><nobr><span class="ft10">;;</span></nobr></DIV>
<DIV style="position:absolute;top:892;left:162"><nobr><span class="ft10">c0 add $r0.3 = $r0.4, $r0.5</span></nobr></DIV>
<DIV style="position:absolute;top:905;left:135"><nobr><span class="ft10">;;</span></nobr></DIV>
<DIV style="position:absolute;top:931;left:81"><nobr><span class="ft5">The following example shows how to efficiently use the logical operation repertoire in VEX to implement complex condi-<br>tional expressions (assumes a 2-cycle compare-to-branch delay and a 2-cycle memory load). Note the use of speculation<br>(</span></nobr></DIV>
<DIV style="position:absolute;top:969;left:86"><nobr><span class="ft10">ldw.d</span></nobr></DIV>
<DIV style="position:absolute;top:967;left:126"><nobr><span class="ft1">) to enable the manipulation of memory operations in conditionals.</span></nobr></DIV>
<DIV style="position:absolute;top:986;left:135"><nobr><span class="ft14">## Implements:<br>## </span></nobr></DIV>
<DIV style="position:absolute;top:1000;left:184"><nobr><span class="ft10">if ((a &gt; 0 || d &lt; 0) &amp;&amp; *pb &gt; c)</span></nobr></DIV>
<DIV style="position:absolute;top:1013;left:135"><nobr><span class="ft10">## goto </span></nobr></DIV>
<DIV style="position:absolute;top:1013;left:256"><nobr><span class="ft10">LABEL;</span></nobr></DIV>
<DIV style="position:absolute;top:1027;left:135"><nobr><span class="ft14">## a in $r0.3, pb in $r0.4, c in $r0.5, d in $r0.6<br>##</span></nobr></DIV>
<DIV style="position:absolute;top:1054;left:159"><nobr><span class="ft14">c0 cmpgt $r0.13 = $r0.3, $r0.0<br>c0 cmplt $r0.16 = $r0.6, $r0.0<br>c0 ldw.d $r0.14 = 0[$r0.4]</span></nobr></DIV>
<DIV style="position:absolute;top:1094;left:135"><nobr><span class="ft10">;;</span></nobr></DIV>
<DIV style="position:absolute;top:106;left:231"><nobr><span class="ft21">MPYHU   t=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:106;left:399"><nobr><span class="ft21">Multiply Unsigned High 16 x 32 bits</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:231"><nobr><span class="ft21">MPYHS   t=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:399"><nobr><span class="ft21">Multiply Signed High 16 x 32, shift left 16</span></nobr></DIV>
<DIV style="position:absolute;top:160;left:232"><nobr><span class="ft13"><b>Table 3:  Logical and Select Operations in VEX</b></span></nobr></DIV>
<DIV style="position:absolute;top:186;left:235"><nobr><span class="ft13"><b>Operation</b></span></nobr></DIV>
<DIV style="position:absolute;top:186;left:400"><nobr><span class="ft13"><b>Description</b></span></nobr></DIV>
<DIV style="position:absolute;top:205;left:235"><nobr><span class="ft21">CMPEQ  {t|b}=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:205;left:400"><nobr><span class="ft21">Compare (equal)</span></nobr></DIV>
<DIV style="position:absolute;top:225;left:235"><nobr><span class="ft21">CMPGE  {t|b}=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:225;left:400"><nobr><span class="ft21">Compare (greater equal - signed)</span></nobr></DIV>
<DIV style="position:absolute;top:244;left:235"><nobr><span class="ft21">CMPGEU {t|b}=s1,{s2|im} Compare (greater equal - unsigned)</span></nobr></DIV>
<DIV style="position:absolute;top:263;left:235"><nobr><span class="ft21">CMPGT  {t|b}=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:263;left:400"><nobr><span class="ft21">Compare (greater - signed)</span></nobr></DIV>
<DIV style="position:absolute;top:283;left:235"><nobr><span class="ft21">CMPGTU {t|b}=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:283;left:400"><nobr><span class="ft21">Compare (greater - unsigned)</span></nobr></DIV>
<DIV style="position:absolute;top:303;left:235"><nobr><span class="ft21">CMPLE  {t|b}=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:303;left:400"><nobr><span class="ft21">Compare (less than equal - signed)</span></nobr></DIV>
<DIV style="position:absolute;top:322;left:235"><nobr><span class="ft21">CMPLEU {t|b}=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:322;left:400"><nobr><span class="ft21">Compare (less than equal - unsigned)</span></nobr></DIV>
<DIV style="position:absolute;top:342;left:235"><nobr><span class="ft21">CMPLT  {t|b}=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:342;left:400"><nobr><span class="ft21">Compare (less than - signed)</span></nobr></DIV>
<DIV style="position:absolute;top:361;left:235"><nobr><span class="ft21">CMPLTU {t|b}=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:361;left:400"><nobr><span class="ft21">Compare (less than - unsigned)</span></nobr></DIV>
<DIV style="position:absolute;top:380;left:235"><nobr><span class="ft21">CMPNE  {t|b}=s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:380;left:400"><nobr><span class="ft21">Compare (not equal)</span></nobr></DIV>
<DIV style="position:absolute;top:400;left:235"><nobr><span class="ft21">NANDL  {t|b}=s1,s2</span></nobr></DIV>
<DIV style="position:absolute;top:400;left:400"><nobr><span class="ft21">Logical NAND</span></nobr></DIV>
<DIV style="position:absolute;top:420;left:235"><nobr><span class="ft21">NORL   {t|b}=s1,s2</span></nobr></DIV>
<DIV style="position:absolute;top:420;left:400"><nobr><span class="ft21">Logical NOR</span></nobr></DIV>
<DIV style="position:absolute;top:439;left:235"><nobr><span class="ft21">ORL    {t|b}=s1,s2</span></nobr></DIV>
<DIV style="position:absolute;top:439;left:400"><nobr><span class="ft21">Logical OR</span></nobr></DIV>
<DIV style="position:absolute;top:459;left:235"><nobr><span class="ft21">SLCT   t=b,s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:459;left:400"><nobr><span class="ft21">Select <i>s1</i> on True Condition</span></nobr></DIV>
<DIV style="position:absolute;top:478;left:235"><nobr><span class="ft21">SLCTF  t=b,s1,{s2|im}</span></nobr></DIV>
<DIV style="position:absolute;top:478;left:400"><nobr><span class="ft21">Select <i>s1</i> on False Condition</span></nobr></DIV>
<DIV style="position:absolute;top:81;left:228"><nobr><span class="ft13"><b>Table 2: Multiplication Operations in VEX</b></span></nobr></DIV>
</DIV>
<!-- Page 7 -->
<a name="7"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="vex007.png" alt="background image">
<DIV style="position:absolute;top:82;left:159"><nobr><span class="ft10">c0 orl $r0.13 = $r0.13, $r0.16</span></nobr></DIV>
<DIV style="position:absolute;top:95;left:135"><nobr><span class="ft10">;;</span></nobr></DIV>
<DIV style="position:absolute;top:109;left:159"><nobr><span class="ft10">c0 cmpgt $r0.14 = $r0.14, $r0.5</span></nobr></DIV>
<DIV style="position:absolute;top:122;left:135"><nobr><span class="ft10">;;   </span></nobr></DIV>
<DIV style="position:absolute;top:136;left:159"><nobr><span class="ft14">c0 andl $b0.0 = $r0.13, $r0.14<br>xnop 1</span></nobr></DIV>
<DIV style="position:absolute;top:163;left:135"><nobr><span class="ft10">;;</span></nobr></DIV>
<DIV style="position:absolute;top:176;left:159"><nobr><span class="ft10">c0 br $b0.0, LABEL</span></nobr></DIV>
<DIV style="position:absolute;top:190;left:135"><nobr><span class="ft10">;;</span></nobr></DIV>
<DIV style="position:absolute;top:221;left:81"><nobr><span class="ft17"><b>1.5 Intercluster Communication</b></span></nobr></DIV>
<DIV style="position:absolute;top:255;left:81"><nobr><span class="ft5">VEX uses a pair of <i>send</i> and <i>receive</i> operations to implement inter-cluster communication. Send/Receive operations specify a<br>source/destination register and an intercluster path identifier. A <i>send</i> operation places the source register value on the specified<br>inter-cluster path. The corresponding <i>receive</i> operation, which must be issued in the same instruction, retrieves the data from<br>the specified inter-cluster path and stores it in the destination register. The immediate operand enables a large number of<br>microarchitectural paths.</span></nobr></DIV>
<DIV style="position:absolute;top:345;left:94"><nobr><span class="ft1"><A href="">Table 4 </a>shows the basic intercluster operations that VEX supports. For convenience and readability, VEX assembler usually</span></nobr></DIV>
<DIV style="position:absolute;top:363;left:81"><nobr><span class="ft1">represents pairs of <i>send/receive</i> operations with the macro <i>mov</i> as the example shows.</span></nobr></DIV>
<DIV style="position:absolute;top:495;left:81"><nobr><span class="ft9"><i>Example</i></span></nobr></DIV>
<DIV style="position:absolute;top:521;left:135"><nobr><span class="ft14">## Copy reg.3 of cluster 0 to reg.4 of cluster 1<br>## Copy reg.1 of cluster 2 to reg.7 of cluster 3<br>## (in the same instruction)<br>##</span></nobr></DIV>
<DIV style="position:absolute;top:575;left:162"><nobr><span class="ft10">c1=c0</span></nobr></DIV>
<DIV style="position:absolute;top:575;left:216"><nobr><span class="ft10">mov $r1.4 = $r0.3</span></nobr></DIV>
<DIV style="position:absolute;top:589;left:162"><nobr><span class="ft10">c3=c2  mov $r3.7 = $r2.1</span></nobr></DIV>
<DIV style="position:absolute;top:602;left:135"><nobr><span class="ft10">;;</span></nobr></DIV>
<DIV style="position:absolute;top:634;left:81"><nobr><span class="ft17"><b>1.6 Memory Operations</b></span></nobr></DIV>
<DIV style="position:absolute;top:667;left:81"><nobr><span class="ft6">VEX is a <i>load/store</i> architecture, meaning that only <i>load </i>and <i>store</i> operations can access memory<i>,</i> and that memory operations<br>only target general-purpose registers (e.g., there are no <i>memory-to-memory </i>operations). This version uses a <i>big-endian</i> byte<br>ordering model. Memory accesses in VEX are restricted to native alignment (i.e., <i>0 mod 2</i> for short, <i>0 mod 4</i> for int, <i>0 mod 8<br></i>for double). Misaligned accesses cause a non-recoverable trap.</span></nobr></DIV>
<DIV style="position:absolute;top:739;left:94"><nobr><span class="ft1">VEX only supports a <i>base plus offset</i> addressing mode, where the base may be any general-purpose register, but the offset</span></nobr></DIV>
<DIV style="position:absolute;top:757;left:81"><nobr><span class="ft1">must be an immediate. For example, the following examples represent a subset of the supported load operations:</span></nobr></DIV>
<DIV style="position:absolute;top:790;left:135"><nobr><span class="ft10">## int a[]; t = a[10] (a in $r0.2, t in $r0.1)</span></nobr></DIV>
<DIV style="position:absolute;top:803;left:162"><nobr><span class="ft10">c0 ldw $r0.1 = 40[$r0.2]</span></nobr></DIV>
<DIV style="position:absolute;top:817;left:135"><nobr><span class="ft10">;;</span></nobr></DIV>
<DIV style="position:absolute;top:844;left:135"><nobr><span class="ft10">## short a[]; t = a[10] (a in $r0.2, t in $r0.1)</span></nobr></DIV>
<DIV style="position:absolute;top:857;left:162"><nobr><span class="ft10">c0 ldh $r0.1 = 20[$r0.2]   </span></nobr></DIV>
<DIV style="position:absolute;top:871;left:135"><nobr><span class="ft10">;;</span></nobr></DIV>
<DIV style="position:absolute;top:898;left:135"><nobr><span class="ft10">## char a[]; t = a[10] (a in $r0.2, t in $r0.1)</span></nobr></DIV>
<DIV style="position:absolute;top:911;left:162"><nobr><span class="ft10">c0 ldb $r0.1 = 10[$r0.2] </span></nobr></DIV>
<DIV style="position:absolute;top:925;left:135"><nobr><span class="ft10">;;</span></nobr></DIV>
<DIV style="position:absolute;top:951;left:94"><nobr><span class="ft1">VEX supports speculative execution of memory <i>load </i>operations. Control speculation occurs when the compiler moves a</span></nobr></DIV>
<DIV style="position:absolute;top:969;left:81"><nobr><span class="ft5">load operation before a controlling branch in the original program order. VEX supports this form of speculation through <i>dis-<br>missible load</i> operations. A <i>dismissible load </i>(sometimes called <i>silent load</i>) ignores non-recoverable exceptions, so it guaran-<br>tees that <i>correct programs run correctly. </i>On the other hand, programs that rely on the generation of non-recoverable<br>exceptions may not be compatible with the VEX speculation model. VEX also supports the concept of explicit memory<br>prefetching, through a <i>prefetch</i> operation.</span></nobr></DIV>
<DIV style="position:absolute;top:1059;left:94"><nobr><span class="ft1">When multiple memory accesses are allowed, VEX guarantees coherency between the memory structures, including caches</span></nobr></DIV>
<DIV style="position:absolute;top:1077;left:81"><nobr><span class="ft1">and local memories. A VEX implementation may introduce stall cycles in order to provide this guarantee. Users are responsi-</span></nobr></DIV>
<DIV style="position:absolute;top:396;left:226"><nobr><span class="ft13"><b>Table 4: Intercluster Operations in VEX</b></span></nobr></DIV>
<DIV style="position:absolute;top:421;left:229"><nobr><span class="ft13"><b>Operation</b></span></nobr></DIV>
<DIV style="position:absolute;top:421;left:350"><nobr><span class="ft13"><b>Description</b></span></nobr></DIV>
<DIV style="position:absolute;top:441;left:229"><nobr><span class="ft21">SEND    s1, im</span></nobr></DIV>
<DIV style="position:absolute;top:441;left:350"><nobr><span class="ft21">Send &lt;s1&gt; to the path identified by &lt;im&gt;</span></nobr></DIV>
<DIV style="position:absolute;top:460;left:229"><nobr><span class="ft21">RECV    t = im</span></nobr></DIV>
<DIV style="position:absolute;top:460;left:350"><nobr><span class="ft21">Assigns the value from the path identified by &lt;im&gt; to &lt;t&gt;</span></nobr></DIV>
</DIV>
<!-- Page 8 -->
<a name="8"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft32{font-size:11px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="vex008.png" alt="background image">
<DIV style="position:absolute;top:81;left:81"><nobr><span class="ft1">ble for guaranteeing coherency beyond the uniprocessor model.</span></nobr></DIV>
<DIV style="position:absolute;top:99;left:94"><nobr><span class="ft1"><A href="">Table 5 </a>shows the repertoire of VEX memory operations, including possible modifiers (represented as <i>{.modifier}</i>). VEX</span></nobr></DIV>
<DIV style="position:absolute;top:117;left:81"><nobr><span class="ft6">supports two flavors of memory modifiers: <i>dismissible (".d")</i> to indicate speculative operations; and optional <i>locality hints<br></i>(<i>".s"</i> for "streaming" accesses, and <i>".l"</i> for "local" accesses).</span></nobr></DIV>
<DIV style="position:absolute;top:388;left:94"><nobr><span class="ft1">The semantics of dismissible load operations are somewhat subtle. A dismissible load must return exactly the same value as</span></nobr></DIV>
<DIV style="position:absolute;top:406;left:81"><nobr><span class="ft5">a corresponding conventional load if such a load could be executed. When a conventional load would suffer a non-recoverable<br>exception, the dismissible load must return a 0. Thus, the correct behavior of dismissible loads is tightly coupled with the pro-<br>cessor exception model.</span></nobr></DIV>
<DIV style="position:absolute;top:460;left:94"><nobr><span class="ft1">Access hints are performance enhancement hints and a VEX implementation may choose to ignore them. The VEX memory</span></nobr></DIV>
<DIV style="position:absolute;top:478;left:81"><nobr><span class="ft5">system may use different caching methods and/or memory structures depending on the access hint. For example, cache lines<br>loaded by addresses tagged with spatial-only locality may be flagged to be replaced sooner than others.</span></nobr></DIV>
<DIV style="position:absolute;top:514;left:94"><nobr><span class="ft1">Prefetch operations are also defined as hints to the underlying memory system. The intended behavior is to cause the</span></nobr></DIV>
<DIV style="position:absolute;top:532;left:81"><nobr><span class="ft5">requested data to be loaded into the local data cache (or prefetch buffer) if not already present. A legal, but not very interesting,<br>implementation of prefetch is a NOP; semantically, a prefetch operation is indeed equivalent to a NOP--it is not allowed to<br>modify the programmer visible state or to cause an exception. Properly implemented prefetch operations may be used to<br>reduce cache miss rates by loading data into the cache in advance of a load or store operations, without stalling execution.</span></nobr></DIV>
<DIV style="position:absolute;top:604;left:94"><nobr><span class="ft1">The following code shows an example of dismissble load:</span></nobr></DIV>
<DIV style="position:absolute;top:637;left:135"><nobr><span class="ft14">## Implements:<br>## </span></nobr></DIV>
<DIV style="position:absolute;top:650;left:189"><nobr><span class="ft10">if (p != 0) *p += 2</span></nobr></DIV>
<DIV style="position:absolute;top:664;left:135"><nobr><span class="ft14">## With p in $r0.1, 2-cycle load, 2-cycle compare<br>##</span></nobr></DIV>
<DIV style="position:absolute;top:691;left:162"><nobr><span class="ft10">c0</span></nobr></DIV>
<DIV style="position:absolute;top:691;left:189"><nobr><span class="ft10">cmpne $b0.0 = $r0.1, 0</span></nobr></DIV>
<DIV style="position:absolute;top:704;left:162"><nobr><span class="ft10">c0</span></nobr></DIV>
<DIV style="position:absolute;top:704;left:189"><nobr><span class="ft32"><b>ldw.d</b></span></nobr></DIV>
<DIV style="position:absolute;top:704;left:229"><nobr><span class="ft10"> $r0.2 = 0[$r0.1]</span></nobr></DIV>
<DIV style="position:absolute;top:718;left:192"><nobr><span class="ft10">xnop 2</span></nobr></DIV>
<DIV style="position:absolute;top:731;left:135"><nobr><span class="ft10">;;</span></nobr></DIV>
<DIV style="position:absolute;top:745;left:162"><nobr><span class="ft14">c0 add $r0.2 = $r0.2, 2<br>c0 br $b0.0, L1</span></nobr></DIV>
<DIV style="position:absolute;top:772;left:135"><nobr><span class="ft10">;;</span></nobr></DIV>
<DIV style="position:absolute;top:785;left:162"><nobr><span class="ft10">c0 stw 0[$r0.1] = $r0.2</span></nobr></DIV>
<DIV style="position:absolute;top:799;left:135"><nobr><span class="ft14">;;<br>L1:</span></nobr></DIV>
<DIV style="position:absolute;top:844;left:81"><nobr><span class="ft17"><b>1.7 Control Operations</b></span></nobr></DIV>
<DIV style="position:absolute;top:877;left:81"><nobr><span class="ft5">VEX supports a simple statically-predicted branch architecture; branches are not considered the most critical operations for the<br>typical media-processing embedded applications. The VEX compiler uses profiling and static branch prediction extensively to<br>linearize the predicted paths--which coincide with the <i>fall-through</i> paths. To remove microarchitecture dependencies from the<br>ISA level, VEX does not expose branch delay slots; the assumption is that the microarchitecture quashes the necessary instruc-<br>tions in the pipeline following a taken branch. In this way, it is possible to apply <i>dynamic branch prediction</i> schemes when<br>they prove to be effective. VEX branches execute in two phases. </span></nobr></DIV>
<DIV style="position:absolute;top:985;left:94"><nobr><span class="ft1">1.</span></nobr></DIV>
<DIV style="position:absolute;top:985;left:121"><nobr><span class="ft5"><b>Prepare the condition</b> specifying the branch, in advance of the control flow change point, and store it in a set of single-<br>bit <i>branch registers</i></span></nobr></DIV>
<DIV style="position:absolute;top:1021;left:94"><nobr><span class="ft1">2.</span></nobr></DIV>
<DIV style="position:absolute;top:1021;left:121"><nobr><span class="ft3"><b>Execute the branch</b> based on the condition as the very last action of an instruction. </span></nobr></DIV>
<DIV style="position:absolute;top:1039;left:94"><nobr><span class="ft1">The presence of multiple branch registers allows the compiler to start preparing multiple conditions before executing the</span></nobr></DIV>
<DIV style="position:absolute;top:1057;left:81"><nobr><span class="ft5">first branch. All compare and logical operations can target either a branch or a general register for flexibility. The delay<br>between the generation of a condition and its use in a branch is exposed to the compiler. Only <i>cluster 0</i> supports the execution</span></nobr></DIV>
<DIV style="position:absolute;top:168;left:227"><nobr><span class="ft13"><b>Table 5: Memory Operations in VEX</b></span></nobr></DIV>
<DIV style="position:absolute;top:193;left:230"><nobr><span class="ft13"><b>Operation</b></span></nobr></DIV>
<DIV style="position:absolute;top:193;left:433"><nobr><span class="ft13"><b>Description</b></span></nobr></DIV>
<DIV style="position:absolute;top:213;left:230"><nobr><span class="ft21">LDW{.d}{.s}{.l}  t = im[s]</span></nobr></DIV>
<DIV style="position:absolute;top:213;left:433"><nobr><span class="ft21">Load word</span></nobr></DIV>
<DIV style="position:absolute;top:232;left:230"><nobr><span class="ft21">LDH{.d}{.s}{.l}  t = im[s1]</span></nobr></DIV>
<DIV style="position:absolute;top:232;left:433"><nobr><span class="ft21">Load halfword signed</span></nobr></DIV>
<DIV style="position:absolute;top:252;left:230"><nobr><span class="ft21">LDHU{.d}{.s}{.l} t = im[s1]</span></nobr></DIV>
<DIV style="position:absolute;top:252;left:433"><nobr><span class="ft21">Load halfword unsigned</span></nobr></DIV>
<DIV style="position:absolute;top:271;left:230"><nobr><span class="ft21">LDB{.d}{.s}{.l}  t = im[s1]</span></nobr></DIV>
<DIV style="position:absolute;top:271;left:433"><nobr><span class="ft21">Load byte signed</span></nobr></DIV>
<DIV style="position:absolute;top:290;left:230"><nobr><span class="ft21">LDBU{.d}{.s}{.l} t = im[s1]</span></nobr></DIV>
<DIV style="position:absolute;top:290;left:433"><nobr><span class="ft21">Load byte unsigned</span></nobr></DIV>
<DIV style="position:absolute;top:310;left:230"><nobr><span class="ft21">STW{.s}{.l} im[s1] </span></nobr></DIV>
<DIV style="position:absolute;top:310;left:365"><nobr><span class="ft21">= </span></nobr></DIV>
<DIV style="position:absolute;top:310;left:377"><nobr><span class="ft21">s2</span></nobr></DIV>
<DIV style="position:absolute;top:310;left:433"><nobr><span class="ft21">Store word</span></nobr></DIV>
<DIV style="position:absolute;top:330;left:230"><nobr><span class="ft21">STH{.s}{.l} im[s1] </span></nobr></DIV>
<DIV style="position:absolute;top:330;left:365"><nobr><span class="ft21">= </span></nobr></DIV>
<DIV style="position:absolute;top:330;left:377"><nobr><span class="ft21">s2</span></nobr></DIV>
<DIV style="position:absolute;top:330;left:433"><nobr><span class="ft21">Store halfword</span></nobr></DIV>
<DIV style="position:absolute;top:349;left:230"><nobr><span class="ft21">STB{.s}{.l} </span></nobr></DIV>
<DIV style="position:absolute;top:349;left:322"><nobr><span class="ft21"> im[s1] = s2</span></nobr></DIV>
<DIV style="position:absolute;top:349;left:433"><nobr><span class="ft21">Store byte</span></nobr></DIV>
<DIV style="position:absolute;top:369;left:230"><nobr><span class="ft21">PFT{.s}{.l} im[s1]</span></nobr></DIV>
<DIV style="position:absolute;top:369;left:433"><nobr><span class="ft21">Prefetch</span></nobr></DIV>
</DIV>
<!-- Page 9 -->
<a name="9"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="vex009.png" alt="background image">
<DIV style="position:absolute;top:81;left:81"><nobr><span class="ft5">of branch operations; however, all clusters can execute compare/logical operations and write the condition result to their own<br>branch registers. In a multicluster organization, branches execute on <i>cluster 0, </i>but can read conditions from other clusters.</span></nobr></DIV>
<DIV style="position:absolute;top:117;left:94"><nobr><span class="ft1">VEX specifies branch target addresses in two alternative ways: through a relative displacement from the program counter; or</span></nobr></DIV>
<DIV style="position:absolute;top:135;left:81"><nobr><span class="ft5">through the content of a special register (the <i>link register</i>) for indirect jumps. A simplifying assumption in VEX is that branch<br>displacements (typically 24 bits) are wide enough to reach the entire <i>text</i> section. VEX support for <i>call</i> operations is limited to<br>a simple <i>branch-and-link</i> operation, that saves the return pointer to the special <i>link register. </i>The software is responsible for all<br>other calling conventions (save and restore registers, manage the stack), as we describe<A href="vex.html#12"> in Section 2 &quot;The VEX Run-Time<br>Architecture&quot;</a>.<A href=""> Table 6 l</a>ists the VEX control operations; in addition to the standard notations, we also use <i>off</i> to indicate a PC-<br>relative code offset, and <i>lr</i> for the VEX link register (<i>$l0.0).</i></span></nobr></DIV>
<DIV style="position:absolute;top:243;left:94"><nobr><span class="ft1">Finally, a special operation is the multi-cycle no-operation control (<i>xnop</i>). In VEX, <i>xnop</i> operations take an argument and</span></nobr></DIV>
<DIV style="position:absolute;top:261;left:81"><nobr><span class="ft5">define the number of cycles that the machine must stall before issuing the next instruction. This can be implemented in various<br>ways: with a separate operation (very inefficient), with a few bits in each instruction (good to cover small latencies), or it could<br>even be completely ignored for a microarchitecture with a scoreboarded register file. The compiler can optionally be instructed<br>to emit explicit <i>nop</i> operations (empty instructions) with the <i>-fno-xnop</i> flag.</span></nobr></DIV>
<DIV style="position:absolute;top:583;left:81"><nobr><span class="ft9"><i>Examples</i></span></nobr></DIV>
<DIV style="position:absolute;top:609;left:81"><nobr><span class="ft5">The following example shows how to use a combination of compare and logical operations to simplify the control flow and to<br>start the preparation of multiple branches with multiple condition registers.</span></nobr></DIV>
<DIV style="position:absolute;top:659;left:135"><nobr><span class="ft14">## Implements: <br>##</span></nobr></DIV>
<DIV style="position:absolute;top:673;left:256"><nobr><span class="ft10">if (a || b) { [Block 1] };</span></nobr></DIV>
<DIV style="position:absolute;top:686;left:135"><nobr><span class="ft10">## </span></nobr></DIV>
<DIV style="position:absolute;top:686;left:256"><nobr><span class="ft10">if (a &gt; 0 &amp;&amp; b &lt; 0) { [Block 2] } ;</span></nobr></DIV>
<DIV style="position:absolute;top:700;left:135"><nobr><span class="ft14">## where a is in $r0.1 and b is in $r0.2<br>##</span></nobr></DIV>
<DIV style="position:absolute;top:727;left:162"><nobr><span class="ft14">c0 orl $b0.0 = $r0.1, $r0.2<br>c0 cmpgt $r0.3 = $r0.1, 0<br>c0 cmplt $r0.4 = $r0.2, 0</span></nobr></DIV>
<DIV style="position:absolute;top:767;left:135"><nobr><span class="ft10">;;</span></nobr></DIV>
<DIV style="position:absolute;top:781;left:162"><nobr><span class="ft10">c0 andl $b1.0, $r0.3, $r0.4</span></nobr></DIV>
<DIV style="position:absolute;top:794;left:135"><nobr><span class="ft10">;; </span></nobr></DIV>
<DIV style="position:absolute;top:808;left:162"><nobr><span class="ft10">c0 br $b0.0, L1 ## L1 starts [Block 1]</span></nobr></DIV>
<DIV style="position:absolute;top:821;left:135"><nobr><span class="ft10">;;</span></nobr></DIV>
<DIV style="position:absolute;top:835;left:162"><nobr><span class="ft10">c0 br $b1.0, L2 ## L2 starts [Block 2]</span></nobr></DIV>
<DIV style="position:absolute;top:848;left:135"><nobr><span class="ft10">;;</span></nobr></DIV>
<DIV style="position:absolute;top:862;left:162"><nobr><span class="ft10">## Continue with the fallthrough path</span></nobr></DIV>
<DIV style="position:absolute;top:894;left:81"><nobr><span class="ft5">In the multicluster case, two identical branch syllables are encoded in the instruction: the first (in cluster 0) provides the branch<br>target, the second (in the condition cluster) provides the branch condition. For example, the following code sequence branches<br>on a condition on cluster 2.</span></nobr></DIV>
<DIV style="position:absolute;top:962;left:135"><nobr><span class="ft14">##<br>## Generate condition on cluster 2<br>##</span></nobr></DIV>
<DIV style="position:absolute;top:1003;left:162"><nobr><span class="ft10">c2</span></nobr></DIV>
<DIV style="position:absolute;top:1003;left:189"><nobr><span class="ft10">cmplt $b2.0 = $r2,1, $r2.0</span></nobr></DIV>
<DIV style="position:absolute;top:1016;left:192"><nobr><span class="ft10">xnop 1</span></nobr></DIV>
<DIV style="position:absolute;top:1030;left:135"><nobr><span class="ft14">;;<br>##<br>## Branch on cl.0 (also uses a syllable on cl.2)<br>##</span></nobr></DIV>
<DIV style="position:absolute;top:1084;left:162"><nobr><span class="ft10">c0  br $b2.0, L2</span></nobr></DIV>
<DIV style="position:absolute;top:348;left:221"><nobr><span class="ft13"><b>Table 6: Control Operations in VEX</b></span></nobr></DIV>
<DIV style="position:absolute;top:373;left:224"><nobr><span class="ft13"><b>Operation</b></span></nobr></DIV>
<DIV style="position:absolute;top:373;left:354"><nobr><span class="ft13"><b>Description</b></span></nobr></DIV>
<DIV style="position:absolute;top:393;left:224"><nobr><span class="ft21">GOTO   off</span></nobr></DIV>
<DIV style="position:absolute;top:393;left:354"><nobr><span class="ft21">Unconditional relative jump</span></nobr></DIV>
<DIV style="position:absolute;top:412;left:224"><nobr><span class="ft21">IGOTO  lr</span></nobr></DIV>
<DIV style="position:absolute;top:412;left:354"><nobr><span class="ft21">Unconditional absolute indirect jump to link register</span></nobr></DIV>
<DIV style="position:absolute;top:432;left:224"><nobr><span class="ft21">CALL   lr = im</span></nobr></DIV>
<DIV style="position:absolute;top:432;left:354"><nobr><span class="ft21">Unconditional relative call</span></nobr></DIV>
<DIV style="position:absolute;top:451;left:224"><nobr><span class="ft21">ICALL  lr = lr</span></nobr></DIV>
<DIV style="position:absolute;top:451;left:354"><nobr><span class="ft21">Unconditional absolute indirect call to link register</span></nobr></DIV>
<DIV style="position:absolute;top:470;left:224"><nobr><span class="ft21">BR      b, off</span></nobr></DIV>
<DIV style="position:absolute;top:470;left:354"><nobr><span class="ft21">Conditional relative branch on true condition</span></nobr></DIV>
<DIV style="position:absolute;top:490;left:224"><nobr><span class="ft21">BRF    b, off</span></nobr></DIV>
<DIV style="position:absolute;top:490;left:354"><nobr><span class="ft21">Conditional relative branch on false condition</span></nobr></DIV>
<DIV style="position:absolute;top:510;left:224"><nobr><span class="ft21">RETURN t = t, off, lr Pop stack frame (t = t + off) and goto link register</span></nobr></DIV>
<DIV style="position:absolute;top:529;left:224"><nobr><span class="ft21">RFI</span></nobr></DIV>
<DIV style="position:absolute;top:529;left:354"><nobr><span class="ft21">Return from interrupt</span></nobr></DIV>
<DIV style="position:absolute;top:549;left:224"><nobr><span class="ft21">XNOP n</span></nobr></DIV>
<DIV style="position:absolute;top:549;left:354"><nobr><span class="ft21">Multicycle No-Operation(advance the pipeline for <i>n</i> cycles)</span></nobr></DIV>
</DIV>
<!-- Page 10 -->
<a name="10"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft33{font-size:12px;line-height:19px;font-family:Times;color:#000000;}
	.ft34{font-size:11px;line-height:16px;font-family:Times;color:#000000;}
	.ft35{font-size:11px;line-height:6px;font-family:Times;color:#000000;}
	.ft36{font-size:11px;line-height:5px;font-family:Times;color:#000000;}
	.ft37{font-size:11px;line-height:18px;font-family:Times;color:#000000;}
	.ft38{font-size:11px;line-height:3px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="vex010.png" alt="background image">
<DIV style="position:absolute;top:82;left:135"><nobr><span class="ft10">;;</span></nobr></DIV>
<DIV style="position:absolute;top:113;left:81"><nobr><span class="ft17"><b>1.8 Structure of the default VEX Cluster</b></span></nobr></DIV>
<DIV style="position:absolute;top:610;left:81"><nobr><span class="ft5">The default VEX cluster (supported by the default tool configuration) has two register files, four integer ALUs, two 16x32-bit<br>multiply units, and a data cache po<A href="">rt (Figure 3).</a> The cluster can issue up to four operations per instruction. The register set<br>consists of 64 general-purpose 32-bit registers (GRs) and 8 1-bit branch registers (BRs). In addition to the base computational<br>resources, the default VEX cluster also contains a control unit (Branch Unit) for program sequencing.</span></nobr></DIV>
<DIV style="position:absolute;top:682;left:94"><nobr><span class="ft1">Note that, without changing the base instruction set, the cluster organization could be significantly altered, with no impact</span></nobr></DIV>
<DIV style="position:absolute;top:700;left:81"><nobr><span class="ft6">on the software. For example, we could produce a cluster with two integer ALUs and one multiply unit. Similarly, the func-<br>tionality of the cluster could be expanded with additional special purpose operations.The default VEX clusters contains <i>Mem-<br>ory</i>, <i>Integer</i>, and <i>Branch</i> functional units.</span></nobr></DIV>
<DIV style="position:absolute;top:760;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:761;left:102"><nobr><span class="ft27"><b>Memory Units</b> perform load, store, and prefetch operations. There are as many units as data cache memory ports con-<br>nected to the cluster. Each Memory unit is associated with an access to the memory system.</span></nobr></DIV>
<DIV style="position:absolute;top:803;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:804;left:102"><nobr><span class="ft3"><b>Integer Units</b> execute the common set of integer, compare, shift and select operations, on registers or immediate operands </span></nobr></DIV>
<DIV style="position:absolute;top:829;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:830;left:102"><nobr><span class="ft27"><b>Branch Units</b> execute control operations based on the conditions stored in the branch registers, such as conditional<br>branches, unconditional jumps, direct and indirect calls and returns.</span></nobr></DIV>
<DIV style="position:absolute;top:871;left:94"><nobr><span class="ft1">Given the restriction that only four syllables may be used to encode the operations for the cluster, at most four operations</span></nobr></DIV>
<DIV style="position:absolute;top:889;left:81"><nobr><span class="ft1">may be issued in a single instruction.</span></nobr></DIV>
<DIV style="position:absolute;top:922;left:81"><nobr><span class="ft9"><i>Register Files and Immediates</i></span></nobr></DIV>
<DIV style="position:absolute;top:948;left:81"><nobr><span class="ft1">VEX operand can be <i>general purpose</i> (GR) registers, <i>branch</i> (BR) registers, <i>link</i> registers (LR) or <i>immediates</i> (constants).</span></nobr></DIV>
<DIV style="position:absolute;top:971;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:972;left:102"><nobr><span class="ft5"><b>General-purpose Registers</b> are a set of 64 32-bit general-purpose registers, including one special registers: <i>register #0<br></i>wired to the constant `0', The software conventions of the VEX RTA (see<A href="vex.html#12"> Section 2 &quot;The VEX Run-Time Architecture&quot;)<br></a>define other usage rules for other VEX registers.</span></nobr></DIV>
<DIV style="position:absolute;top:1033;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:1034;left:102"><nobr><span class="ft5"><b>Branch Registers</b> are a set of 8 1-bit registers written by compare/logical operations and read by conditional branches. In<br>addition, branch registers are used as conditions for select operations and also store the carry bit for the operations that<br>manipulate carries.</span></nobr></DIV>
<DIV style="position:absolute;top:258;left:338"><nobr><span class="ft10">Reg </span></nobr></DIV>
<DIV style="position:absolute;top:273;left:339"><nobr><span class="ft10">File </span></nobr></DIV>
<DIV style="position:absolute;top:290;left:332"><nobr><span class="ft10">64 GR  </span></nobr></DIV>
<DIV style="position:absolute;top:306;left:328"><nobr><span class="ft10">(32 bits)  </span></nobr></DIV>
<DIV style="position:absolute;top:322;left:334"><nobr><span class="ft10">$r0=0 </span></nobr></DIV>
<DIV style="position:absolute;top:339;left:331"><nobr><span class="ft10">$r63=lr </span></nobr></DIV>
<DIV style="position:absolute;top:282;left:619"><nobr><span class="ft10">Load </span></nobr></DIV>
<DIV style="position:absolute;top:297;left:618"><nobr><span class="ft10">Store </span></nobr></DIV>
<DIV style="position:absolute;top:314;left:622"><nobr><span class="ft10">Unit </span></nobr></DIV>
<DIV style="position:absolute;top:426;left:395"><nobr><span class="ft10">ALU </span></nobr></DIV>
<DIV style="position:absolute;top:426;left:503"><nobr><span class="ft10">ALU </span></nobr></DIV>
<DIV style="position:absolute;top:426;left:559"><nobr><span class="ft10">ALU </span></nobr></DIV>
<DIV style="position:absolute;top:426;left:449"><nobr><span class="ft10">ALU </span></nobr></DIV>
<DIV style="position:absolute;top:418;left:211"><nobr><span class="ft10">Branch </span></nobr></DIV>
<DIV style="position:absolute;top:433;left:219"><nobr><span class="ft10">Unit </span></nobr></DIV>
<DIV style="position:absolute;top:282;left:210"><nobr><span class="ft10">I$ </span></nobr></DIV>
<DIV style="position:absolute;top:297;left:201"><nobr><span class="ft34">32KB <br>direct </span></nobr></DIV>
<DIV style="position:absolute;top:274;left:284"><nobr><span class="ft10">D</span></nobr></DIV>
<DIV style="position:absolute;top:283;left:284"><nobr><span class="ft38">e<br>c<br>ode<br>r<br> </span></nobr></DIV>
<DIV style="position:absolute;top:406;left:312"><nobr><span class="ft10">Br RegFile  </span></nobr></DIV>
<DIV style="position:absolute;top:422;left:326"><nobr><span class="ft10">8 BR </span></nobr></DIV>
<DIV style="position:absolute;top:439;left:324"><nobr><span class="ft10">(1 bit)  </span></nobr></DIV>
<DIV style="position:absolute;top:282;left:698"><nobr><span class="ft10">D$ </span></nobr></DIV>
<DIV style="position:absolute;top:297;left:690"><nobr><span class="ft10">4-way </span></nobr></DIV>
<DIV style="position:absolute;top:314;left:691"><nobr><span class="ft10">32KB </span></nobr></DIV>
<DIV style="position:absolute;top:161;left:406"><nobr><span class="ft10">16x32 </span></nobr></DIV>
<DIV style="position:absolute;top:177;left:411"><nobr><span class="ft10">Mult </span></nobr></DIV>
<DIV style="position:absolute;top:161;left:516"><nobr><span class="ft10">16x32 </span></nobr></DIV>
<DIV style="position:absolute;top:177;left:521"><nobr><span class="ft10">Mult </span></nobr></DIV>
<DIV style="position:absolute;top:511;left:158"><nobr><span class="ft26"><b>Figure 3   Structure of the default VEX cluster. </b>What the VEX default configuration implements is a<br>4-issue cluster that loosely resembles the HP/ST ST220 VLIW processor core. The cluster includes 4<br>integer units, 2 multipliers, a load-store unit and a control unit. VEX allows to extend the cluster by<br>changing issue width, number of clusters as well as other architecture parameters.</span></nobr></DIV>
</DIV>
<!-- Page 11 -->
<a name="11"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft39{font-size:9px;font-family:Times;color:#000000;}
	.ft40{font-size:11px;line-height:15px;font-family:Times;color:#000000;}
	.ft41{font-size:11px;line-height:14px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="white.png" alt="background image">
<DIV style="position:absolute;top:82;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:83;left:102"><nobr><span class="ft3"><b>Link Register</b> for procedure calls, returns and indirect jumps. </span></nobr></DIV>
<DIV style="position:absolute;top:107;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:108;left:102"><nobr><span class="ft5"><b>Immediate Operands</b> encode compile-time and load-time constants. VEX instructions encode the necessary immediates<br>without requiring extra operations. VEX supports three types of immediates: <i>branch offsets</i> (24-bit, for branch operations)<br>fit in a single syllable: <i>short immediates</i> (9 bits, for all operations) fit in a single syllable; <i>long immediates</i> (32 bit, for all<br>operations) draw bits upon one adjacent extension syllable in the same cluster and instruction. Immediate extensions are<br>decoded in the same instruction of the operation that reads them, and carry no performance penalty.</span></nobr></DIV>
<DIV style="position:absolute;top:219;left:81"><nobr><span class="ft17"><b>1.9 VEX Semantics</b></span></nobr></DIV>
<DIV style="position:absolute;top:252;left:81"><nobr><span class="ft5">This section describes the semantics of the VEX operations using the syntax of C preprocessor macros. This set of macros is<br>very similar to what--for example--the VEX compiled simulator emits to implement VEX operations. The description only<br>covers the architectural state changes of each operation without considering the exception behavior. The description of the<br>computational operations is self-explanatory. The description of memory operations uses the set of</span></nobr></DIV>
<DIV style="position:absolute;top:326;left:81"><nobr><span class="ft10">"sim_mem_access_safe*()</span></nobr></DIV>
<DIV style="position:absolute;top:327;left:267"><nobr><span class="ft39">"</span></nobr></DIV>
<DIV style="position:absolute;top:324;left:274"><nobr><span class="ft1"> utilities to mimic the behavior of <i>speculative  </i>memory accesses that silently dismiss non-</span></nobr></DIV>
<DIV style="position:absolute;top:342;left:81"><nobr><span class="ft1">recoverable exceptions. The description of control operations uses the </span></nobr></DIV>
<DIV style="position:absolute;top:344;left:509"><nobr><span class="ft10">"goto_instr(x)"</span></nobr></DIV>
<DIV style="position:absolute;top:342;left:630"><nobr><span class="ft1"> utility to indicate changes in con-</span></nobr></DIV>
<DIV style="position:absolute;top:360;left:81"><nobr><span class="ft1">trol flow, and the </span></nobr></DIV>
<DIV style="position:absolute;top:362;left:190"><nobr><span class="ft10">"next_instr()"</span></nobr></DIV>
<DIV style="position:absolute;top:360;left:303"><nobr><span class="ft1"> utility to indicate the address of the instruction following the current. Note that the <i>link</i></span></nobr></DIV>
<DIV style="position:absolute;top:378;left:81"><nobr><span class="ft5"><i>register</i> used for system calls and indirect jumps is always explicitly nominated, since the VEX ISA prohibits "invisible" side-<br>effects of operations on architecturally visible state.</span></nobr></DIV>
<DIV style="position:absolute;top:433;left:135"><nobr><span class="ft40">/* Memory Macros and Operations */<br>#define UINT8(s)  ((s) &amp; 0xff)<br>#define INT8(s)   (((signed) ((s) &lt;&lt; 24)) &gt;&gt; 24)<br>#define UINT16(s) ((s) &amp; 0xffff)<br>#define INT16(s)  (((signed) ((s) &lt;&lt; 16)) &gt;&gt; 16)<br>#define UINT32(s) ((unsigned) (s))<br>#define INT32(s)  ((signed) (s))<br>#define MEM8(a) (*((volatile unsigned char*)(a)))<br>#define MEM16(a) (*((volatile unsigned short*)(a)))<br>#define MEM32(a) (*((volatile unsigned*)(a)))<br>#define MEMSPEC8(a) sim_mem_access_safe8(a)<br>#define MEMSPEC16(a) sim_mem_access_safe16(a)<br>#define MEMSPEC32(a) sim_mem_access_safe32(a)</span></nobr></DIV>
<DIV style="position:absolute;top:643;left:135"><nobr><span class="ft41">#define LDBs(t,s1) t = INT8(MEMSPEC8(s1)) /* speculative */<br>#define LDB(t,s1) t = INT8(MEM8(s1))<br>#define LDBUs(t,s1) t = UINT8(MEMSPEC8(s1)) /* speculative */<br>#define LDBU(t,s1) t = UINT8(MEM8(s1))<br>#define LDHs(t,s1) t = INT16(MEMSPEC16(s1)) /* speculative */<br>#define LDH(t,s1) t = INT16(MEM16(s1))<br>#define LDHUs(t,s1) t = UINT16(MEMSPEC16(s1)) /* speculative */<br>#define LDHU(t,s1) t = UINT16(MEM16(s1))<br>#define LDWs(t,s1) t = INT32(MEMSPEC32(s1)) /* speculative */<br>#define LDW(t,s1) t = INT32(MEM32(s1))<br>#define STB(t,s1) MEM8(t) = UINT8(s1)<br>#define STH(t,s1) MEM16(t) = UINT16(s1)<br>#define STW(t,s1) MEM32(t) = UINT32(s1)</span></nobr></DIV>
<DIV style="position:absolute;top:853;left:135"><nobr><span class="ft41">/* Computational and Logical Operations */<br>#define ADD(t,s1,s2) t = (s1) + (s2)<br>#define AND(t,s1,s2) t = (s1) &amp; (s2)<br>#define ANDC(t,s1,s2) t = ~(s1) &amp; (s2)<br>#define ANDL(t,s1,s2) t = ((((s1) == 0) | ((s2) == 0)) ? 0 : 1)<br>#define CMPEQ(t,s1,s2) t = ((s1) == (s2))<br>#define CMPNE(t,s1,s2) t = ((s1) != (s2))<br>#define CMPGT(t,s1,s2) t = (INT32(s1) &gt; INT32(s2))<br>#define CMPGE(t,s1,s2) t = (INT32(s1) &gt;= INT32(s2))<br>#define CMPLT(t,s1,s2) t = (INT32(s1) &lt; INT32(s2))<br>#define CMPLE(t,s1,s2) t = (INT32(s1) &lt;= INT32(s2))<br>#define CMPGTU(t,s1,s2) t = (UINT32(s1) &gt; UINT32(s2))<br>#define CMPGEU(t,s1,s2) t = (UINT32(s1) &gt;= UINT32(s2))<br>#define CMPLTU(t,s1,s2) t = (UINT32(s1) &lt; UINT32(s2))<br>#define CMPLEU(t,s1,s2) t = (UINT32(s1) &lt;= UINT32(s2))<br>#define MOV(t,s1) t = s1<br>#define MPYL(t,s1,s2) t = (s1) * INT16(s2)</span></nobr></DIV>
</DIV>
<!-- Page 12 -->
<a name="12"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="white.png" alt="background image">
<DIV style="position:absolute;top:82;left:135"><nobr><span class="ft40">#define MPYH(t,s1,s2) t = (s1) * INT16((s2) &gt;&gt; 16)<br>#define MPYHS(t,s1,s2) t = ((s1) * INT16((s2) &gt;&gt; 16)) &lt;&lt; 16<br>#define MPYLU(t,s1,s2) t = (s1) * UINT16(s2)<br>#define MPYHU(t,s1,s2) t = (s1) * UINT16((s2) &gt;&gt; 16)<br>#define MPYLL(t,s1,s2) t = INT16(s1) * INT16(s2)<br>#define MPYLH(t,s1,s2) t = INT16(s1) * INT16((s2) &gt;&gt; 16)<br>#define MPYHH(t,s1,s2) t = INT16((s1) &gt;&gt; 16) * INT16((s2) &gt;&gt; 16)<br>#define MPYLLU(t,s1,s2) t = UINT16(s1) * UINT16(s2)<br>#define MPYLHU(t,s1,s2) t = UINT16(s1) * UINT16((s2) &gt;&gt; 16)<br>#define MPYHHU(t,s1,s2) t = UINT16((s1) &gt;&gt; 16) * UINT16((s2) &gt;&gt; 16)<br>#define NANDL(t,s1,s2) t = (((s1) == 0) | ((s2) == 0)) ? 1 : 0<br>#define NOP() /* do nothing */<br>#define NORL(t,s1,s2) t = (((s1) == 0) &amp; ((s2) == 0)) ? 1 : 0<br>#define ORL(t,s1,s2) t = (((s1) == 0) &amp; ((s2) == 0)) ? 0 : 1<br>#define OR(t,s1,s2) t = (s1) | (s2)<br>#define ORC(t,s1,s2) t = (~(s1)) | (s2)<br>#define SH1ADD(t,s1,s2) t = ((s1) &lt;&lt; 1) + (s2)<br>#define SH2ADD(t,s1,s2) t = ((s1) &lt;&lt; 2) + (s2)<br>#define SH3ADD(t,s1,s2) t = ((s1) &lt;&lt; 3) + (s2)<br>#define SH4ADD(t,s1,s2) t = ((s1) &lt;&lt; 4) + (s2)<br>#define SHL(t,s1,s2) t = (INT32(s1)) &lt;&lt; (s2)<br>#define SHR(t,s1,s2) t = (INT32(s1)) &gt;&gt; (s2)<br>#define SHRU(t,s1,s2) t = (UINT32(s1)) &gt;&gt; (s2)<br>#define SLCT(t,s1,s2,s3)  t = UINT32(((s1) == 1) ? (s2) : (s3))<br>#define SLCTF(t,s1,s2,s3) t = UINT32(((s1) == 0) ? (s2) : (s3))<br>#define SUB(t,s1,s2) t = (s1) - (s2)<br>#define SXTB(t,s1) t = UINT32((INT32((s1) &lt;&lt; 24)) &gt;&gt; 24)<br>#define SXTH(t,s1) t = UINT32((INT32((s1) &lt;&lt; 16)) &gt;&gt; 16)<br>#define XOR(t,s1,s2) t = (s1) ^ (s2)<br>#define XNOP(n) /* do nothing */<br>#define ZXTB(t,s1) t = ((s1) &amp; 0xff)<br>#define ZXTH(t,s1) t = ((s1) &amp; 0xffff)</span></nobr></DIV>
<DIV style="position:absolute;top:577;left:135"><nobr><span class="ft41">/* Carry Manipulation */<br>#define ADDCG(t,cout,s1,s2,cin) { \<br>    t = (s1) + (s2) + ((cin) &amp; 0x1); \<br>    cout =   ((cin) &amp; 0x1) \<br>           ? (UINT32(t) &lt;= UINT32(s1)) \<br>           : (UINT32(t) &lt;  UINT32(s1)); \<br>}<br>#define DIVS(t,cout,s1,s2,cin) { \<br>    unsigned tmp = ((s1) &lt;&lt; 1) | (cin); \<br>    cout = UINT32(s1) &gt;&gt; 31; \<br>    t = cout ? tmp + (s2) : tmp - (s2); \<br>}</span></nobr></DIV>
<DIV style="position:absolute;top:772;left:135"><nobr><span class="ft40">/* Basic Control Operations */<br>#define goto_instr(X) /* jumps to the instruction at address "x" */<br>#define next_instr() /* address of the instr following address "x" */</span></nobr></DIV>
<DIV style="position:absolute;top:832;left:135"><nobr><span class="ft41">#define BR(b1,off)  if (b1 == 1)  goto_instr(off)<br>#define BRF(b1,off) if (b1 == 0) goto_instr(off)<br>#define GOTO(off)   goto_instr(off)<br>#define IGOTO(lr)   goto_instr(lr) /* "lr" is the link reg (l0)*/<br>#define CALL(off,lr)   { lr = next_instr(); goto_instr(off); }<br>#define ICALL(off) { lr = next_instr(); goto_instr(s1); }<br>#define RETURN(sp,off,lr) { sp += off; goto_instr(lr); }</span></nobr></DIV>
<DIV style="position:absolute;top:961;left:81"><nobr><span class="ft7"><b>2 The VEX Run-Time Architecture</b></span></nobr></DIV>
<DIV style="position:absolute;top:1003;left:81"><nobr><span class="ft6">This VEX <i>Run-Time Architecture</i> (RTA) defines the common software conventions necessary to compile, link, and execute a<br>VEX program. In other systems, it is sometimes also called <i>Application Binary Interface </i>(ABI). VEX applications run in a 32-<br>bit environment and use the &quot;ILP32&quot; data model: where integers, long, and pointers are 32 bits. Within this specification, <i>half-<br>word</i></span></nobr></DIV>
<DIV style="position:absolute;top:1057;left:111"><nobr><span class="ft1"> refers to a 16-bit object, <i>word</i> refers to a 32-bit object, and <i>doubleword</i> refers to a 64-bit object</span></nobr></DIV>
<DIV style="position:absolute;top:1075;left:94"><nobr><span class="ft1">In the following we focus on a RTA model that is well suited for embedded systems, since it is restricted to a <i>single</i>, <i>stati-</i></span></nobr></DIV>
</DIV>
<!-- Page 13 -->
<a name="13"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft42{font-size:11px;line-height:16px;font-family:Helvetica;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="vex013.png" alt="background image">
<DIV style="position:absolute;top:81;left:81"><nobr><span class="ft5"><i>cally bound</i>,<i> non-relocatable</i> load module. This model does not support dynamically-linked libraries, allows the use of abso-<br>lute addresses, and it does not use function descriptors or a global data pointer.</span></nobr></DIV>
<DIV style="position:absolute;top:136;left:81"><nobr><span class="ft17"><b>2.1 Data Allocation and Layout</b></span></nobr></DIV>
<DIV style="position:absolute;top:169;left:81"><nobr><span class="ft5">This section describes how to access and layout various types of data objects in the VEX world. All VEX items greater than 8<br>bytes must all be aligned on a 16-byte boundary. Smaller data items must be aligned on the next larger power-of-two boundary.<br>In other words, 1-byte objects have no alignment restrictions, 2-byte objects have to be aligned <i>0 mod 2</i>; objects of size 3 and<br>4: <i>0 mod 4</i>; objects of size 5 to 8: <i>0 mod 8</i>; and so on</span></nobr></DIV>
<DIV style="position:absolute;top:247;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:248;left:102"><nobr><span class="ft22"><b>Global variables</b>. Common blocks, dynamically allocated regions (such as object returned by <i>malloc()</i>), and external data<br>access are made with an <i>absolute address</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:290;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:291;left:102"><nobr><span class="ft3"><b>Local static data</b> accesses are made with an <i>absolute address</i></span></nobr></DIV>
<DIV style="position:absolute;top:316;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:317;left:102"><nobr><span class="ft27"><b>Local memory stack variables</b> accesses are relative to the stack-pointer register. Stack frames must always be aligned on<br>a 32-byte boundary. That is, the stack pointer register must always be aligned on a 32-byte boundary.</span></nobr></DIV>
<DIV style="position:absolute;top:359;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:360;left:102"><nobr><span class="ft3"><b>Constants and literals</b>.may be placed in the text or data segments</span></nobr></DIV>
<DIV style="position:absolute;top:384;left:94"><nobr><span class="ft5"><A href="">Table 7 l</a>ists the fundamental scalar data types supported by the VEX architecture (values expressed in bytes).<br> </span></nobr></DIV>
<DIV style="position:absolute;top:771;left:94"><nobr><span class="ft1">Aggregate data types (structures, unions and arrays) assume the alignment of their most strictly aligned component. The size</span></nobr></DIV>
<DIV style="position:absolute;top:789;left:81"><nobr><span class="ft5">of any object, including aggregates and unions, is always a multiple of the object's alignment. An array uses the same align-<br>ment as its elements. Structure and union objects can require padding to meet size and alignment constraints. An entire struc-<br>ture or union object is aligned on the same boundary as its most strictly aligned member; an array object is aligned on the same<br>boundary as its element type. Each structure member is assigned to the lowest available offset with the appropriate alignment.<br>This may require internal padding, depending on the previous member. A structure's size is increased, if necessary, to make it<br>a multiple of the alignment. This may require tail padding, depending on the last member.<A href=""> Figure 4 s</a>hows the layout of typical<br>structures and bitfields.</span></nobr></DIV>
<DIV style="position:absolute;top:934;left:81"><nobr><span class="ft17"><b>2.2 Register Usage</b></span></nobr></DIV>
<DIV style="position:absolute;top:967;left:81"><nobr><span class="ft1">VEX registers are partitioned into the following classes:</span></nobr></DIV>
<DIV style="position:absolute;top:991;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:992;left:102"><nobr><span class="ft27"><b>Scratch registers</b> may be destroyed by a procedure call; the caller must save these registers before a call if needed (also<br>called <i>caller-saves</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:1034;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:1035;left:102"><nobr><span class="ft27"><b>Preserved registers</b> must not be destroyed by a procedure call; the callee must save and restore these registers if used (also<br>called <i>callee-saves</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:1078;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:1079;left:102"><nobr><span class="ft3"><b>Constant registers</b> contain a fixed value that cannot be changed</span></nobr></DIV>
<DIV style="position:absolute;top:434;left:184"><nobr><span class="ft13"><b>Table 7: Scalar data types in VEX</b></span></nobr></DIV>
<DIV style="position:absolute;top:460;left:187"><nobr><span class="ft13"><b>Type</b></span></nobr></DIV>
<DIV style="position:absolute;top:460;left:312"><nobr><span class="ft13"><b>C</b></span></nobr></DIV>
<DIV style="position:absolute;top:460;left:449"><nobr><span class="ft13"><b>Size</b></span></nobr></DIV>
<DIV style="position:absolute;top:460;left:504"><nobr><span class="ft13"><b>Align</b></span></nobr></DIV>
<DIV style="position:absolute;top:460;left:566"><nobr><span class="ft42"><b>Hardware <br>Representation</b></span></nobr></DIV>
<DIV style="position:absolute;top:586;left:187"><nobr><span class="ft13"><b>Integral</b></span></nobr></DIV>
<DIV style="position:absolute;top:496;left:312"><nobr><span class="ft26">char<br>signed char</span></nobr></DIV>
<DIV style="position:absolute;top:496;left:449"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:496;left:504"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:496;left:566"><nobr><span class="ft21">signed byte</span></nobr></DIV>
<DIV style="position:absolute;top:532;left:312"><nobr><span class="ft21">unsigned char</span></nobr></DIV>
<DIV style="position:absolute;top:532;left:449"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:532;left:504"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:532;left:566"><nobr><span class="ft21">unsigned byte</span></nobr></DIV>
<DIV style="position:absolute;top:551;left:312"><nobr><span class="ft26">short<br>signed short</span></nobr></DIV>
<DIV style="position:absolute;top:551;left:449"><nobr><span class="ft21">2</span></nobr></DIV>
<DIV style="position:absolute;top:551;left:504"><nobr><span class="ft21">2</span></nobr></DIV>
<DIV style="position:absolute;top:551;left:566"><nobr><span class="ft21">signed halfword</span></nobr></DIV>
<DIV style="position:absolute;top:587;left:312"><nobr><span class="ft21">unsigned short</span></nobr></DIV>
<DIV style="position:absolute;top:587;left:449"><nobr><span class="ft21">2</span></nobr></DIV>
<DIV style="position:absolute;top:587;left:504"><nobr><span class="ft21">2</span></nobr></DIV>
<DIV style="position:absolute;top:587;left:566"><nobr><span class="ft21">unsigned halfword</span></nobr></DIV>
<DIV style="position:absolute;top:607;left:312"><nobr><span class="ft26">int, signed int<br>long, signed long<br>enum</span></nobr></DIV>
<DIV style="position:absolute;top:607;left:449"><nobr><span class="ft21">4</span></nobr></DIV>
<DIV style="position:absolute;top:607;left:504"><nobr><span class="ft21">4</span></nobr></DIV>
<DIV style="position:absolute;top:607;left:566"><nobr><span class="ft21">signed word</span></nobr></DIV>
<DIV style="position:absolute;top:659;left:312"><nobr><span class="ft26">unsigned int<br>unsigned long</span></nobr></DIV>
<DIV style="position:absolute;top:659;left:449"><nobr><span class="ft21">4</span></nobr></DIV>
<DIV style="position:absolute;top:659;left:504"><nobr><span class="ft21">4</span></nobr></DIV>
<DIV style="position:absolute;top:659;left:566"><nobr><span class="ft21">unsigned word</span></nobr></DIV>
<DIV style="position:absolute;top:704;left:187"><nobr><span class="ft13"><b>Pointer</b></span></nobr></DIV>
<DIV style="position:absolute;top:695;left:312"><nobr><span class="ft26"><i>any-type</i> *<br><i>any-type</i> (*)()</span></nobr></DIV>
<DIV style="position:absolute;top:695;left:449"><nobr><span class="ft21">4</span></nobr></DIV>
<DIV style="position:absolute;top:695;left:504"><nobr><span class="ft21">4</span></nobr></DIV>
<DIV style="position:absolute;top:695;left:566"><nobr><span class="ft21">unsigned word</span></nobr></DIV>
<DIV style="position:absolute;top:741;left:187"><nobr><span class="ft13"><b>Floating point</b></span></nobr></DIV>
<DIV style="position:absolute;top:731;left:312"><nobr><span class="ft21">float</span></nobr></DIV>
<DIV style="position:absolute;top:731;left:449"><nobr><span class="ft21">4</span></nobr></DIV>
<DIV style="position:absolute;top:731;left:504"><nobr><span class="ft21">4</span></nobr></DIV>
<DIV style="position:absolute;top:731;left:566"><nobr><span class="ft21">IEEE single precision</span></nobr></DIV>
<DIV style="position:absolute;top:751;left:312"><nobr><span class="ft21">double</span></nobr></DIV>
<DIV style="position:absolute;top:751;left:449"><nobr><span class="ft21">8</span></nobr></DIV>
<DIV style="position:absolute;top:751;left:504"><nobr><span class="ft21">8</span></nobr></DIV>
<DIV style="position:absolute;top:751;left:566"><nobr><span class="ft21">IEEE double precision</span></nobr></DIV>
</DIV>
<!-- Page 14 -->
<a name="14"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft43{font-size:11px;font-family:Helvetica;color:#ffffff;}
-->
</STYLE>
<IMG width="918" height="1188" src="vex014.png" alt="background image">
<DIV style="position:absolute;top:680;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:681;left:102"><nobr><span class="ft3"><b>Special registers</b>, used in the call/return mechanism</span></nobr></DIV>
<DIV style="position:absolute;top:705;left:81"><nobr><span class="ft5">The following tables <A href="">(Table 8 a</a>n<A href="">d Table 9) </a>show a description of the register usage in VEX. Note that VEX defines a <i>user<br>mode</i> where all the registers are available, and a <i>kernel mode</i> where only a subset of registers are available. The kernel mode is<br>useful to reduce the overhead of context switches that do not require the whole set of registers offered by the processor.</span></nobr></DIV>
<DIV style="position:absolute;top:774;left:174"><nobr><span class="ft13"><b>Table 8: Register Usage in VEX</b></span></nobr></DIV>
<DIV style="position:absolute;top:799;left:177"><nobr><span class="ft13"><b>Register</b></span></nobr></DIV>
<DIV style="position:absolute;top:799;left:334"><nobr><span class="ft13"><b>Class</b></span></nobr></DIV>
<DIV style="position:absolute;top:799;left:440"><nobr><span class="ft13"><b>Usage (user-mode)</b></span></nobr></DIV>
<DIV style="position:absolute;top:799;left:597"><nobr><span class="ft13"><b>Usage (kernel-mode)</b></span></nobr></DIV>
<DIV style="position:absolute;top:819;left:377"><nobr><span class="ft31"><i>General Registers (cluster 0)</i></span></nobr></DIV>
<DIV style="position:absolute;top:838;left:177"><nobr><span class="ft31"><i>$r0.0</i></span></nobr></DIV>
<DIV style="position:absolute;top:838;left:334"><nobr><span class="ft21">Constant</span></nobr></DIV>
<DIV style="position:absolute;top:838;left:440"><nobr><span class="ft21">always zero</span></nobr></DIV>
<DIV style="position:absolute;top:838;left:597"><nobr><span class="ft21">always zero</span></nobr></DIV>
<DIV style="position:absolute;top:857;left:177"><nobr><span class="ft31"><i>$r0.1</i></span></nobr></DIV>
<DIV style="position:absolute;top:857;left:334"><nobr><span class="ft21">Special</span></nobr></DIV>
<DIV style="position:absolute;top:857;left:440"><nobr><span class="ft21">stack pointer</span></nobr></DIV>
<DIV style="position:absolute;top:857;left:597"><nobr><span class="ft21">stack pointer</span></nobr></DIV>
<DIV style="position:absolute;top:877;left:177"><nobr><span class="ft31"><i>$r0.2</i></span></nobr></DIV>
<DIV style="position:absolute;top:877;left:334"><nobr><span class="ft21">Scratch</span></nobr></DIV>
<DIV style="position:absolute;top:877;left:440"><nobr><span class="ft21">struct return pointer </span></nobr></DIV>
<DIV style="position:absolute;top:877;left:597"><nobr><span class="ft21">struct return pointer </span></nobr></DIV>
<DIV style="position:absolute;top:897;left:177"><nobr><span class="ft31"><i>$r0.3-$r0.10</i></span></nobr></DIV>
<DIV style="position:absolute;top:897;left:334"><nobr><span class="ft21">Scratch</span></nobr></DIV>
<DIV style="position:absolute;top:897;left:440"><nobr><span class="ft21">argument/return value</span></nobr></DIV>
<DIV style="position:absolute;top:897;left:597"><nobr><span class="ft21">argument/return value</span></nobr></DIV>
<DIV style="position:absolute;top:916;left:177"><nobr><span class="ft31"><i>$r0.11-$r0.15</i></span></nobr></DIV>
<DIV style="position:absolute;top:916;left:334"><nobr><span class="ft21">Scratch</span></nobr></DIV>
<DIV style="position:absolute;top:916;left:440"><nobr><span class="ft21">temporaries</span></nobr></DIV>
<DIV style="position:absolute;top:916;left:597"><nobr><span class="ft21">temporaries</span></nobr></DIV>
<DIV style="position:absolute;top:936;left:177"><nobr><span class="ft31"><i>$r0.16-$r0.56</i></span></nobr></DIV>
<DIV style="position:absolute;top:936;left:334"><nobr><span class="ft21">Scratch</span></nobr></DIV>
<DIV style="position:absolute;top:936;left:440"><nobr><span class="ft21">temporaries</span></nobr></DIV>
<DIV style="position:absolute;top:945;left:597"><nobr><span class="ft43">(unavailable)</span></nobr></DIV>
<DIV style="position:absolute;top:955;left:177"><nobr><span class="ft31"><i>$r0.57-$r0.63</i></span></nobr></DIV>
<DIV style="position:absolute;top:955;left:334"><nobr><span class="ft21">Preserved</span></nobr></DIV>
<DIV style="position:absolute;top:955;left:440"><nobr><span class="ft21">temporaries(callee-save)</span></nobr></DIV>
<DIV style="position:absolute;top:974;left:177"><nobr><span class="ft31"><i>$l0.0</i></span></nobr></DIV>
<DIV style="position:absolute;top:974;left:334"><nobr><span class="ft21">Special</span></nobr></DIV>
<DIV style="position:absolute;top:974;left:440"><nobr><span class="ft21">link register</span></nobr></DIV>
<DIV style="position:absolute;top:974;left:597"><nobr><span class="ft21">link register</span></nobr></DIV>
<DIV style="position:absolute;top:994;left:362"><nobr><span class="ft31"><i>General Registers (other clusters)</i></span></nobr></DIV>
<DIV style="position:absolute;top:1014;left:177"><nobr><span class="ft31"><i>$ri.0</i></span></nobr></DIV>
<DIV style="position:absolute;top:1014;left:334"><nobr><span class="ft21">Constant</span></nobr></DIV>
<DIV style="position:absolute;top:1014;left:440"><nobr><span class="ft21">always zero</span></nobr></DIV>
<DIV style="position:absolute;top:1014;left:597"><nobr><span class="ft21">always zero</span></nobr></DIV>
<DIV style="position:absolute;top:1033;left:177"><nobr><span class="ft31"><i>$ri.1­$ri.56</i></span></nobr></DIV>
<DIV style="position:absolute;top:1033;left:334"><nobr><span class="ft21">Scratch</span></nobr></DIV>
<DIV style="position:absolute;top:1033;left:440"><nobr><span class="ft21">temporaries</span></nobr></DIV>
<DIV style="position:absolute;top:1043;left:597"><nobr><span class="ft43">(unavailable)</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:177"><nobr><span class="ft31"><i>$ri.57­$ri.63</i></span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:334"><nobr><span class="ft21">Preserved</span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:440"><nobr><span class="ft21">temporaries(callee-save)</span></nobr></DIV>
<DIV style="position:absolute;top:1072;left:379"><nobr><span class="ft31"><i>Branch Registers (cluster 0)</i></span></nobr></DIV>
<DIV style="position:absolute;top:634;left:149"><nobr><span class="ft26"><b>Figure 4   Layout of typical structures and unions (left) and bitfields (right) in VEX. </b>The picture<br>refers to a big-endian byte ordering model. Bit numbering is left-to-right for LSB-to-MSB bits.</span></nobr></DIV>
</DIV>
<!-- Page 15 -->
<a name="15"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft44{font-size:11px;font-family:Helvetica;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="vex015.png" alt="background image">
<DIV style="position:absolute;top:220;left:81"><nobr><span class="ft17"><b>2.3 Stack Layout and Procedure Linkage</b></span></nobr></DIV>
<DIV style="position:absolute;top:699;left:81"><nobr><span class="ft5">The memory stack in VEX is used for spilled registers and parameter passing. It is organized as a stack of procedure frames,<br>beginning with the main program's frame at the base of the stack, and continuing towards the top of the stack with nested pro-<br>cedure calls. The frame for the currently active procedure is at the top of the stack. The memory stack begins at an address<br>determined by the operating system, and grows towards lower memory addresses. The stack pointer register always points to<br>the lowest address in the current frame on the stack.</span></nobr></DIV>
<DIV style="position:absolute;top:789;left:94"><nobr><span class="ft1">Each procedure creates its frame on entry by subtracting its frame size from the stack pointer, and removes its frame from</span></nobr></DIV>
<DIV style="position:absolute;top:807;left:81"><nobr><span class="ft5">the stack on exit by restoring the previous value of the stack pointer, usually by adding its frame size. Not every procedure<br>needs a memory stack frame; however, every non-leaf procedure needs to save at least its return link.</span></nobr></DIV>
<DIV style="position:absolute;top:843;left:94"><nobr><span class="ft5">A procedure frame <A href="">(Figure 5) </a>consists of two regions:<br>1.</span></nobr></DIV>
<DIV style="position:absolute;top:861;left:121"><nobr><span class="ft3"><b>Local storage</b>. A procedure may store local variables, temporaries, and spilled registers in this region</span></nobr></DIV>
<DIV style="position:absolute;top:879;left:94"><nobr><span class="ft1">2.</span></nobr></DIV>
<DIV style="position:absolute;top:879;left:121"><nobr><span class="ft5"><b>Outgoing parameters</b>. Parameters in excess to those passed in registers are stored in this region. A procedure accesses<br>its incoming parameters in the outgoing parameter region of its caller's stack frame</span></nobr></DIV>
<DIV style="position:absolute;top:915;left:94"><nobr><span class="ft1">3.</span></nobr></DIV>
<DIV style="position:absolute;top:915;left:121"><nobr><span class="ft5"><b>Scratch area</b>. A 16-byte region provided as scratch storage for procedures called by the current procedure, so that each<br>procedure may use the 16 bytes at the top of its own frame as scratch memory</span></nobr></DIV>
<DIV style="position:absolute;top:951;left:81"><nobr><span class="ft5">The stack pointer must always be aligned at a 32-byte boundary (i.e., stack frames sizes are a multiple of 32 bytes), and pro-<br>grams may not write below the stack pointer. Most procedures have a fixed size frame. The VEX compiler determines the size<br>required for each region, pads the local storage area to a multiple of 32 bytes, creates the frame by subtracting a constant from<br>the previous stack pointer, and removes the frame by adding the same constant to the stack pointer before returning.</span></nobr></DIV>
<DIV style="position:absolute;top:1037;left:81"><nobr><span class="ft9"><i>Procedure Linkage</i></span></nobr></DIV>
<DIV style="position:absolute;top:1063;left:81"><nobr><span class="ft1">VEX defines the following types of calls:</span></nobr></DIV>
<DIV style="position:absolute;top:1087;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:1088;left:102"><nobr><span class="ft3"><b>Direct calls</b>, made directly to the entry point of the target procedure</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:177"><nobr><span class="ft31"><i>$b0.0­$b0.3</i></span></nobr></DIV>
<DIV style="position:absolute;top:126;left:334"><nobr><span class="ft21">scratch</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:440"><nobr><span class="ft21">temporaries</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:597"><nobr><span class="ft21">temporaries</span></nobr></DIV>
<DIV style="position:absolute;top:145;left:177"><nobr><span class="ft31"><i>$b0.4-$b0.7</i></span></nobr></DIV>
<DIV style="position:absolute;top:145;left:334"><nobr><span class="ft21">scratch</span></nobr></DIV>
<DIV style="position:absolute;top:145;left:440"><nobr><span class="ft21">temporaries</span></nobr></DIV>
<DIV style="position:absolute;top:145;left:597"><nobr><span class="ft43">(unavailable)</span></nobr></DIV>
<DIV style="position:absolute;top:164;left:364"><nobr><span class="ft31"><i>Branch Registers (other clusters)</i></span></nobr></DIV>
<DIV style="position:absolute;top:184;left:177"><nobr><span class="ft31"><i>$bi.0-$bi.7</i></span></nobr></DIV>
<DIV style="position:absolute;top:184;left:334"><nobr><span class="ft21">scratch</span></nobr></DIV>
<DIV style="position:absolute;top:184;left:440"><nobr><span class="ft21">temporaries</span></nobr></DIV>
<DIV style="position:absolute;top:184;left:597"><nobr><span class="ft43">(unavailable)</span></nobr></DIV>
<DIV style="position:absolute;top:254;left:143"><nobr><span class="ft13"><b>Table 9: Detailed register usage in VEX</b></span></nobr></DIV>
<DIV style="position:absolute;top:280;left:436"><nobr><span class="ft31"><i>Cluster 0</i></span></nobr></DIV>
<DIV style="position:absolute;top:299;left:146"><nobr><span class="ft31"><i>$r0.0</i></span></nobr></DIV>
<DIV style="position:absolute;top:299;left:255"><nobr><span class="ft21">Constant register 0; if written to, it represents a <i>bit-bucket </i>(written values are discarded)</span></nobr></DIV>
<DIV style="position:absolute;top:319;left:146"><nobr><span class="ft44"><i><b>$r0.1</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:319;left:255"><nobr><span class="ft26">The <b>stack pointer</b> holds the limit of the current stack frame, which is the address of the<br>stack's bottommost, valid word. At all times, the stack pointer must point to a 0 mod 32<br>aligned area. The stack pointer is also used to access any memory arguments upon<br>entry to a function and is preserved across any functions called by the current function</span></nobr></DIV>
<DIV style="position:absolute;top:388;left:146"><nobr><span class="ft44"><i><b>$r0.2</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:388;left:255"><nobr><span class="ft26"><b>Struct return pointer register</b>. If the function called returns a struct or union value<br>larger than 32 bytes, the register contains, on entry, the appropriately aligned address of<br>the caller-allocated area to contain the value being returned. Scratch otherwise.</span></nobr></DIV>
<DIV style="position:absolute;top:441;left:146"><nobr><span class="ft44"><i><b>$r0.3­$r0.10</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:441;left:255"><nobr><span class="ft26"><b>Argument and return values </b>up to 32 bytes are passed in these registers. Arguments<br>beyond these registers appear in memory (see<A href="vex.html#15"> Section 2.3 &quot;Stack Layout and Procedure<br>Linkage&quot;</a>). Within the called function, these registers are scratch registers.</span></nobr></DIV>
<DIV style="position:absolute;top:493;left:146"><nobr><span class="ft31"><i>$r0.11­$r0.56</i></span></nobr></DIV>
<DIV style="position:absolute;top:493;left:255"><nobr><span class="ft21">Scratch registers (caller-saves) with no specific role in the calling sequence</span></nobr></DIV>
<DIV style="position:absolute;top:513;left:146"><nobr><span class="ft31"><i>$r0.57­$r0.63</i></span></nobr></DIV>
<DIV style="position:absolute;top:513;left:255"><nobr><span class="ft21">Preserved registers (callee-saves) with no specific role in the calling sequence. </span></nobr></DIV>
<DIV style="position:absolute;top:532;left:146"><nobr><span class="ft44"><i><b>$l0.0</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:532;left:255"><nobr><span class="ft26"><b>Link register</b> to store the return address on entry to a procedure. Branch operations<br>read it for indirect local jumps, returns, and indirect function calls.</span></nobr></DIV>
<DIV style="position:absolute;top:568;left:146"><nobr><span class="ft31"><i>$b0.0­$b0.7</i></span></nobr></DIV>
<DIV style="position:absolute;top:568;left:255"><nobr><span class="ft21">Scratch registers (caller-saves) with no specified role in the calling sequence.</span></nobr></DIV>
<DIV style="position:absolute;top:587;left:419"><nobr><span class="ft31"><i>Other Clusters</i></span></nobr></DIV>
<DIV style="position:absolute;top:607;left:146"><nobr><span class="ft31"><i>$ri.0</i></span></nobr></DIV>
<DIV style="position:absolute;top:607;left:255"><nobr><span class="ft21">Constant register 0; if written to, it represents a <i>bit-bucket </i>(written values are discarded)</span></nobr></DIV>
<DIV style="position:absolute;top:627;left:146"><nobr><span class="ft31"><i>$ri.1­$ri.56</i></span></nobr></DIV>
<DIV style="position:absolute;top:627;left:255"><nobr><span class="ft21">Scratch registers (caller-saves) with no specific role in the function calling sequence</span></nobr></DIV>
<DIV style="position:absolute;top:646;left:146"><nobr><span class="ft31"><i>$ri.57­$ri.63</i></span></nobr></DIV>
<DIV style="position:absolute;top:646;left:255"><nobr><span class="ft21">Preserved registers (callee-saves) with no specific role in the calling sequence</span></nobr></DIV>
<DIV style="position:absolute;top:666;left:146"><nobr><span class="ft31"><i>$bi.0­$bi.7</i></span></nobr></DIV>
<DIV style="position:absolute;top:666;left:255"><nobr><span class="ft21">Scratch registers (caller-saves) with no specified role in the calling sequence</span></nobr></DIV>
<DIV style="position:absolute;top:81;left:174"><nobr><span class="ft13"><b>Table 8: Register Usage in VEX</b></span></nobr></DIV>
<DIV style="position:absolute;top:106;left:177"><nobr><span class="ft13"><b>Register</b></span></nobr></DIV>
<DIV style="position:absolute;top:106;left:334"><nobr><span class="ft13"><b>Class</b></span></nobr></DIV>
<DIV style="position:absolute;top:106;left:440"><nobr><span class="ft13"><b>Usage (user-mode)</b></span></nobr></DIV>
<DIV style="position:absolute;top:106;left:597"><nobr><span class="ft13"><b>Usage (kernel-mode)</b></span></nobr></DIV>
</DIV>
<!-- Page 16 -->
<a name="16"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="vex016.png" alt="background image">
<DIV style="position:absolute;top:339;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:340;left:102"><nobr><span class="ft3"><b>Indirect calls </b>made through a function pointer that points to the address of the function entry point for the target function.</span></nobr></DIV>
<DIV style="position:absolute;top:365;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:366;left:102"><nobr><span class="ft27"><b>Special calls</b> made through a special calling convention negotiated between the compiler and the run-time system (e.g.,<br><i>intrinsics </i>calls).</span></nobr></DIV>
<DIV style="position:absolute;top:408;left:94"><nobr><span class="ft1">For all calls, the compiler has to keep the values that live across the call alive in scratch registers, by saving them into pre-</span></nobr></DIV>
<DIV style="position:absolute;top:426;left:81"><nobr><span class="ft5">served registers or on the memory stack; it must set up parameters in registers and memory; then issue the call operation,<br>assuming that the call displacement field is sufficiently wide to reach any target. The call operation saves the return link in the<br>link register.</span></nobr></DIV>
<DIV style="position:absolute;top:696;left:94"><nobr><span class="ft1">At <b>procedure entry,</b> the compiler allocates a frame on the memory stack, if necessary. Then, if it is a non-leaf procedure, it</span></nobr></DIV>
<DIV style="position:absolute;top:714;left:81"><nobr><span class="ft1">must save the return link in the memory stack frame, together with any preserved registers that will be used in this procedure.</span></nobr></DIV>
<DIV style="position:absolute;top:732;left:94"><nobr><span class="ft1">At <b>procedure exit,</b> the compiler is responsible for restoring the return link and any preserved registers that were saved, as</span></nobr></DIV>
<DIV style="position:absolute;top:750;left:81"><nobr><span class="ft5">well as for deallocating the memory stack frame (if created). Finally, the procedure exits by branching through the link register<br>with the <i>return</i> instruction. After the call, any saved values must be restored.</span></nobr></DIV>
<DIV style="position:absolute;top:786;left:94"><nobr><span class="ft3"><b>Parameters</b> are passed in a combination of general registers and memory <A href="">(Figure 6).</a> The first 32 bytes of the parameter list</span></nobr></DIV>
<DIV style="position:absolute;top:804;left:81"><nobr><span class="ft5">are passed in registers, and the rest of the parameters are passed on the memory stack, beginning at the caller's stack pointer<br>plus 16 bytes. The caller uses up to 8 general registers for parameters. To accommodate variable argument lists, there is a fixed<br>correspondence between an argument's position in the parameter list and the register used for general register arguments. This<br>allows a procedure to spill its register arguments easily to memory before stepping through the argument list with a pointer. </span></nobr></DIV>
<DIV style="position:absolute;top:876;left:94"><nobr><span class="ft1">Parameters are first allocated on a conceptual argument list, which is then mapped to a combination of registers and the</span></nobr></DIV>
<DIV style="position:absolute;top:894;left:81"><nobr><span class="ft5">memory stack. The argument list begins at relative address 0, and is allocated towards increasing addresses. Each parameter<br>begins on a 4-byte boundary. Each 4-byte unit in the argument list is called an <i>argument slot</i> (named <i>arg0</i>, <i>arg1</i>,  <i>arg2,...</i>)<i>.<br></i>Parameters may use more than one argument slot, and are aligned and padded within the argument list according to the follow-<br>ing rules:</span></nobr></DIV>
<DIV style="position:absolute;top:971;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:972;left:102"><nobr><span class="ft22">Small integral scalar parameters (smaller than 4 bytes) are padded on the left to a total width of 4 bytes and placed in the<br>next available argument slot</span></nobr></DIV>
<DIV style="position:absolute;top:1015;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:1016;left:102"><nobr><span class="ft1">32-bit integral scalar, pointers and single-precision floating-point parameters are placed in the next available argument slot</span></nobr></DIV>
<DIV style="position:absolute;top:1040;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:1041;left:102"><nobr><span class="ft27">Double-precision floating-point scalar parameters are aligned to an 8-byte boundary (possibly leaving an argument slot<br>empty), and placed in the next two consecutive argument slots</span></nobr></DIV>
<DIV style="position:absolute;top:1084;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:1085;left:102"><nobr><span class="ft1">Aggregates up to 4 bytes in size are padded to 4 bytes and placed in the next available argument slot</span></nobr></DIV>
<DIV style="position:absolute;top:305;left:205"><nobr><span class="ft13"><b>Figure 5   The VEX Procedure Frame</b></span></nobr></DIV>
<DIV style="position:absolute;top:167;left:262"><nobr><span class="ft18">scratch </span></nobr></DIV>
<DIV style="position:absolute;top:180;left:271"><nobr><span class="ft18">area</span></nobr></DIV>
<DIV style="position:absolute;top:167;left:356"><nobr><span class="ft18">outgoing </span></nobr></DIV>
<DIV style="position:absolute;top:180;left:350"><nobr><span class="ft18">param eters</span></nobr></DIV>
<DIV style="position:absolute;top:173;left:505"><nobr><span class="ft18">local storage</span></nobr></DIV>
<DIV style="position:absolute;top:241;left:387"><nobr><span class="ft21">lower addresses</span></nobr></DIV>
<DIV style="position:absolute;top:275;left:240"><nobr><span class="ft21">sp</span></nobr></DIV>
<DIV style="position:absolute;top:275;left:588"><nobr><span class="ft21">previous sp</span></nobr></DIV>
<DIV style="position:absolute;top:93;left:411"><nobr><span class="ft21">frame size</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:256"><nobr><span class="ft18">16 bytes</span></nobr></DIV>
<DIV style="position:absolute;top:167;left:262"><nobr><span class="ft18">scratch </span></nobr></DIV>
<DIV style="position:absolute;top:180;left:271"><nobr><span class="ft18">area</span></nobr></DIV>
<DIV style="position:absolute;top:167;left:356"><nobr><span class="ft18">outgoing </span></nobr></DIV>
<DIV style="position:absolute;top:180;left:350"><nobr><span class="ft18">param eters</span></nobr></DIV>
<DIV style="position:absolute;top:173;left:505"><nobr><span class="ft18">local storage</span></nobr></DIV>
<DIV style="position:absolute;top:241;left:387"><nobr><span class="ft21">lower addresses</span></nobr></DIV>
<DIV style="position:absolute;top:275;left:240"><nobr><span class="ft21">sp</span></nobr></DIV>
<DIV style="position:absolute;top:275;left:588"><nobr><span class="ft21">previous sp</span></nobr></DIV>
<DIV style="position:absolute;top:93;left:411"><nobr><span class="ft21">frame size</span></nobr></DIV>
<DIV style="position:absolute;top:126;left:256"><nobr><span class="ft18">16 bytes</span></nobr></DIV>
<DIV style="position:absolute;top:567;left:208"><nobr><span class="ft18">$r0.3 </span></nobr></DIV>
<DIV style="position:absolute;top:567;left:251"><nobr><span class="ft18">$r0.4 </span></nobr></DIV>
<DIV style="position:absolute;top:567;left:294"><nobr><span class="ft18">$r0.5 </span></nobr></DIV>
<DIV style="position:absolute;top:567;left:338"><nobr><span class="ft18">$r0.6 </span></nobr></DIV>
<DIV style="position:absolute;top:567;left:381"><nobr><span class="ft18">$r0.7 </span></nobr></DIV>
<DIV style="position:absolute;top:567;left:468"><nobr><span class="ft18">$r0.9 </span></nobr></DIV>
<DIV style="position:absolute;top:567;left:425"><nobr><span class="ft18">$r0.8 </span></nobr></DIV>
<DIV style="position:absolute;top:567;left:508"><nobr><span class="ft18">$r0.10 </span></nobr></DIV>
<DIV style="position:absolute;top:501;left:640"><nobr><span class="ft18">arg10 </span></nobr></DIV>
<DIV style="position:absolute;top:514;left:656"><nobr><span class="ft18"> </span></nobr></DIV>
<DIV style="position:absolute;top:501;left:210"><nobr><span class="ft18">arg0 </span></nobr></DIV>
<DIV style="position:absolute;top:514;left:202"><nobr><span class="ft24"> <br> </span></nobr></DIV>
<DIV style="position:absolute;top:501;left:253"><nobr><span class="ft18">arg1 </span></nobr></DIV>
<DIV style="position:absolute;top:514;left:265"><nobr><span class="ft18"> </span></nobr></DIV>
<DIV style="position:absolute;top:501;left:296"><nobr><span class="ft18">arg2 </span></nobr></DIV>
<DIV style="position:absolute;top:514;left:308"><nobr><span class="ft18"> </span></nobr></DIV>
<DIV style="position:absolute;top:501;left:340"><nobr><span class="ft18">arg3 </span></nobr></DIV>
<DIV style="position:absolute;top:514;left:352"><nobr><span class="ft18"> </span></nobr></DIV>
<DIV style="position:absolute;top:501;left:383"><nobr><span class="ft18">arg4 </span></nobr></DIV>
<DIV style="position:absolute;top:514;left:396"><nobr><span class="ft18"> </span></nobr></DIV>
<DIV style="position:absolute;top:501;left:470"><nobr><span class="ft18">arg6 </span></nobr></DIV>
<DIV style="position:absolute;top:514;left:482"><nobr><span class="ft18"> </span></nobr></DIV>
<DIV style="position:absolute;top:501;left:427"><nobr><span class="ft18">arg5 </span></nobr></DIV>
<DIV style="position:absolute;top:514;left:439"><nobr><span class="ft18"> </span></nobr></DIV>
<DIV style="position:absolute;top:501;left:513"><nobr><span class="ft18">arg7 </span></nobr></DIV>
<DIV style="position:absolute;top:514;left:525"><nobr><span class="ft18"> </span></nobr></DIV>
<DIV style="position:absolute;top:501;left:557"><nobr><span class="ft18">arg8 </span></nobr></DIV>
<DIV style="position:absolute;top:514;left:569"><nobr><span class="ft18"> </span></nobr></DIV>
<DIV style="position:absolute;top:501;left:600"><nobr><span class="ft18">arg9 </span></nobr></DIV>
<DIV style="position:absolute;top:514;left:612"><nobr><span class="ft18"> </span></nobr></DIV>
<DIV style="position:absolute;top:501;left:683"><nobr><span class="ft18">arg11 </span></nobr></DIV>
<DIV style="position:absolute;top:514;left:699"><nobr><span class="ft18"> </span></nobr></DIV>
<DIV style="position:absolute;top:623;left:552"><nobr><span class="ft18">16[s p] </span></nobr></DIV>
<DIV style="position:absolute;top:636;left:569"><nobr><span class="ft18"> </span></nobr></DIV>
<DIV style="position:absolute;top:623;left:639"><nobr><span class="ft18">24[sp] </span></nobr></DIV>
<DIV style="position:absolute;top:636;left:656"><nobr><span class="ft18"> </span></nobr></DIV>
<DIV style="position:absolute;top:623;left:595"><nobr><span class="ft18">20[s p] </span></nobr></DIV>
<DIV style="position:absolute;top:636;left:612"><nobr><span class="ft18"> </span></nobr></DIV>
<DIV style="position:absolute;top:623;left:682"><nobr><span class="ft18">28[sp] </span></nobr></DIV>
<DIV style="position:absolute;top:636;left:699"><nobr><span class="ft18"> </span></nobr></DIV>
<DIV style="position:absolute;top:652;left:181"><nobr><span class="ft13"><b>Figure 6   Parameter Passing in VEX</b></span></nobr></DIV>
</DIV>
<!-- Page 17 -->
<a name="17"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft45{font-size:8px;font-family:Helvetica;color:#000000;}
	.ft46{font-size:8px;line-height:11px;font-family:Helvetica;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="vex017.png" alt="background image">
<DIV style="position:absolute;top:82;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:83;left:102"><nobr><span class="ft27">Aggregates larger than 4 bytes are padded to a multiple of 4 bytes, aligned to an 8-byte boundary (possibly leaving an argu-<br>ment slot empty), and placed in as many argument slots as needed</span></nobr></DIV>
<DIV style="position:absolute;top:124;left:94"><nobr><span class="ft1">The first eight argument slots (32 bytes) in the argument list are passed in registers, according to the previous rules, and are</span></nobr></DIV>
<DIV style="position:absolute;top:142;left:81"><nobr><span class="ft5">associated, one-to-one, with the procedure arguments. If an aggregate parameter straddles the boundary between <i>arg7</i> and<br><i>arg8</i>, the part that lies within the first eight slots is passed in registers, and the remainder is passed in memory. The remainder<br>of the parameter list, beginning with <i>arg8</i>, is passed in the outgoing parameter area of the memory stack frame. Parameters are<br>mapped directly to memory, with <i>arg8</i> placed at location <i>sp+16</i>, <i>arg9</i> at <i>sp+20</i>, and so on.</span></nobr></DIV>
<DIV style="position:absolute;top:214;left:94"><nobr><span class="ft1">A function with variable arguments may assume that the first eight variable arguments can all be found in the argument reg-</span></nobr></DIV>
<DIV style="position:absolute;top:232;left:81"><nobr><span class="ft5">isters. It may then store these registers to memory, using the 16-byte scratch area for <i>$r0.7­$r0.10</i>, and using up to 16 bytes at<br>the base of its own stack frame for <i>$r0.3­$r0.6</i>. This arrangement places all the variable parameters in one contiguous block of<br>memory.</span></nobr></DIV>
<DIV style="position:absolute;top:286;left:94"><nobr><span class="ft1">Return values follow rules similar to arguments:</span></nobr></DIV>
<DIV style="position:absolute;top:310;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:311;left:102"><nobr><span class="ft22">Integral and floating-point values up to 4 bytes are returned in <i>$r0.3</i>. For smaller integers, the contents of the upper bits<br>must be zero-filled (if unsigned) or sign-extended (if signed) to 4 bytes</span></nobr></DIV>
<DIV style="position:absolute;top:353;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:354;left:102"><nobr><span class="ft1">64-bit floating-point values are returned in <i>$r0.3</i> and <i>$r0.4</i></span></nobr></DIV>
<DIV style="position:absolute;top:379;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:380;left:102"><nobr><span class="ft27">Aggregates smaller than 32 bytes are padded to a multiple of 4 bytes, and returned in successive general registers begin-<br>ning with <i>$r0.3</i></span></nobr></DIV>
<DIV style="position:absolute;top:422;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:423;left:102"><nobr><span class="ft27">Return values larger than 32 bytes are returned in a buffer allocated by the caller. A pointer to the buffer is passed to the<br>called procedure in <i>$r0.2</i></span></nobr></DIV>
<DIV style="position:absolute;top:485;left:81"><nobr><span class="ft7"><b>3 The VEX C Compiler</b></span></nobr></DIV>
<DIV style="position:absolute;top:528;left:81"><nobr><span class="ft5">The VEX development system (sometimes referred to as the <i>VEX toolchain</i>) includes the set of tools that allow C programs<br>compiled for a VEX target to be simulated on a host workstation. The center of the VEX toolchain is the Multiflow/VEX C<br>compiler. The VEX toolchain is mainly intended for architecture exploration, application development, and benchmarking. It<br>includes a very fast architectural simulator that uses a form of binary translation to convert VEX assembler files to native bina-<br>ries running on the host workstation. The translator annotates the binaries to collect execution statistics and includes an<br>(optional) cache simulator to collect D-cache and I-cache data.<A href=""> Figure 7 </a>shows the overall structure of the VEX toolchain.</span></nobr></DIV>
<DIV style="position:absolute;top:1081;left:94"><nobr><span class="ft1">A command-line interface controls the toolchain). The first level C compiler driver (<i>"cc")</i> hides all the steps involved in</span></nobr></DIV>
<DIV style="position:absolute;top:720;left:424"><nobr><span class="ft45"><b>V E X  </b></span></nobr></DIV>
<DIV style="position:absolute;top:732;left:401"><nobr><span class="ft45"><b>a s s e m b le r  </b></span></nobr></DIV>
<DIV style="position:absolute;top:743;left:424"><nobr><span class="ft45"><b>f il e s  </b></span></nobr></DIV>
<DIV style="position:absolute;top:755;left:428"><nobr><span class="ft45"><b>( . s )  </b></span></nobr></DIV>
<DIV style="position:absolute;top:662;left:382"><nobr><span class="ft45"><b>V E X   C   c o m p i l e r  </b></span></nobr></DIV>
<DIV style="position:absolute;top:850;left:423"><nobr><span class="ft45"><b>s 2 c s  </b></span></nobr></DIV>
<DIV style="position:absolute;top:905;left:439"><nobr><span class="ft46"><b> <br> </b></span></nobr></DIV>
<DIV style="position:absolute;top:1001;left:399"><nobr><span class="ft45"><b>H o s t   b in a r y  </b></span></nobr></DIV>
<DIV style="position:absolute;top:883;left:424"><nobr><span class="ft45"><b>H o s t  </b></span></nobr></DIV>
<DIV style="position:absolute;top:895;left:418"><nobr><span class="ft45"><b>o b j e c t  </b></span></nobr></DIV>
<DIV style="position:absolute;top:907;left:426"><nobr><span class="ft45"><b>f i l e s  </b></span></nobr></DIV>
<DIV style="position:absolute;top:953;left:400"><nobr><span class="ft45"><b>H o s t   li n k e r  </b></span></nobr></DIV>
<DIV style="position:absolute;top:883;left:303"><nobr><span class="ft45"><b>H o s t  </b></span></nobr></DIV>
<DIV style="position:absolute;top:895;left:292"><nobr><span class="ft45"><b>s u p p o r t  </b></span></nobr></DIV>
<DIV style="position:absolute;top:907;left:289"><nobr><span class="ft45"><b>l i b r a r i e s  </b></span></nobr></DIV>
<DIV style="position:absolute;top:883;left:534"><nobr><span class="ft45"><b>H o s t  </b></span></nobr></DIV>
<DIV style="position:absolute;top:895;left:528"><nobr><span class="ft45"><b>o b j e c t  </b></span></nobr></DIV>
<DIV style="position:absolute;top:907;left:536"><nobr><span class="ft45"><b>f i l e s  </b></span></nobr></DIV>
<DIV style="position:absolute;top:784;left:256"><nobr><span class="ft45"><b>C o m p i le d   S i m u l a t o r   T o o l c h a in  </b></span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:217"><nobr><span class="ft13"><b>Figure 7   Structure of the VEX toolchain</b></span></nobr></DIV>
</DIV>
<!-- Page 18 -->
<a name="18"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft47{font-size:11px;line-height:15px;font-family:Times;color:#000000;}
	.ft48{font-size:11px;line-height:14px;font-family:Times;color:#000000;}
	.ft49{font-size:11px;line-height:16px;font-family:Helvetica;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="vex018.png" alt="background image">
<DIV style="position:absolute;top:81;left:81"><nobr><span class="ft5">getting from a C program to an VEX "executable". The toolchain directory tree looks like a standard compiler development<br>tree, with a <i>/bin </i>directory containing tools, a <i>/lib</i> directory for libraries, a <i>/usr/include </i>directory for headers, and so on.</span></nobr></DIV>
<DIV style="position:absolute;top:117;left:94"><nobr><span class="ft1">The VEX <i>compiled simulator</i> uses a binary translator to generate an executable binary for the host platform that contains the</span></nobr></DIV>
<DIV style="position:absolute;top:135;left:81"><nobr><span class="ft5">operations to simulate a program compiler for VEX. For example, assuming that we want to compile two files <i>file1.c  </i>and<br><i>file2.c</i> into a Linux binary <i>a.out</i>, the set of command to issue is:</span></nobr></DIV>
<DIV style="position:absolute;top:185;left:135"><nobr><span class="ft14">$[1] &lt;vex&gt;/bin/cc ­c file1.c<br>$[2] &lt;vex&gt;/bin/cc ­c file2.c<br>$[3] &lt;vex&gt;/bin/cc ­o a.out file1.o file2.o</span></nobr></DIV>
<DIV style="position:absolute;top:238;left:94"><nobr><span class="ft1">Command 1 causes the following steps to be executed:</span></nobr></DIV>
<DIV style="position:absolute;top:257;left:135"><nobr><span class="ft47">&lt;vex&gt;/bin/cc<i># cc shell<br></i>  &lt;vex&gt;/lib/rcc<i># "real" cc driver<br></i>    &lt;vex&gt;/lib/cpp &lt;cpp_flags&gt; file1.c file1.i <i># C preprocessor<br></i>    &lt;vex&gt;/lib/ccom &lt;ccom_flags&gt; file1.i file1.s <i># C compiler<br></i>    &lt;vex&gt;/lib/as &lt;as_flags&gt; <i># Assembler driver<br></i>      &lt;vex&gt;/lib/s2cs &lt;s2cs_flags&gt; file1.s file1.cs.c  <i># Compiled Simulator</i></span></nobr></DIV>
<DIV style="position:absolute;top:347;left:184"><nobr><span class="ft47">&lt;host&gt;/cc ­c file1.cs.c<i># Host C compiler<br></i>&lt;host&gt;/mv  file1.cs.o file1.o <i># Move host object file</i></span></nobr></DIV>
<DIV style="position:absolute;top:391;left:94"><nobr><span class="ft5">Command 2 causes the equivalent sequence on "file2.c". <br>Command [3] causes the following steps to be executed:</span></nobr></DIV>
<DIV style="position:absolute;top:428;left:135"><nobr><span class="ft48">&lt;vex&gt;/bin/cc<i># cc shell<br></i>  &lt;vex&gt;/lib/rcc<i># "real" cc driver<br></i>    &lt;vex&gt;/bin/ld &lt;ld_flags&gt; file1.o file1.o ­o a.exe <i># Linker driver<br></i>      &lt;host&gt;/cc  -o a.exe<i># Linux C linker/loader<br></i>                &lt;vex&gt;/lib/crt0.o <i># VEX C runtime initialization<br></i>                file1.o file2.o  <i># Application object files<br></i>                &lt;vex&gt;/lib/libc.a <i># VEX C library</i></span></nobr></DIV>
<DIV style="position:absolute;top:533;left:259"><nobr><span class="ft10">libcache.sl</span></nobr></DIV>
<DIV style="position:absolute;top:533;left:413"><nobr><span class="ft10"># Cache simulation library</span></nobr></DIV>
<DIV style="position:absolute;top:548;left:135"><nobr><span class="ft10">                ldcs.a</span></nobr></DIV>
<DIV style="position:absolute;top:548;left:402"><nobr><span class="ft16"><i># Simulation support library</i></span></nobr></DIV>
<DIV style="position:absolute;top:563;left:135"><nobr><span class="ft10">                &lt;host&gt;/libc.so.6 <i># Linux C library</i></span></nobr></DIV>
<DIV style="position:absolute;top:592;left:94"><nobr><span class="ft1">Once steps 1 to 3 complete, we obtain a host executable binary <i>a.out</i> that can be executed simply by invoking it. The file</span></nobr></DIV>
<DIV style="position:absolute;top:610;left:81"><nobr><span class="ft5"><i>a.out</i> contains the compiled simulator image of the user application compiled for VEX and converted back into host object for-<br>mat. The image also contains various simulation helper functions, and the D-cache/I-cache simulators.</span></nobr></DIV>
<DIV style="position:absolute;top:646;left:94"><nobr><span class="ft1">According to compile-time flags, the user can select different level of accuracy for the simulation:</span></nobr></DIV>
<DIV style="position:absolute;top:670;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:671;left:102"><nobr><span class="ft5">The  <b>default mode </b>produces an executable that reproduces the correct behavior, and collects standard additional timing<br>information for a set of default arechitecture parameters. The executable includes instrumentation code that counts execu-<br>tion statistics and optionally invokes the I-cache and the D-cache simulators. This mode can be used to benchmark applica-<br>tions and to evaluate the benefit of code transformations and compiler optimizations. Execution statistics are emitted in text<br>form in files called "<i>ta.log.###</i>" that are emitted at program exit.</span></nobr></DIV>
<DIV style="position:absolute;top:768;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:768;left:102"><nobr><span class="ft5">When compiled with <b>profiling flags</b> (<i>-mas_G</i>) the executable includes instrumentation code that collects execution statis-<br>tics and emits a file that can be interpreted by <i>gprof </i>to visualize profile data. This mode uses the native profiling support in<br>the host C compiler to emit calls to the profiling routines at every routine entry point. At program exit the profile data is<br>emitted so that <i>gprof</i>  correctly interprets <i>simulated time.</i> </span></nobr></DIV>
<DIV style="position:absolute;top:846;left:94"><nobr><span class="ft1">In default compilation mode, the intermediate steps are hidden to the user, and intermediate files (stored temporarily in the <i>/</i></span></nobr></DIV>
<DIV style="position:absolute;top:864;left:81"><nobr><span class="ft5"><i>tmp</i> directory) are removed after compilation, or on errors. To keep intermediate files, it is necessary to add the ­<i>mas_g </i>and ­<br><i>ms </i>flags to the compilation. <A href="">Table 10 li</a>sts the relevant file suffixes generated by the VEX toolchain.</span></nobr></DIV>
<DIV style="position:absolute;top:933;left:148"><nobr><span class="ft13"><b>Table 10: File types in the VEX Toolchain</b></span></nobr></DIV>
<DIV style="position:absolute;top:958;left:152"><nobr><span class="ft21">File type</span></nobr></DIV>
<DIV style="position:absolute;top:958;left:308"><nobr><span class="ft21">Description</span></nobr></DIV>
<DIV style="position:absolute;top:978;left:152"><nobr><span class="ft21">file.c</span></nobr></DIV>
<DIV style="position:absolute;top:978;left:308"><nobr><span class="ft21">C source file</span></nobr></DIV>
<DIV style="position:absolute;top:997;left:152"><nobr><span class="ft21">file.i</span></nobr></DIV>
<DIV style="position:absolute;top:997;left:308"><nobr><span class="ft26">C preprocessed file, normally removed. Temporarily stored by the <i>rcc </i>driver as<br><i>/tmp/cpp####</i></span></nobr></DIV>
<DIV style="position:absolute;top:1033;left:152"><nobr><span class="ft21">file.s</span></nobr></DIV>
<DIV style="position:absolute;top:1033;left:308"><nobr><span class="ft49">VEX assembly file, normally removed. Temporarily stored by the <i>rcc</i> driver as <i>/<br>tmp/com####</i></span></nobr></DIV>
<DIV style="position:absolute;top:1069;left:152"><nobr><span class="ft21">file.cs.c</span></nobr></DIV>
<DIV style="position:absolute;top:1069;left:308"><nobr><span class="ft26">VEX compiled simulator translated file, normally removed. Temporarily stored<br>by the <i>as</i> driver as <i>/tmp/csim####.c</i></span></nobr></DIV>
</DIV>
<!-- Page 19 -->
<a name="19"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="vex019.png" alt="background image">
<DIV style="position:absolute;top:355;left:81"><nobr><span class="ft17"><b>3.1 Command-line Options</b></span></nobr></DIV>
<DIV style="position:absolute;top:388;left:81"><nobr><span class="ft5">The <i>cc</i> program is the driver for the VEX C Compiler. It supports the C language, as Defined by Kernighan and Ritchie in<br><i>"The C Programming Language"</i>, and the ISO C89 standard. A compilation command looks like this:</span></nobr></DIV>
<DIV style="position:absolute;top:439;left:135"><nobr><span class="ft10">cc -o outputfile source1 source2 . . . sourceN</span></nobr></DIV>
<DIV style="position:absolute;top:465;left:81"><nobr><span class="ft5">where <i>outputfile</i> is the name of the object file (or executable file) that you wish to create, and <i>source1</i> through <i>sourceN</i> are C<br>source files and compiled object modules. The C compiler determines how to process these files on the basis of their filename,<br>as follows.</span></nobr></DIV>
<DIV style="position:absolute;top:524;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:525;left:102"><nobr><span class="ft5">Files whose names end with `<i>.c</i>' are taken to be C source programs; they are preprocessed, compiled, and assembled, and<br>each object program is left on the file whose name is that of the source with `.o' substituted for `.c'. The `.o' file is nor-<br>mally deleted. By default, `.c' files are compiled as ISO/ANSI C.</span></nobr></DIV>
<DIV style="position:absolute;top:586;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:587;left:102"><nobr><span class="ft27">Files whose names end with `<i>.s</i>' are taken to be assembly source programs and are preprocessed and assembled, producing<br>a `.o' file.</span></nobr></DIV>
<DIV style="position:absolute;top:629;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:630;left:102"><nobr><span class="ft1">Files whose names end with `<i>.i</i>' are taken to be compiler source programs and are not preprocessed.</span></nobr></DIV>
<DIV style="position:absolute;top:654;left:94"><nobr><span class="ft1">Optimization is in effect by default. For more information about optimization, see the -O options (below). The following</span></nobr></DIV>
<DIV style="position:absolute;top:672;left:81"><nobr><span class="ft1">options (grouped by category) are interpreted by <i>cc</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:704;left:81"><nobr><span class="ft9"><i>Output Files</i></span></nobr></DIV>
<DIV style="position:absolute;top:730;left:81"><nobr><span class="ft1">This set of options determines which stages the compiler will execute, and which files it will leave after finishing.</span></nobr></DIV>
<DIV style="position:absolute;top:1027;left:81"><nobr><span class="ft9"><i>Preprocessing</i></span></nobr></DIV>
<DIV style="position:absolute;top:1053;left:81"><nobr><span class="ft6">Before compiling the program, the compiler invokes the standard GNU C preprocessor (<i>cpp</i>), which provides features like<br>macro expansion and conditional compilation. The options in this set control cpp. Note that when using the K&amp;R mode (<i>­KR<br></i>switch) the preprocessor is invoked with the "<i>­traditional</i>" switch, while the default mode of the preprocessor is invoked when</span></nobr></DIV>
<DIV style="position:absolute;top:106;left:152"><nobr><span class="ft21">file.o</span></nobr></DIV>
<DIV style="position:absolute;top:106;left:308"><nobr><span class="ft26">Host object file containing the compilation of the CS translated file. Perma-<br>nently saved for the link step for compilations with the ­<i>c</i> flag</span></nobr></DIV>
<DIV style="position:absolute;top:142;left:152"><nobr><span class="ft21">a.out</span></nobr></DIV>
<DIV style="position:absolute;top:142;left:308"><nobr><span class="ft26">Host executable image containing the binary representing the user application<br>and the simulation routines</span></nobr></DIV>
<DIV style="position:absolute;top:178;left:152"><nobr><span class="ft21">ta.log.###</span></nobr></DIV>
<DIV style="position:absolute;top:178;left:308"><nobr><span class="ft21">Output of the simulation, containing simulation and cache statistics</span></nobr></DIV>
<DIV style="position:absolute;top:197;left:152"><nobr><span class="ft26">gmon.out<br>gmon-nocache.out<br>gmon-icache.out<br>gmon-dcache.out</span></nobr></DIV>
<DIV style="position:absolute;top:197;left:308"><nobr><span class="ft26">Output of the simulation when compiled with profiling flag on (<i>-mas_G</i>). Each<br>of the "gmon-" file contains the gprof database, for cumulative data, execution<br>data (<i>nocache</i>), instruction and data cache only (<i>icache, dcache</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:267;left:152"><nobr><span class="ft21">database.ifprob</span></nobr></DIV>
<DIV style="position:absolute;top:267;left:308"><nobr><span class="ft26">Output of the VEX compiler when compiling for profile data collection for Pro-<br>file-Based Optimization (<i>-prob_gen</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:303;left:152"><nobr><span class="ft26">ifprob.out<br>ifprob.###</span></nobr></DIV>
<DIV style="position:absolute;top:303;left:308"><nobr><span class="ft26">Output of the simulation when collecting profile data for Profile-Based Optimi-<br>zation (<i>-prob_gen</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:769;left:149"><nobr><span class="ft13"><b>-o output</b></span></nobr></DIV>
<DIV style="position:absolute;top:769;left:267"><nobr><span class="ft26">Give the name output to the executable file produced by the loader, rather than the<br>default name a.out. If this option is used, and the file `a.out' already exists, it will be<br>left undisturbed.</span></nobr></DIV>
<DIV style="position:absolute;top:828;left:149"><nobr><span class="ft13"><b>-c</b></span></nobr></DIV>
<DIV style="position:absolute;top:827;left:267"><nobr><span class="ft26">Suppress the loading phase of the compilation; do not delete the `.o' files produced<br>by the assembler. These files may be loaded by cc or ld at a later time.</span></nobr></DIV>
<DIV style="position:absolute;top:870;left:149"><nobr><span class="ft13"><b>-S</b></span></nobr></DIV>
<DIV style="position:absolute;top:870;left:267"><nobr><span class="ft26">Compile the named C programs, and leave the assembler-language output on corre-<br>sponding files suffixed `.s'. No `.o' file is produced.</span></nobr></DIV>
<DIV style="position:absolute;top:911;left:149"><nobr><span class="ft13"><b>-E</b></span></nobr></DIV>
<DIV style="position:absolute;top:911;left:267"><nobr><span class="ft26">Run only the standard preprocessor on the named C programs, and send the result<br>to the standard output. (See «Preprocessing.")</span></nobr></DIV>
<DIV style="position:absolute;top:954;left:149"><nobr><span class="ft13"><b>-M</b></span></nobr></DIV>
<DIV style="position:absolute;top:953;left:267"><nobr><span class="ft26">Run only the standard preprocessor on the named C programs, requesting it to gen-<br>erate Makefile dependencies and send the result to the standard output. (See "Pre-<br>processing")</span></nobr></DIV>
<DIV style="position:absolute;top:81;left:148"><nobr><span class="ft13"><b>Table 10: File types in the VEX Toolchain</b></span></nobr></DIV>
</DIV>
<!-- Page 20 -->
<a name="20"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="white.png" alt="background image">
<DIV style="position:absolute;top:81;left:81"><nobr><span class="ft1">using the ANSI mode of the compiler (default, or <i>-mfansi</i> switch).</span></nobr></DIV>
<DIV style="position:absolute;top:419;left:81"><nobr><span class="ft9"><i>Optimization</i></span></nobr></DIV>
<DIV style="position:absolute;top:445;left:81"><nobr><span class="ft6">This set of options determines how the compiler will optimize your program. Optimization is in effect by default (i.e., -O2<br>compilation). We only give rough definitions of the different optimization types. Each successive option provides additional<br>optimizations in addition to those performed at the previous levels. By default, the option -O2 is in effect: this will provide<br>good performance for most C programs. The -O4 -H* options should be used with care and on the basis of experimentation. In<br>any large program, a few routines may benefit from these optimization levels. They should not be used for programs as a<br>whole For most compilations, you will not need to specify this option. The more aggressive loop unrolling options (-H2<br>through -H4) should be only be used for routines where experimentation has shown that they are effective. These will typically<br>be routines whose execution time is dominated by a relatively simple loops. Note that the VEX system does not currently sup-<br>port source-level debugging. Although the compiler would correctly generate STABS directive when invoked with a <i>"-g"<br></i>flag, the VEX simulator would ignore them.</span></nobr></DIV>
<DIV style="position:absolute;top:119;left:148"><nobr><span class="ft42"><b>-Dname=def <br>-Dname</b></span></nobr></DIV>
<DIV style="position:absolute;top:119;left:266"><nobr><span class="ft26">Define the name to the preprocessor, as if by `#define'. If no definition is given, the<br>name is defined as "1".</span></nobr></DIV>
<DIV style="position:absolute;top:162;left:148"><nobr><span class="ft13"><b>-Uname</b></span></nobr></DIV>
<DIV style="position:absolute;top:161;left:266"><nobr><span class="ft21">Remove any initial definition of name.</span></nobr></DIV>
<DIV style="position:absolute;top:187;left:148"><nobr><span class="ft13"><b>-Idir</b></span></nobr></DIV>
<DIV style="position:absolute;top:187;left:266"><nobr><span class="ft26">`#include files whose names do not begin with `/' are always sought first in the direc-<br>tory of the file argument, then in directories named in -I options, then in directories on<br>a standard list.</span></nobr></DIV>
<DIV style="position:absolute;top:245;left:148"><nobr><span class="ft13"><b>-C</b></span></nobr></DIV>
<DIV style="position:absolute;top:245;left:266"><nobr><span class="ft26">Prevent the preprocessor from eliding comments. Normally, the preprocessor<br>replaces all commands (i.e., all characters falling between /* and the next */) with a<br>single space.</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:148"><nobr><span class="ft13"><b>-E</b></span></nobr></DIV>
<DIV style="position:absolute;top:304;left:266"><nobr><span class="ft26">Run only the standard preprocessor on the named C programs, and send the result<br>to the standard output.</span></nobr></DIV>
<DIV style="position:absolute;top:346;left:148"><nobr><span class="ft13"><b>-M </b></span></nobr></DIV>
<DIV style="position:absolute;top:346;left:266"><nobr><span class="ft26">Run only the standard preprocessor on the named C programs, requesting it to gen-<br>erate Makefile dependencies and send the result to the standard output. Dependen-<br>cies are generated by analyzing the program's #include statements.</span></nobr></DIV>
<DIV style="position:absolute;top:646;left:150"><nobr><span class="ft13"><b>-O</b></span></nobr></DIV>
<DIV style="position:absolute;top:646;left:249"><nobr><span class="ft21">Equivalent to -O2. This option is in effect by default.</span></nobr></DIV>
<DIV style="position:absolute;top:672;left:150"><nobr><span class="ft13"><b>-On</b></span></nobr></DIV>
<DIV style="position:absolute;top:672;left:249"><nobr><span class="ft21">This series of options controls which optimizations the compiler performs, as follows:</span></nobr></DIV>
<DIV style="position:absolute;top:688;left:260"><nobr><span class="ft13"><b>-O1</b></span></nobr></DIV>
<DIV style="position:absolute;top:688;left:294"><nobr><span class="ft21">All scalar optimizations </span></nobr></DIV>
<DIV style="position:absolute;top:704;left:260"><nobr><span class="ft13"><b>-O2</b></span></nobr></DIV>
<DIV style="position:absolute;top:704;left:294"><nobr><span class="ft21">Minimal loop unrolling and trace scheduling compilation </span></nobr></DIV>
<DIV style="position:absolute;top:721;left:260"><nobr><span class="ft13"><b>-O3</b></span></nobr></DIV>
<DIV style="position:absolute;top:721;left:294"><nobr><span class="ft21">Basic loop unrolling, trace scheduling compilation </span></nobr></DIV>
<DIV style="position:absolute;top:738;left:260"><nobr><span class="ft13"><b>-O4</b></span></nobr></DIV>
<DIV style="position:absolute;top:737;left:294"><nobr><span class="ft21">Heavy loop unrolling (see -H4)</span></nobr></DIV>
<DIV style="position:absolute;top:763;left:150"><nobr><span class="ft13"><b>-Hn</b></span></nobr></DIV>
<DIV style="position:absolute;top:763;left:249"><nobr><span class="ft26">This series of options controls loop unrolling. They override the loop unrolling that is<br>implicitly requested by the -On optimization options </span></nobr></DIV>
<DIV style="position:absolute;top:796;left:260"><nobr><span class="ft13"><b>-H0</b></span></nobr></DIV>
<DIV style="position:absolute;top:796;left:293"><nobr><span class="ft21">No unrolling</span></nobr></DIV>
<DIV style="position:absolute;top:812;left:260"><nobr><span class="ft13"><b>-H1</b></span></nobr></DIV>
<DIV style="position:absolute;top:812;left:293"><nobr><span class="ft21">Basic unrolling</span></nobr></DIV>
<DIV style="position:absolute;top:829;left:260"><nobr><span class="ft13"><b>-H2</b></span></nobr></DIV>
<DIV style="position:absolute;top:829;left:293"><nobr><span class="ft21">Aggressive loop unrolling</span></nobr></DIV>
<DIV style="position:absolute;top:846;left:260"><nobr><span class="ft13"><b>-H3</b></span></nobr></DIV>
<DIV style="position:absolute;top:845;left:293"><nobr><span class="ft21">Heavy loop unrolling</span></nobr></DIV>
<DIV style="position:absolute;top:862;left:260"><nobr><span class="ft13"><b>-H4</b></span></nobr></DIV>
<DIV style="position:absolute;top:862;left:293"><nobr><span class="ft21">Very heavy unrolling</span></nobr></DIV>
<DIV style="position:absolute;top:888;left:150"><nobr><span class="ft13"><b>-lb_limit n</b></span></nobr></DIV>
<DIV style="position:absolute;top:888;left:249"><nobr><span class="ft26">Set the «loop branch limit" to n. The compiler ceases to unroll any loop when the<br>unrolled loops body has n internal branches. Branches to code outside of the loop body<br>are not counted, and therefore do not inhibit unrolling. That is, -lb_limit puts an implicit<br>limit on loop unrolling, supplementing the explicit limit provided by any source code<br>directives or command line options. By default, the loop branch limit is 0; branches<br>internal to a loop inhibits loop unrolling.</span></nobr></DIV>
<DIV style="position:absolute;top:996;left:150"><nobr><span class="ft13"><b>-fexpand-div</b></span></nobr></DIV>
<DIV style="position:absolute;top:996;left:249"><nobr><span class="ft26">Instruct the compiler to replace call to library intrinsics with in-line assembly for integer<br>divide and remainder functions. A single 32-bit division gets expanded to about 60<br>assembler operations and yields to significant code expansion and compile slow-down.<br>To be used with caution - only when division performance is important.</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:150"><nobr><span class="ft13"><b>-fno-xnop</b></span></nobr></DIV>
<DIV style="position:absolute;top:1070;left:249"><nobr><span class="ft21">Do not emit <i>xnop</i> instructions, but emit explicit <i>nop</i> instructions instead.</span></nobr></DIV>
</DIV>
<!-- Page 21 -->
<a name="21"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="white.png" alt="background image">
<DIV style="position:absolute;top:292;left:81"><nobr><span class="ft9"><i>Profiling</i></span></nobr></DIV>
<DIV style="position:absolute;top:318;left:81"><nobr><span class="ft1">The compiler supports profile-based optimization with a three-step compilation process. The options controlling profiling are:</span></nobr></DIV>
<DIV style="position:absolute;top:729;left:94"><nobr><span class="ft5">A typical profile-based compilation involves the following steps <A href="">(Figure 8)<br></a>1.</span></nobr></DIV>
<DIV style="position:absolute;top:747;left:121"><nobr><span class="ft5">Compile with <i>-prob_gen</i> flag, so that the compiler can instrument the code to count branch probability. This information<br>is saved in the <i>database.ifprob </i>directory</span></nobr></DIV>
<DIV style="position:absolute;top:783;left:94"><nobr><span class="ft1">2.</span></nobr></DIV>
<DIV style="position:absolute;top:783;left:121"><nobr><span class="ft5">Run with significant data set, collect the branch statistics and emit them in file at the end of the first run (usually<br><i>ifprob.out)</i></span></nobr></DIV>
<DIV style="position:absolute;top:819;left:94"><nobr><span class="ft1">3.</span></nobr></DIV>
<DIV style="position:absolute;top:819;left:121"><nobr><span class="ft1">Re-compile with <i>-prob_use</i> flag, after having copied the <i>ifprob.out </i>file to the <i>database.ifprob </i>directory</span></nobr></DIV>
<DIV style="position:absolute;top:837;left:94"><nobr><span class="ft1">With the <i>-prob_use</i> flag the VEX compiler uses collected data to pick traces. Trace scheduling favors more probable traces.</span></nobr></DIV>
<DIV style="position:absolute;top:855;left:81"><nobr><span class="ft5">code compaction happens on linear paths, and off-trace paths may be penalized by compensation code. Profiling can have sig-<br>nificant impact on performance.</span></nobr></DIV>
<DIV style="position:absolute;top:905;left:81"><nobr><span class="ft9"><i>Language Definition</i></span></nobr></DIV>
<DIV style="position:absolute;top:931;left:81"><nobr><span class="ft1">These options control certain extensions to the language. By default, the C compiler obeys the ISO/ANSI C definition.</span></nobr></DIV>
<DIV style="position:absolute;top:87;left:150"><nobr><span class="ft13"><b>-fmm=&lt;mmf&gt;</b></span></nobr></DIV>
<DIV style="position:absolute;top:87;left:249"><nobr><span class="ft21">Read machine description parameters (latency, resources, etc.) from file &lt;mmf&gt;</span></nobr></DIV>
<DIV style="position:absolute;top:112;left:150"><nobr><span class="ft13"><b>-autoinline</b></span></nobr></DIV>
<DIV style="position:absolute;top:112;left:249"><nobr><span class="ft26">Enables automatic function inlining. Automatic inlining attempts to inline functions in the<br>same module until an inlining "budget" is reached. The compiler also emits the code for<br>the function being inlined, assuming that the assembler and the linker will remove<br>unused functions.</span></nobr></DIV>
<DIV style="position:absolute;top:187;left:150"><nobr><span class="ft13"><b>-mincode</b></span></nobr></DIV>
<DIV style="position:absolute;top:187;left:249"><nobr><span class="ft26">Turns on a set of flags aiming at minimizing code size of the generated object file. This<br>set of flags usually adversely affects performance and should be used with caution.</span></nobr></DIV>
<DIV style="position:absolute;top:229;left:150"><nobr><span class="ft13"><b>-prefetch</b></span></nobr></DIV>
<DIV style="position:absolute;top:229;left:249"><nobr><span class="ft21">Turns on automatic prefetch insertion</span></nobr></DIV>
<DIV style="position:absolute;top:254;left:150"><nobr><span class="ft13"><b>-cache_hints</b></span></nobr></DIV>
<DIV style="position:absolute;top:254;left:249"><nobr><span class="ft21">Interprets cache locality hints and emits the corresponding memory instructions</span></nobr></DIV>
<DIV style="position:absolute;top:357;left:149"><nobr><span class="ft13"><b>-prob_gen</b></span></nobr></DIV>
<DIV style="position:absolute;top:357;left:228"><nobr><span class="ft26">The compiler annotates conditional branches with code that counts execution statistics<br>(taken/not-taken branches). During this process, it saves the profile information in a file<br>stored in the "<i>database.ifprob</i>" directory, corresponding to the name of the module. The<br>module name and the profile directory can be changed through internal compiler options<br>When the executable is generated, the loader links in a module that contains the routine to<br>dump the profile information. When the executable is run, the exit routine dumps the profile<br>information in a file called "<i>ifprob.out</i>", in the directory where the executable is run. If<br>ifprob.out already exists, the compiler attempts to generate a file called "ifprob.<i>nnn"</i>, where<br><i>nnn</i></span></nobr></DIV>
<DIV style="position:absolute;top:488;left:250"><nobr><span class="ft21"> is an increasing number, until no file with such a name exists.</span></nobr></DIV>
<DIV style="position:absolute;top:514;left:149"><nobr><span class="ft13"><b>-prob_use</b></span></nobr></DIV>
<DIV style="position:absolute;top:514;left:228"><nobr><span class="ft26">The compiler looks for a file called <i>"ifprob.out"</i> in the "<i>database.ifprob"</i> directory. If such a<br>file exists, the compiler assigns branches the probability that has been computed in the pre-<br>vious profile run(s), and uses it to guide the selection of traces during trace scheduling. It is<br>wise to use the same compiler options (except <i>­prob_gen/-prob_use</i>) in both steps of the<br>compilation, to avoid mismatches between branches and profile information. Also note that<br>the compiler uses line numbers to maintain branch information, hence it is possible for the<br>profile information to be imprecise, in particular when multiple branches map to the same<br>source line number. This may happen ­ for example ­ in the presence of large preproces-<br>sor macros. In the cases where the compiler detects inconsistencies in the profile informa-<br>tion, it emits a warning.</span></nobr></DIV>
<DIV style="position:absolute;top:688;left:149"><nobr><span class="ft13"><b>-pg</b></span></nobr></DIV>
<DIV style="position:absolute;top:688;left:228"><nobr><span class="ft21">Generate extra code to write profile information suitable for the analysis program <i>gprof</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:970;left:158"><nobr><span class="ft13"><b>-K+R</b></span></nobr></DIV>
<DIV style="position:absolute;top:970;left:274"><nobr><span class="ft21">Use the language definition given by Kernighan and Ritchie ("traditional" C)</span></nobr></DIV>
<DIV style="position:absolute;top:996;left:158"><nobr><span class="ft13"><b>-mfansi</b></span></nobr></DIV>
<DIV style="position:absolute;top:996;left:274"><nobr><span class="ft21">Use the ANSI/ISO language definition. This is the default.</span></nobr></DIV>
<DIV style="position:absolute;top:1021;left:158"><nobr><span class="ft13"><b>-mfinline</b></span></nobr></DIV>
<DIV style="position:absolute;top:1021;left:274"><nobr><span class="ft21">Allow the Multiflow language extension to manually control inline expansion</span></nobr></DIV>
<DIV style="position:absolute;top:1046;left:158"><nobr><span class="ft13"><b>-c99inline</b></span></nobr></DIV>
<DIV style="position:absolute;top:1046;left:274"><nobr><span class="ft21">Allow c99-style <i>inline </i>keywords to manually control inline expansion</span></nobr></DIV>
</DIV>
<!-- Page 22 -->
<a name="22"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft50{font-size:10px;font-family:Helvetica;color:#000000;}
	.ft51{font-size:10px;font-family:Helvetica;color:#000000;}
	.ft52{font-size:10px;font-family:Helvetica;color:#000000;}
	.ft53{font-size:10px;font-family:Helvetica;color:#000000;}
	.ft54{font-size:22px;font-family:Helvetica;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="vex022.png" alt="background image">
<DIV style="position:absolute;top:711;left:81"><nobr><span class="ft9"><i>Libraries</i></span></nobr></DIV>
<DIV style="position:absolute;top:736;left:81"><nobr><span class="ft5">These options let you link C programs with different subprogram libraries, in addition to the standard libraries. Libraries that<br>are distributed as a part of the VEX compiler are located in the directory <i>&lt;vex_tree&gt;/lib.</i></span></nobr></DIV>
<DIV style="position:absolute;top:925;left:81"><nobr><span class="ft9"><i>Passing Options to Compile Phases</i></span></nobr></DIV>
<DIV style="position:absolute;top:951;left:81"><nobr><span class="ft5">This group of options lets you pass options from the cc command to the preprocessor (cpp), the loader (ld) or the assembler<br>(as). Note that any filename or option that cc does not recognize is automatically passed to the loader. Any manual entry for<br>the GNU C preprocessor lists the available <i>cpp </i>options.</span></nobr></DIV>
<DIV style="position:absolute;top:532;left:158"><nobr><span class="ft13"><b>-funsigned-char</b></span></nobr></DIV>
<DIV style="position:absolute;top:532;left:274"><nobr><span class="ft21">Treat `char' as unsigned (default is signed)</span></nobr></DIV>
<DIV style="position:absolute;top:558;left:158"><nobr><span class="ft13"><b>-align n</b></span></nobr></DIV>
<DIV style="position:absolute;top:557;left:274"><nobr><span class="ft26">This option indicates that all data items larger than n bytes obey their optimal<br>alignment, where n is 1, 4, or 8. For example, the option <i>-align 1 </i>means that any<br>data object may start at any address (i.e., the program does not obey any align-<br>ment restrictions). By default, alignment is eight, stating that the program always<br>observes optimal alignment. When accessing data items whose native alignment<br>is larger than the "forced" alignment, the VEX compiler generates a sequence of<br>extract/merge operations to ensure that the accesses are properly aligned, result-<br>ing in a performance loss.</span></nobr></DIV>
<DIV style="position:absolute;top:793;left:142"><nobr><span class="ft13"><b>­l<i>nnn</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:793;left:206"><nobr><span class="ft26">Links with the library file named `lib<i>nnn</i>.a'. The loader will search for this file in any directories<br>specified with the -L option, in the directories `<i>&lt;vex_tree&gt;/lib</i>' and `<i>&lt;vex_tree&gt;/usr/lib</i>'. Libraries<br>are searched in the order in which they appear on the command line; therefore, they should nor-<br>mally appear at the end of any cc command. This flag is passed directly to the loader.</span></nobr></DIV>
<DIV style="position:absolute;top:868;left:142"><nobr><span class="ft13"><b>-Ldir</b></span></nobr></DIV>
<DIV style="position:absolute;top:868;left:206"><nobr><span class="ft26">Library archives are sought first in directories named in -L options, then in directories on a stan-<br>dard list. This flag is passed directly to the loader.</span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:147"><nobr><span class="ft13"><b>-mp<i>nnn</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:1025;left:265"><nobr><span class="ft21">Pass the option <i>­nnn</i> to the c preprocessor (cpp)</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:147"><nobr><span class="ft13"><b>-ma<i>nnn</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:265"><nobr><span class="ft21">Pass the option <i>-nnn</i> to the assembler (as).</span></nobr></DIV>
<DIV style="position:absolute;top:1077;left:147"><nobr><span class="ft13"><b>-ml<i>nnn</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:1077;left:265"><nobr><span class="ft21">Pass the option <i>­nnn</i> to the loader (ld).</span></nobr></DIV>
<DIV style="position:absolute;top:499;left:155"><nobr><span class="ft13"><b>Figure 8   The three steps of profile-based compilation.</b></span></nobr></DIV>
<DIV style="position:absolute;top:159;left:292"><nobr><span class="ft50"><i><b>cc -prob_gen </b></i></span></nobr></DIV>
<DIV style="position:absolute;top:144;left:190"><nobr><span class="ft51">file1.c </span></nobr></DIV>
<DIV style="position:absolute;top:180;left:190"><nobr><span class="ft51">file2.c </span></nobr></DIV>
<DIV style="position:absolute;top:138;left:465"><nobr><span class="ft51">database.ifprob </span></nobr></DIV>
<DIV style="position:absolute;top:187;left:442"><nobr><span class="ft51">file1.li nes </span></nobr></DIV>
<DIV style="position:absolute;top:187;left:517"><nobr><span class="ft51">file2.li nes </span></nobr></DIV>
<DIV style="position:absolute;top:235;left:316"><nobr><span class="ft52"><b>a.exe </b> </span></nobr></DIV>
<DIV style="position:absolute;top:250;left:297"><nobr><span class="ft53"><i>with profiling </i></span></nobr></DIV>
<DIV style="position:absolute;top:264;left:289"><nobr><span class="ft53"><i>instrumentation</i> </span></nobr></DIV>
<DIV style="position:absolute;top:316;left:465"><nobr><span class="ft51">database.ifprob </span></nobr></DIV>
<DIV style="position:absolute;top:367;left:485"><nobr><span class="ft51">file1.lines </span></nobr></DIV>
<DIV style="position:absolute;top:367;left:559"><nobr><span class="ft51">file2.lines </span></nobr></DIV>
<DIV style="position:absolute;top:367;left:417"><nobr><span class="ft51">ifprob.out </span></nobr></DIV>
<DIV style="position:absolute;top:430;left:473"><nobr><span class="ft50"><i><b>cc -prob_use </b></i></span></nobr></DIV>
<DIV style="position:absolute;top:415;left:346"><nobr><span class="ft51">file1.c </span></nobr></DIV>
<DIV style="position:absolute;top:452;left:346"><nobr><span class="ft51">file2.c </span></nobr></DIV>
<DIV style="position:absolute;top:135;left:611"><nobr><span class="ft54">1 </span></nobr></DIV>
<DIV style="position:absolute;top:240;left:555"><nobr><span class="ft54">2 </span></nobr></DIV>
<DIV style="position:absolute;top:302;left:730"><nobr><span class="ft54">3 </span></nobr></DIV>
<DIV style="position:absolute;top:423;left:683"><nobr><span class="ft52"><b>a.exe  </b></span></nobr></DIV>
<DIV style="position:absolute;top:438;left:672"><nobr><span class="ft53"><i>optimized </i></span></nobr></DIV>
</DIV>
<!-- Page 23 -->
<a name="23"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="white.png" alt="background image">
<DIV style="position:absolute;top:175;left:81"><nobr><span class="ft9"><i>Terminal Output and Process Control</i></span></nobr></DIV>
<DIV style="position:absolute;top:201;left:81"><nobr><span class="ft1">This group of options controls the terminal output of the compiler.</span></nobr></DIV>
<DIV style="position:absolute;top:608;left:81"><nobr><span class="ft9"><i>Other Options</i></span></nobr></DIV>
<DIV style="position:absolute;top:634;left:81"><nobr><span class="ft1">The following set of option controls the Compiled-Simulator invocation</span></nobr></DIV>
<DIV style="position:absolute;top:964;left:94"><nobr><span class="ft1">The following options control miscellaneous configuration and diagnostics for the VEX compiler.</span></nobr></DIV>
<DIV style="position:absolute;top:87;left:147"><nobr><span class="ft13"><b>-Wa,&lt;options&gt;</b></span></nobr></DIV>
<DIV style="position:absolute;top:87;left:265"><nobr><span class="ft21">Pass comma-separated &lt;options&gt; to the assembler</span></nobr></DIV>
<DIV style="position:absolute;top:112;left:147"><nobr><span class="ft13"><b>-Wl,&lt;options&gt;</b></span></nobr></DIV>
<DIV style="position:absolute;top:112;left:265"><nobr><span class="ft21">Pass comma-separated &lt;options&gt; to the linker</span></nobr></DIV>
<DIV style="position:absolute;top:137;left:147"><nobr><span class="ft13"><b>-Wp,&lt;options&gt;</b></span></nobr></DIV>
<DIV style="position:absolute;top:137;left:265"><nobr><span class="ft21">Pass comma-separated &lt;options&gt; to the C preprocessor</span></nobr></DIV>
<DIV style="position:absolute;top:240;left:144"><nobr><span class="ft13"><b>-w</b></span></nobr></DIV>
<DIV style="position:absolute;top:240;left:262"><nobr><span class="ft21">Suppress warning diagnostics from compiler.</span></nobr></DIV>
<DIV style="position:absolute;top:265;left:144"><nobr><span class="ft13"><b>-mv</b></span></nobr></DIV>
<DIV style="position:absolute;top:265;left:262"><nobr><span class="ft21">Display a banner line, including the version number</span></nobr></DIV>
<DIV style="position:absolute;top:290;left:144"><nobr><span class="ft13"><b>-mve</b></span></nobr></DIV>
<DIV style="position:absolute;top:290;left:262"><nobr><span class="ft26">Display a banner line, including the version number of the compiler, and terminate; do<br>not proceed with compilation.</span></nobr></DIV>
<DIV style="position:absolute;top:333;left:144"><nobr><span class="ft13"><b>-d</b></span></nobr></DIV>
<DIV style="position:absolute;top:332;left:262"><nobr><span class="ft21">Show all invocations of the compiler phases and run the compiler</span></nobr></DIV>
<DIV style="position:absolute;top:358;left:144"><nobr><span class="ft13"><b>-dn</b></span></nobr></DIV>
<DIV style="position:absolute;top:358;left:262"><nobr><span class="ft21">Show all invocations of the compiler phases and do nothing</span></nobr></DIV>
<DIV style="position:absolute;top:384;left:144"><nobr><span class="ft13"><b>-ms</b></span></nobr></DIV>
<DIV style="position:absolute;top:384;left:262"><nobr><span class="ft26">Compile the named programs, leave the assembler-language output on corresponding<br>files suffixed `.s', and continue to generate `.o' files normally. By default cc deletes any<br>`.s' files that it creates.</span></nobr></DIV>
<DIV style="position:absolute;top:442;left:144"><nobr><span class="ft13"><b>-temp=<i>directory</b></i></span></nobr></DIV>
<DIV style="position:absolute;top:442;left:262"><nobr><span class="ft26">Create temporary files used during compilation in <i>directory</i>, rather than in /tmp (the<br>default). An error occurs if directory is missing; if the given path is not the name of the<br>directory; or if the given path is not writable</span></nobr></DIV>
<DIV style="position:absolute;top:501;left:144"><nobr><span class="ft13"><b>-S</b></span></nobr></DIV>
<DIV style="position:absolute;top:501;left:262"><nobr><span class="ft26">Only compile to the assembler-level, leave the assembler-language output on corre-<br>sponding files suffixed `.s', and stop.</span></nobr></DIV>
<DIV style="position:absolute;top:542;left:144"><nobr><span class="ft13"><b>-help | --help</b></span></nobr></DIV>
<DIV style="position:absolute;top:542;left:262"><nobr><span class="ft21">Show help message for basic options</span></nobr></DIV>
<DIV style="position:absolute;top:568;left:144"><nobr><span class="ft13"><b>--license</b></span></nobr></DIV>
<DIV style="position:absolute;top:568;left:262"><nobr><span class="ft21">Show VEX license</span></nobr></DIV>
<DIV style="position:absolute;top:673;left:145"><nobr><span class="ft13"><b>-mas_g</b></span></nobr></DIV>
<DIV style="position:absolute;top:673;left:263"><nobr><span class="ft26">Compile the named programs, and leave the intermediate files used in the `Compiled<br>Simulator' step in `.cs.c', then continue to generate `.o' files normally. By default cc<br>deletes any `.cs.c' file</span></nobr></DIV>
<DIV style="position:absolute;top:731;left:145"><nobr><span class="ft42"><b>-mas_t<br>-mas_ti<br>-mas_td</b></span></nobr></DIV>
<DIV style="position:absolute;top:731;left:263"><nobr><span class="ft13"><b>-mas_t</b></span></nobr></DIV>
<DIV style="position:absolute;top:731;left:306"><nobr><span class="ft21"> enables the collection of `Compiled Simulator' runtime statistics, I-cache simu-</span></nobr></DIV>
<DIV style="position:absolute;top:748;left:263"><nobr><span class="ft26">lation and D-cache simulation when a program is executed. Statistics appear in the<br><i>ta.log.nnn</i></span></nobr></DIV>
<DIV style="position:absolute;top:764;left:322"><nobr><span class="ft21"> file at the end of the program execution. </span></nobr></DIV>
<DIV style="position:absolute;top:781;left:263"><nobr><span class="ft21">It is also possible to individually turn on part of the simulation statistics:</span></nobr></DIV>
<DIV style="position:absolute;top:798;left:274"><nobr><span class="ft13"><b>-mas_ti</b></span></nobr></DIV>
<DIV style="position:absolute;top:798;left:337"><nobr><span class="ft21">collects I-cache simulation data </span></nobr></DIV>
<DIV style="position:absolute;top:814;left:274"><nobr><span class="ft13"><b>-mas_td</b></span></nobr></DIV>
<DIV style="position:absolute;top:814;left:337"><nobr><span class="ft21">collects D-cache simulation data</span></nobr></DIV>
<DIV style="position:absolute;top:839;left:145"><nobr><span class="ft13"><b>-mas_G</b></span></nobr></DIV>
<DIV style="position:absolute;top:839;left:263"><nobr><span class="ft26">Turn on gprof-style collection of profiling data. The gprof tool produces an execution<br>profile of programs where the effect of called routines is incorporated into the profile of<br>each caller. Profile data is taken from the call graph profile file (gmon.out default) </span></nobr></DIV>
<DIV style="position:absolute;top:898;left:145"><nobr><span class="ft13"><b>-mas_d</b></span></nobr></DIV>
<DIV style="position:absolute;top:898;left:263"><nobr><span class="ft21">Show internal assembler steps</span></nobr></DIV>
<DIV style="position:absolute;top:924;left:145"><nobr><span class="ft13"><b>-mld_d</b></span></nobr></DIV>
<DIV style="position:absolute;top:924;left:263"><nobr><span class="ft21">Show internal linker steps</span></nobr></DIV>
<DIV style="position:absolute;top:1003;left:139"><nobr><span class="ft13"><b>-fmm=&lt;mm_file&gt;</b></span></nobr></DIV>
<DIV style="position:absolute;top:1003;left:269"><nobr><span class="ft21">Reads the Machine Model configuration file from &lt;<i>mm_file</i>&gt;</span></nobr></DIV>
<DIV style="position:absolute;top:1028;left:139"><nobr><span class="ft13"><b>-fmmdump</b></span></nobr></DIV>
<DIV style="position:absolute;top:1028;left:269"><nobr><span class="ft26">Dumps (to the <i>info_file</i>) the current machine model configuration, which could be used<br>to produce a Machine Model file to pass to the <i>-fmm=&lt;file&gt;</i> option.</span></nobr></DIV>
<DIV style="position:absolute;top:1071;left:139"><nobr><span class="ft13"><b>-fdraw-dag=&lt;n&gt;</b></span></nobr></DIV>
<DIV style="position:absolute;top:1070;left:269"><nobr><span class="ft26">Emits to the <i>DAG file</i> (default "DAG.vcg") the VCG representation of the DAG for trace<br>number &lt;n&gt; of the first procedure in the compilation unit.</span></nobr></DIV>
</DIV>
<!-- Page 24 -->
<a name="24"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft55{font-size:11px;line-height:13px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="vex024.png" alt="background image">
<DIV style="position:absolute;top:167;left:81"><nobr><span class="ft17"><b>3.2 Compiler Pragmas</b></span></nobr></DIV>
<DIV style="position:absolute;top:201;left:81"><nobr><span class="ft5">This section discusses the set of compiler <i>pragmas</i> available in the VEX system. Pragmas are hints, directives and assertions<br>that the programmer can pass to the compiler to improve performance. </span></nobr></DIV>
<DIV style="position:absolute;top:252;left:81"><nobr><span class="ft9"><i>Unrolling and Profiling</i></span></nobr></DIV>
<DIV style="position:absolute;top:277;left:81"><nobr><span class="ft5">Unrolling pragmas control the loop optimization heuristics applied by the compiler. The loop optimization phase of the com-<br>piler consists of two successive phases: <i>first unrolling</i>, where the loop induction variables are transformed so that all iterations<br>can be executed in parallel; and <i>second unrolling</i>, where the loop induction variables are not transformed. In most cases, the<br>first unrolling phase is sufficient to achieve the desired behavior and the second unrolling phase should be used with caution.</span></nobr></DIV>
<DIV style="position:absolute;top:349;left:94"><nobr><span class="ft1">Profiling pragmas control the way the compiler picks traces, when no profiling information is available.</span></nobr></DIV>
<DIV style="position:absolute;top:879;left:81"><nobr><span class="ft5">The following example shows how to tell the compiler to unroll a loop 4 times (using the first unrolling phase), to precondition<br>the loop to 4 iterations and to use a typical trip count of a 1000 iterations for the compiler heuristics.</span></nobr></DIV>
<DIV style="position:absolute;top:929;left:135"><nobr><span class="ft14">void loop_pragmas(int N, int a[], int b[] int c[])<br>{<br>    int i;</span></nobr></DIV>
<DIV style="position:absolute;top:970;left:167"><nobr><span class="ft55"><b>#pragma unroll_amount(4,1)<br>#pragma precondition_amount(4)<br>#pragma trip_count(1000)</b></span></nobr></DIV>
<DIV style="position:absolute;top:1010;left:135"><nobr><span class="ft14">    for(i=0;i&lt;N;++i)<br>    {<br>        a[i] = b[i] * c[i];<br>    }<br>}</span></nobr></DIV>
<DIV style="position:absolute;top:1090;left:81"><nobr><span class="ft1">The following example shows how to tell the compiler that a branch is biased to be taken 20 times over 100 executions (i.e., a</span></nobr></DIV>
<DIV style="position:absolute;top:87;left:139"><nobr><span class="ft13"><b>-fdag-file=&lt;fname&gt;</b></span></nobr></DIV>
<DIV style="position:absolute;top:87;left:269"><nobr><span class="ft21">Sets the <i>DAG file </i>to &lt;<i>fname</i>&gt;</span></nobr></DIV>
<DIV style="position:absolute;top:112;left:139"><nobr><span class="ft13"><b>-fdraw-cfg</b></span></nobr></DIV>
<DIV style="position:absolute;top:112;left:269"><nobr><span class="ft26">Emits the control-flow graph (basic-blocks) for every procedure of the compilation unit.<br>The graphs are emitted to files called "<i>GRAPH&lt;procname&gt;.vcg</i>"</span></nobr></DIV>
<DIV style="position:absolute;top:406;left:142"><nobr><span class="ft13"><b>Pragma</b></span></nobr></DIV>
<DIV style="position:absolute;top:406;left:316"><nobr><span class="ft13"><b>Description</b></span></nobr></DIV>
<DIV style="position:absolute;top:432;left:142"><nobr><span class="ft42"><b>#pragma<br>unroll_amount(n1,n2)</b></span></nobr></DIV>
<DIV style="position:absolute;top:431;left:316"><nobr><span class="ft26">Specifies the amount of unrolling that the compiler must perform in the first<br>(<i>n1</i>) and second (<i>n2</i>) unrolling phases for the loop. This pragma applies to the<br>following loop. The statement immediately following the pragma must be a<br>loop statement (<i>for, while </i>or  <i>do</i>). The compiler flags a syntax error if the<br>pragma precedes any other statement. This pragma takes precedence over<br>command-line flags.</span></nobr></DIV>
<DIV style="position:absolute;top:540;left:142"><nobr><span class="ft42"><b>#pragma<br>precondition_amount(n)</b></span></nobr></DIV>
<DIV style="position:absolute;top:539;left:316"><nobr><span class="ft49">Specifies the amount of preconditioning that the compiler must perform for the<br>loop. This pragma applies to the following loop. The value <i>n</i> must be compat-<br>ible with the unrolling amount specified for the loop: it is only legal to specify a<br>preconditioning value that is an integer multiple of the unrolling amount. The<br>statement immediately following the pragma must be a loop statement (<i>for,<br>while </i></span></nobr></DIV>
<DIV style="position:absolute;top:622;left:352"><nobr><span class="ft21">or  <i>do</i>). The compiler flags a syntax error if the pragma precedes any</span></nobr></DIV>
<DIV style="position:absolute;top:638;left:316"><nobr><span class="ft21">other statement. This pragma takes precedence over command-line flags</span></nobr></DIV>
<DIV style="position:absolute;top:664;left:142"><nobr><span class="ft13"><b>#pragma trip_count(n)</b></span></nobr></DIV>
<DIV style="position:absolute;top:664;left:316"><nobr><span class="ft26">Specifies the estimated number of iterations of the loop, and is used to guide<br>compiler heuristics. This pragma applies to the following loop. The statement<br>immediately following the pragma must be a loop statement (<i>for, while </i>or <i>do</i>).<br>The compiler flags a syntax error if the pragma precedes any other statement.<br>This pragma takes precedence over command-line flags</span></nobr></DIV>
<DIV style="position:absolute;top:756;left:142"><nobr><span class="ft13"><b>#pragma if_prob(n1,n2)</b></span></nobr></DIV>
<DIV style="position:absolute;top:755;left:316"><nobr><span class="ft26">Specifies the probability of the following branch. The two parameters specify<br>the number of times the following branch is executed (<i>n2</i>) and the number of<br>times the following branch is taken (<i>n1</i>) The compiler computes the taken-<br>branch probability as <i>n1/n2</i>. The statement immediately following the pragma<br>must be an <i>if</i> statement. The compiler flags a syntax error if the pragma pre-<br>cedes any other statement.</span></nobr></DIV>
</DIV>
<!-- Page 25 -->
<a name="25"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="vex025.png" alt="background image">
<DIV style="position:absolute;top:81;left:81"><nobr><span class="ft1">20% taken probability)</span></nobr></DIV>
<DIV style="position:absolute;top:113;left:135"><nobr><span class="ft14">int if_pragms(int a, int b)<br>{</span></nobr></DIV>
<DIV style="position:absolute;top:140;left:167"><nobr><span class="ft32"><b>#pragma if_prob(20,100)</b></span></nobr></DIV>
<DIV style="position:absolute;top:154;left:135"><nobr><span class="ft14">    if (a&gt;b)<br>         return foo(a + b);<br>    else <br>         return bar(a - b);<br>}</span></nobr></DIV>
<DIV style="position:absolute;top:235;left:81"><nobr><span class="ft9"><i>Assertions</i></span></nobr></DIV>
<DIV style="position:absolute;top:261;left:81"><nobr><span class="ft5">Assertions give the compiler more information about the program being compiled. Note that assertions are not hints and the<br>compiler trusts the programmer about their validity. If the asserted condition can be false, it is possible for the compiler to gen-<br>erate code that would produce unexpected results. Assertions are valid in the current scope are not propagated to other scopes,<br>and should be used with extreme caution.</span></nobr></DIV>
<DIV style="position:absolute;top:511;left:81"><nobr><span class="ft1">The following example asserts that the pointers <i>p</i> and <i>q</i> are aligned <i>0mod4</i> in the function <i>foo()</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:544;left:135"><nobr><span class="ft14">foo(char *p, char *q, int N)<br>{<br>    int i;</span></nobr></DIV>
<DIV style="position:absolute;top:584;left:167"><nobr><span class="ft55"><b>#pragma assert_eq(p,0,4)<br>#pragma assert_eq(q,0,4)</b></span></nobr></DIV>
<DIV style="position:absolute;top:611;left:135"><nobr><span class="ft14">    for(i=0; i&lt;N; i++)<br>        *p++ = *q++<br>}</span></nobr></DIV>
<DIV style="position:absolute;top:666;left:81"><nobr><span class="ft9"><i>Memory Disambiguation</i></span></nobr></DIV>
<DIV style="position:absolute;top:691;left:81"><nobr><span class="ft5">Given two memory references to arbitrarily complex address expressions A and B, the compiler applies a set of techniques that<br>try to answer the question <i>"Can the addresses A and B ever be the same?".</i> This set of techniques falls into the category of<br><i>Memory Disambiguation</i>. There are three possible answers to the previous question: <i>yes</i>, when the compiler can definitely<br>establish that A and B alias; <i>no</i> when the compiler can definitely establish that A and be never alias; <i>maybe</i>. when the compiler<br>cannot establish the alias relationship between A and B. In its default operation mode, the compiler has to treat <i>maybe</i> memory<br>dependencies as potential aliases, and the scheduler uses this information to limit the code motion.</span></nobr></DIV>
<DIV style="position:absolute;top:799;left:94"><nobr><span class="ft1">The compiler supports a set of pragmas to force the scheduler to alter this default behavior and to ignore some of the mem-</span></nobr></DIV>
<DIV style="position:absolute;top:817;left:81"><nobr><span class="ft5">ory dependencies. Note that--like assertions--the <i>#pragma ivdep </i>directive is <i>not a hint</i> and the compiler trusts the user on the<br>truth of the assertion. If indeed some memory dependence may exist in the loop, it is possible for the compiler to generate code<br>that would produce unexpected results. The <i>ivdep</i> pragma is only valid for the following loop, and should be used with<br>extreme caution. </span></nobr></DIV>
<DIV style="position:absolute;top:353;left:149"><nobr><span class="ft13"><b>Pragma</b></span></nobr></DIV>
<DIV style="position:absolute;top:353;left:388"><nobr><span class="ft13"><b>Description</b></span></nobr></DIV>
<DIV style="position:absolute;top:379;left:149"><nobr><span class="ft42"><b>#pragma assert_eq(exp1,exp2,n)<br>#pragma assert_ne(exp1,exp2,n)</b></span></nobr></DIV>
<DIV style="position:absolute;top:379;left:388"><nobr><span class="ft26">Assert equality (<i>assert_eq</i>) and inequality (<i>assert_ne</i>) of the two<br>C expressions <i>exp1</i> and <i>exp2</i>, modulo <i>n</i>, in the current scope.</span></nobr></DIV>
<DIV style="position:absolute;top:421;left:149"><nobr><span class="ft42"><b>#pragma assert_lt (exp1,exp2)<br>#pragma assert_le (exp1,exp2)<br>#pragma assert_gt (exp1,exp2)<br>#pragma assert_ge (exp1,exp2)</b></span></nobr></DIV>
<DIV style="position:absolute;top:421;left:388"><nobr><span class="ft26">Assert less-than (<i>assert_lt</i>), less-equal-than (<i>assert_le</i>), greater-<br>then (<i>assert_g</i>) or greater-equal-then (<i>assert_ge</i>) of the two C<br>expressions <i>exp1</i> and <i>exp2</i>, modulo <i>n</i>, in the current scope</span></nobr></DIV>
<DIV style="position:absolute;top:910;left:145"><nobr><span class="ft13"><b>Pragma</b></span></nobr></DIV>
<DIV style="position:absolute;top:910;left:278"><nobr><span class="ft13"><b>Description</b></span></nobr></DIV>
<DIV style="position:absolute;top:936;left:145"><nobr><span class="ft13"><b>#pragma ivdep</b></span></nobr></DIV>
<DIV style="position:absolute;top:935;left:278"><nobr><span class="ft26">Forces the compiler to treat all "MAYBE" memory aliases as "NO" memory aliases<br>in the following loop. This pragma applies to the following loop. The statement<br>immediately following the pragma must be a loop statement (<i>for, while </i>or <i>do</i>). The<br>compiler flags a syntax error if the pragma precedes any other statement.</span></nobr></DIV>
<DIV style="position:absolute;top:1010;left:145"><nobr><span class="ft13"><b>#pragma restrict</b></span></nobr></DIV>
<DIV style="position:absolute;top:1010;left:278"><nobr><span class="ft26">Implements a variation of the C99 "<i>restrict</i>" keyword in the form of a pragma. It is a<br>type-annotation pragma and applies to the following declaration (or <i>typedef</i>). It<br>instructs the compiler that pointers with a "<i>restrict</i>" type point to memory areas that<br>cannot overlap.</span></nobr></DIV>
</DIV>
<!-- Page 26 -->
<a name="26"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft56{font-size:12px;line-height:17px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="white.png" alt="background image">
<DIV style="position:absolute;top:81;left:94"><nobr><span class="ft1">The following example shows the usage of the <i>ivdep</i> pragma. The use of <i>ivdep </i>indicates the compiler that no alias exists in</span></nobr></DIV>
<DIV style="position:absolute;top:99;left:81"><nobr><span class="ft5">the following loop. In the particular example, this means that the user wants to inform the compiler that the vector a[], b[]<br>and c[] point to distinct memory areas that do not overlap (at least for the first N elements). The compiler will use the infor-<br>mation to reorder the memory accesses, so that ­ for example ­ it is legal to load a new value of b[] before writing the new<br>value of a[]. Obviously, if the two arrays a[] and b[] ever overlap (i.e., the <i>ivdep</i> was asserted incorrectly), the code gener-<br>ated by the compiler will produce unexpected results.</span></nobr></DIV>
<DIV style="position:absolute;top:203;left:135"><nobr><span class="ft10">void loop_with_ivdep_pragma(</span></nobr></DIV>
<DIV style="position:absolute;top:217;left:167"><nobr><span class="ft10">int N, int a[], int b[], int c[]</span></nobr></DIV>
<DIV style="position:absolute;top:230;left:135"><nobr><span class="ft14">) {<br>    int i;</span></nobr></DIV>
<DIV style="position:absolute;top:257;left:167"><nobr><span class="ft32"><b>#pragma ivdep</b></span></nobr></DIV>
<DIV style="position:absolute;top:271;left:135"><nobr><span class="ft14">    for(i = 0;i &lt; N; ++i) {<br>        a[i] = b[i] * c[i];<br>    }<br>}</span></nobr></DIV>
<DIV style="position:absolute;top:337;left:94"><nobr><span class="ft1">The following example shows the usage of the <i>restrict </i>pragma</span></nobr></DIV>
<DIV style="position:absolute;top:333;left:467"><nobr><span class="ft28">1</span></nobr></DIV>
<DIV style="position:absolute;top:337;left:473"><nobr><span class="ft1">. The use of <i>restrict </i>indicates the compiler that no alias exists</span></nobr></DIV>
<DIV style="position:absolute;top:355;left:81"><nobr><span class="ft5">for pointers declared with a &quot;restrict&quot; type. In the particular example, this means that the user wants to inform the compiler that<br>the vector a[], b[] and c[] point to distinct memory areas that do not overlap for the (at least for the first N elements). The<br>compiler will use the information to reorder the memory accesses, so that ­ for example ­ it is legal to load a new value of b[]<br>before writing the new value of a[]. Obviously, if the two arrays a[] and b[] ever overlap (i.e., the <i>ivdep</i> was asserted<br>incorrectly), the code generated by the compiler will produce incorrect results.</span></nobr></DIV>
<DIV style="position:absolute;top:460;left:135"><nobr><span class="ft55"><b>#pragma restrict<br></b>typedef r_int int;</span></nobr></DIV>
<DIV style="position:absolute;top:500;left:135"><nobr><span class="ft10">void loop_with_restrict_pragma(</span></nobr></DIV>
<DIV style="position:absolute;top:514;left:167"><nobr><span class="ft14">int N, <br>r_int a[], <br>r_int b[],<br>r_int c[] )</span></nobr></DIV>
<DIV style="position:absolute;top:568;left:135"><nobr><span class="ft14">{<br>    int i;<br>    for(i=0;i&lt;N;++i) {<br>        a[i] = b[i] * c[i];<br>    }<br>}</span></nobr></DIV>
<DIV style="position:absolute;top:661;left:81"><nobr><span class="ft5">The VEX compiler also support a limited form of the ISO-C99 "<i>restrict</i>" keyword for pointers. The <i>restrict</i> keyword has sim-<br>ilar effects (with different syntax) of the <i>restrict</i> pragma described above. For example, the following loop generates equiva-<br>lent annotations, through the use of the C99 syntax.</span></nobr></DIV>
<DIV style="position:absolute;top:730;left:135"><nobr><span class="ft10">void loop_with_c99_restrict(</span></nobr></DIV>
<DIV style="position:absolute;top:743;left:167"><nobr><span class="ft14">int N, <br>int * <b>restrict</b> a, <br>int * <b>restrict</b> b,<br>int * <b>restrict</b> c</span></nobr></DIV>
<DIV style="position:absolute;top:797;left:135"><nobr><span class="ft14">) {<br>    int i;<br>    for(i=0;i&lt;N;++i) {<br>        a[i] = b[i] * c[i];<br>    }<br>}</span></nobr></DIV>
<DIV style="position:absolute;top:892;left:81"><nobr><span class="ft9"><i>Cache Control</i></span></nobr></DIV>
<DIV style="position:absolute;top:918;left:81"><nobr><span class="ft5">The VEX compiler supports a set of pragmas that allow programmers to attach certain attributes to C data types. The compiler<br>attaches the attributes to the data type and maintains them during the compilation process through the final code-generation<br>back-end. The machine specific back-end is responsible for interpreting the type attributes and for generating the proper<br>actions. The basic concept behind VEX type attributes is that they represent <i>hints</i> <i>to the compiler</i> and <i>never impact the correct-<br>ness of the program</i>. In this way, the back-end is free to ignore them if it chooses to do so, or if the particular compilation target<br>lacks hardware support to implement the behavior suggested by the hint.</span></nobr></DIV>
<DIV style="position:absolute;top:1026;left:94"><nobr><span class="ft1">These type attributes influence data cache accesses and enable the user to manually force a compiler-directed data prefetch-</span></nobr></DIV>
<DIV style="position:absolute;top:1077;left:81"><nobr><span class="ft30">1. Note that the VEX compiler predates the C99 <i>restrict</i> keyword. The <i>restrict </i>pragma substantially implemented the same concept, with a different tech-<br>nique. The VEX compiler supports both ways.</span></nobr></DIV>
</DIV>
<!-- Page 27 -->
<a name="27"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft57{font-size:12px;font-family:Times;color:#000000;}
	.ft58{font-size:12px;line-height:17px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="vex027.png" alt="background image">
<DIV style="position:absolute;top:81;left:81"><nobr><span class="ft5">ing. VEX memory operations include two qualifiers that specify <i>streaming </i>accesses (i.e., accesses to objects that only exhibit<br><i>spatial locality</i>); and <i>local </i>accesses (i.e. accesses to objects that exhibit a strong temporal locality). The following pragmas<br>control the prefetching algorithm and the replacement policy of the cache.</span></nobr></DIV>
<DIV style="position:absolute;top:537;left:81"><nobr><span class="ft5">Note that type annotation pragmas always refer to the physical memory storage implied by the definition/declaration. The fol-<br>lowing construct:</span></nobr></DIV>
<DIV style="position:absolute;top:587;left:135"><nobr><span class="ft55"><b>#pragma stream<br></b>typedef int stream_int;</span></nobr></DIV>
<DIV style="position:absolute;top:628;left:135"><nobr><span class="ft10">stream_int *p;</span></nobr></DIV>
<DIV style="position:absolute;top:654;left:81"><nobr><span class="ft6">defines a <i>stream_int  </i>type derived from the basic type <i>int</i>, tagged with a <i>streaming</i> attribute, and declares a pointer <i>p<br></i>pointing to data of type <i>stream_int</i>. In other words, the pragma will affect all accesses through <i>p</i> (such as <i>*p</i>), but not the<br>accesses to set or read the value of <i>p</i> itself. If the desired behavior is to have the pointer <i>p</i> itself be tagged with the <i>spatial<br>locality</i> attribute, then we need the following statements:</span></nobr></DIV>
<DIV style="position:absolute;top:740;left:135"><nobr><span class="ft55"><b>#pragma stream<br></b>typedef int *stream_int_ptr;</span></nobr></DIV>
<DIV style="position:absolute;top:781;left:135"><nobr><span class="ft10">stream_int_ptr *p;</span></nobr></DIV>
<DIV style="position:absolute;top:807;left:81"><nobr><span class="ft1">Finally, if we want both <i>p</i> and *<i>p</i> to be tagged with the <i>spatial locality</i> attribute, we can use the following combination:</span></nobr></DIV>
<DIV style="position:absolute;top:839;left:135"><nobr><span class="ft55"><b>#pragma stream<br></b>typedef int stream_int;</span></nobr></DIV>
<DIV style="position:absolute;top:880;left:135"><nobr><span class="ft55"><b>#pragma stream<br></b>typedef stream_int *stream_int_stream_ptr;</span></nobr></DIV>
<DIV style="position:absolute;top:920;left:135"><nobr><span class="ft10">stream_int_stream_ptr *p;</span></nobr></DIV>
<DIV style="position:absolute;top:946;left:81"><nobr><span class="ft1">Similarly. it is possible to annotate types with a "prefetch" attribute, as in the following example.</span></nobr></DIV>
<DIV style="position:absolute;top:979;left:135"><nobr><span class="ft55"><b>#pragma prefetch(1)<br></b>typedef int pft1_int;</span></nobr></DIV>
<DIV style="position:absolute;top:1018;left:81"><nobr><span class="ft5">One way of using the "prefetch" attribute to operate fine-grain prefetch control is in a <i>cast</i> operator, as the following example<br>(multiplication of a vector by a constant) shows:</span></nobr></DIV>
<DIV style="position:absolute;top:1069;left:135"><nobr><span class="ft14">for(i=0;i&lt;100;i++) {<br>    (<b>(pft1_int *)</b>c)[i] = (<b>(pft1_int *)</b>a)[i] * k;</span></nobr></DIV>
<DIV style="position:absolute;top:155;left:144"><nobr><span class="ft13"><b>Pragma</b></span></nobr></DIV>
<DIV style="position:absolute;top:155;left:302"><nobr><span class="ft13"><b>Description</b></span></nobr></DIV>
<DIV style="position:absolute;top:181;left:144"><nobr><span class="ft13"><b>#pragma lmb</b></span></nobr></DIV>
<DIV style="position:absolute;top:181;left:302"><nobr><span class="ft26">Attaches a "<i>spatial locality</i>" attribute the following type definition or variable dec-<br>laration. The statement immediately following the pragma must be a type decla-<br>ration (typedef) or variable declaration. The compiler flags a syntax error if the<br>pragma precedes any other statement. In case of a type declaration, the<br>attribute applies to all variables of the same type. In case of a variable declara-<br>tion, the attribute applies to the declared variable only.</span></nobr></DIV>
<DIV style="position:absolute;top:289;left:144"><nobr><span class="ft13"><b>#pragma stream</b></span></nobr></DIV>
<DIV style="position:absolute;top:289;left:302"><nobr><span class="ft26">Attaches a "<i>temporal locality</i>" attribute the following type definition or variable<br>declaration. The statement immediately following the pragma must be a type<br>declaration (typedef) or variable declaration. The compiler flags a syntax error if<br>the pragma precedes any other statement. In case of a type declaration, the<br>attribute applies to all variables of the same type. In case of a variable declara-<br>tion, the attribute applies to the declared variable only.</span></nobr></DIV>
<DIV style="position:absolute;top:397;left:144"><nobr><span class="ft13"><b>#pragma prefetch(num)</b></span></nobr></DIV>
<DIV style="position:absolute;top:397;left:302"><nobr><span class="ft26">Attaches a "<i>prefetch</i>" attribute to the following type definition, or variable decla-<br>ration. The statement immediately following the pragma must be a type declara-<br>tion (typedef) or variable declaration. The compiler flags a syntax error if the<br>pragma precedes any other statement. In case of a type declaration, the<br>attribute applies to all variables of the same type. In case of a variable declara-<br>tion, the attribute applies to the declared variable only. The value <i>num</i> indicates<br>the prefetch distance (expressed in multiples of D-cache lines).</span></nobr></DIV>
</DIV>
<!-- Page 28 -->
<a name="28"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft59{font-size:12px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="white.png" alt="background image">
<DIV style="position:absolute;top:82;left:135"><nobr><span class="ft10">}</span></nobr></DIV>
<DIV style="position:absolute;top:108;left:81"><nobr><span class="ft6">This example suggests to the compiler that it add a prefetch operation to the accesses of the arrays <i>c[]</i> and <i>a[]</i> in the loop. The<br>parameter "1" to the prefetch pragma indicates that the amount to prefetch is 1 D-cache line. If the size of a D-cache line is (for<br>example) 32 Bytes, the compiler will emit one prefetch operation for the line containing <i>c+i+32 </i>and one prefetch operation for<br>the line containing <i>a+i+32</i> at each loop iteration. In this case if <i>i &gt;&gt;32</i>, adding the prefetch will cause the values of <i>c[]</i> and <i>a[]<br></i>to be loaded in the cache long before their use, in this way avoiding a potential cache miss.</span></nobr></DIV>
<DIV style="position:absolute;top:217;left:81"><nobr><span class="ft17"><b>3.3 Inline Expansion</b></span></nobr></DIV>
<DIV style="position:absolute;top:250;left:81"><nobr><span class="ft5">Inline expansion is an optimization that replaces calls to functions by the function itself. It is beneficial, since it eliminates the<br>overhead required to make a function call, and it allows optimizations to take place which otherwise would be inhibited by<br>function calls (such as <i>loop unrolling</i>). For example, the two pieces of code below show a simple example of manual inline<br>expansion:</span></nobr></DIV>
<DIV style="position:absolute;top:337;left:135"><nobr><span class="ft10">int f1(int x,int y,int q)</span></nobr></DIV>
<DIV style="position:absolute;top:337;left:351"><nobr><span class="ft10">int f1(int x, int y, int q)</span></nobr></DIV>
<DIV style="position:absolute;top:350;left:135"><nobr><span class="ft10">{</span></nobr></DIV>
<DIV style="position:absolute;top:350;left:351"><nobr><span class="ft10">{</span></nobr></DIV>
<DIV style="position:absolute;top:364;left:135"><nobr><span class="ft10">    int z = mac(x,y,q);    </span></nobr></DIV>
<DIV style="position:absolute;top:364;left:378"><nobr><span class="ft10">z = x * y + q;</span></nobr></DIV>
<DIV style="position:absolute;top:377;left:135"><nobr><span class="ft10">    return z * 2 + 4;    </span></nobr></DIV>
<DIV style="position:absolute;top:377;left:378"><nobr><span class="ft10">return z * 2 + 4;</span></nobr></DIV>
<DIV style="position:absolute;top:391;left:135"><nobr><span class="ft10">}</span></nobr></DIV>
<DIV style="position:absolute;top:391;left:351"><nobr><span class="ft10">}</span></nobr></DIV>
<DIV style="position:absolute;top:418;left:135"><nobr><span class="ft14">int mac(int a,int b,int c)<br>{<br>    return a*b + c;<br>}</span></nobr></DIV>
<DIV style="position:absolute;top:484;left:94"><nobr><span class="ft1">The code on the left calls the function mac. This involves some overhead for saving and restoring registers. Inline substitu-</span></nobr></DIV>
<DIV style="position:absolute;top:502;left:81"><nobr><span class="ft5">tion, performed "by hand" on the right, eliminates the overhead for calling mac by rewriting the calling program so that the<br>definition of mac is substituted "inline." </span></nobr></DIV>
<DIV style="position:absolute;top:538;left:94"><nobr><span class="ft1">The mechanics of actual inline expansion are significantly more complex. When the compiler performs inline expansion, it</span></nobr></DIV>
<DIV style="position:absolute;top:556;left:81"><nobr><span class="ft5">guarantees that the expansion will not affect the program's behavior at all. In particular, this means that static and external<br>variables will behave correctly, and that local variable names within the expanded function will not conflict with variables in<br>the calling function. </span></nobr></DIV>
<DIV style="position:absolute;top:610;left:94"><nobr><span class="ft1">A function that is expanded inline disappears completely into the function that calls it, and this has consequences on both</span></nobr></DIV>
<DIV style="position:absolute;top:628;left:81"><nobr><span class="ft5">debugging and profiling. Calls to inlined functions do not appear in profiles produced by gprof. Most debugging tools cannot<br>set breakpoints within inlined functions.</span></nobr></DIV>
<DIV style="position:absolute;top:664;left:94"><nobr><span class="ft1">The VEX-compiler supports two methods of user-controlled inlining.</span></nobr></DIV>
<DIV style="position:absolute;top:690;left:81"><nobr><span class="ft3"><b>Multiflow-style inlining. </b>This inline facility in the VEX compiler (triggered by the <b><i>-mfinline</b> </i>flag) extends the syntax of C</span></nobr></DIV>
<DIV style="position:absolute;top:686;left:827"><nobr><span class="ft28">1</span></nobr></DIV>
<DIV style="position:absolute;top:690;left:833"><nobr><span class="ft1">,</span></nobr></DIV>
<DIV style="position:absolute;top:708;left:81"><nobr><span class="ft5">and it is based on the concept of an <i>inline module. </i>An inline module is a group of functions which can be substituted inline.<br>Functions to be inlined need to be enclosed in an <i>inline declaration</i>. The compiler does not generate code or storage for an<br>inline declaration; therefore inline expansion can only take place after the function being expanded has appeared within an<br>inline declaration. The compiler inlines all functions in an inline module that are declared with the <i>inline</i> attribute. For exam-<br>ple, the following code expands all calls to the function "<i>mac()</i>" within the function "<i>f()</i>".</span></nobr></DIV>
<DIV style="position:absolute;top:812;left:135"><nobr><span class="ft32"><b>inline_declare</b></span></nobr></DIV>
<DIV style="position:absolute;top:812;left:248"><nobr><span class="ft10"> {</span></nobr></DIV>
<DIV style="position:absolute;top:826;left:135"><nobr><span class="ft32"><b>inline_module</b></span></nobr></DIV>
<DIV style="position:absolute;top:826;left:240"><nobr><span class="ft10"> maclib {</span></nobr></DIV>
<DIV style="position:absolute;top:839;left:162"><nobr><span class="ft32"><b>inline</b></span></nobr></DIV>
<DIV style="position:absolute;top:839;left:211"><nobr><span class="ft10"> int mac(int,int,int) {</span></nobr></DIV>
<DIV style="position:absolute;top:853;left:189"><nobr><span class="ft10">return a*b + c;</span></nobr></DIV>
<DIV style="position:absolute;top:866;left:162"><nobr><span class="ft10">}</span></nobr></DIV>
<DIV style="position:absolute;top:880;left:135"><nobr><span class="ft10">}}</span></nobr></DIV>
<DIV style="position:absolute;top:907;left:135"><nobr><span class="ft32"><b>inline_module</b></span></nobr></DIV>
<DIV style="position:absolute;top:907;left:240"><nobr><span class="ft10"> maclib {</span></nobr></DIV>
<DIV style="position:absolute;top:920;left:162"><nobr><span class="ft32"><b>inline</b></span></nobr></DIV>
<DIV style="position:absolute;top:920;left:211"><nobr><span class="ft10"> int mac(int a, int b, int c) {</span></nobr></DIV>
<DIV style="position:absolute;top:934;left:189"><nobr><span class="ft10">return a*b + c;</span></nobr></DIV>
<DIV style="position:absolute;top:947;left:162"><nobr><span class="ft10">}</span></nobr></DIV>
<DIV style="position:absolute;top:961;left:135"><nobr><span class="ft14">}<br><b>inline_use</b></span></nobr></DIV>
<DIV style="position:absolute;top:974;left:216"><nobr><span class="ft10"> maclib;</span></nobr></DIV>
<DIV style="position:absolute;top:1001;left:135"><nobr><span class="ft14">int f(int x, int y, int q)<br>{</span></nobr></DIV>
<DIV style="position:absolute;top:1028;left:162"><nobr><span class="ft14">int z = mac(x,y,q); /* this call is inlined */<br>return z * 2 + 4;</span></nobr></DIV>
<DIV style="position:absolute;top:1092;left:81"><nobr><span class="ft28">1. Note that the VEX compiler predates the C99 <i>inline </i>keyword, which is more user-friendly, but also more limited than the <i>inline module </i>concept.</span></nobr></DIV>
</DIV>
<!-- Page 29 -->
<a name="29"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="white.png" alt="background image">
<DIV style="position:absolute;top:82;left:135"><nobr><span class="ft10">}</span></nobr></DIV>
<DIV style="position:absolute;top:115;left:81"><nobr><span class="ft3"><b>C99-style inlining. </b>This inline facility resembles the <i>inline</i> hint in C99</span></nobr></DIV>
<DIV style="position:absolute;top:111;left:506"><nobr><span class="ft28">1</span></nobr></DIV>
<DIV style="position:absolute;top:115;left:512"><nobr><span class="ft1">. All functions in scope marked with <i>inline</i> are consid-</span></nobr></DIV>
<DIV style="position:absolute;top:133;left:81"><nobr><span class="ft5">ered candidates for inlining. This mode is triggered by the <b><i>-c99inline</b></i> flag. The following example implements the same inlin-<br>ing functionality of the <i>mac() </i>function within <i>f().</i></span></nobr></DIV>
<DIV style="position:absolute;top:184;left:135"><nobr><span class="ft32"><b>inline</b></span></nobr></DIV>
<DIV style="position:absolute;top:184;left:184"><nobr><span class="ft10"> int mac(int a, int b, int c) {</span></nobr></DIV>
<DIV style="position:absolute;top:197;left:162"><nobr><span class="ft10">return a*b + c;</span></nobr></DIV>
<DIV style="position:absolute;top:211;left:135"><nobr><span class="ft10">}</span></nobr></DIV>
<DIV style="position:absolute;top:238;left:135"><nobr><span class="ft14">int f(int x, int y, int q)<br>{</span></nobr></DIV>
<DIV style="position:absolute;top:265;left:162"><nobr><span class="ft14">int z = mac(x,y,q); /* this call is inlined */<br>return z * 2 + 4;</span></nobr></DIV>
<DIV style="position:absolute;top:292;left:135"><nobr><span class="ft10">}</span></nobr></DIV>
<DIV style="position:absolute;top:318;left:94"><nobr><span class="ft1">Finally, note that the <b><i>-autoinline</b></i> flag of the VEX compiler uses the same mechanisms in a transparent way, and is equivalent</span></nobr></DIV>
<DIV style="position:absolute;top:336;left:81"><nobr><span class="ft1">to doing the following (with all functions of <i>"hello.c"</i> marked as <i>inline</i>):</span></nobr></DIV>
<DIV style="position:absolute;top:368;left:135"><nobr><span class="ft14">inline_module hello_1234 {<br>    inline_declare {<br>        inline_module hello_1234 {<br>            #include "hello.c"<br>        }<br>    }<br>    #include "hello.c"<br>}</span></nobr></DIV>
<DIV style="position:absolute;top:508;left:81"><nobr><span class="ft17"><b>3.4 Machine Model Parameters</b></span></nobr></DIV>
<DIV style="position:absolute;top:541;left:81"><nobr><span class="ft5">The version of the VEX compiler supports a limited form of dynamic reconfigurability. The VEX compiler optionally parses a<br>configuration file passed through <b><i>-fmm=&lt;mm_file&gt;</b></i> option. For example, the command</span></nobr></DIV>
<DIV style="position:absolute;top:578;left:135"><nobr><span class="ft10">&lt;vex&gt;/bin/cc hello.c -fmm=config.mm</span></nobr></DIV>
<DIV style="position:absolute;top:604;left:81"><nobr><span class="ft5">reads in the configuration from the <i>config.mm</i> file. The configuration file syntax is a free-format list of <i>&lt;directive, property,<br>value&gt;</i> tuples. The <i>&lt;property&gt;</i> fields are machine-model specific strings and have to match the ones used in the default<br>machine descriptio<A href="vex.html#36">n (Section 6 &quot;Customizing the VEX Toolchain&quot; s</a>pecifies the VEX-specific configuration properties). The<br><i>&lt;value&gt;</i> field is an integer value. The currently supported <i>&lt;directive&gt;</i> commands are:</span></nobr></DIV>
<DIV style="position:absolute;top:682;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:683;left:102"><nobr><span class="ft5"><b>CFG</b>: To set a configuration option. Currently, only <i>"Debug" </i>and <i>"Dump"</i> are supported, <i>"Debug"</i> sets the "verbosity"<br>level of compiler messages when parsing the configuration file. <i>"Dump"</i> instructs the compiler to dump the variables that<br>can be reconfigured with their value, in a format that can be re-read by the compiler itself</span></nobr></DIV>
<DIV style="position:absolute;top:743;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:744;left:102"><nobr><span class="ft27"><b>RES</b>: To set the size of a machine resource. This can be used to set the quantity of resources available in a single instruc-<br>tion. For example: 4 multipliers, 8 issue slots, 3 memory ports, etc.</span></nobr></DIV>
<DIV style="position:absolute;top:787;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:788;left:102"><nobr><span class="ft5"><b>DEL</b>: To set the delay of a computation machine element. This can be use to modify the issue-use delay of an operation<br>(number of instructions between the issue of an operation and the instruction where a consumer of any output can be sched-<br>uled).</span></nobr></DIV>
<DIV style="position:absolute;top:849;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:849;left:102"><nobr><span class="ft5"><b>REG</b>: To set the number of registers of a register bank machine element. Note that registers in a bank can only be reduced<br>from the statically compiled value, and that lower bounds mandated by the RTA must be obeyed (see<A href="vex.html#12"> Section 2 &quot;The VEX<br>Run-Time Architecture&quot;) f</a>or the banks that participate in the calling convention.</span></nobr></DIV>
<DIV style="position:absolute;top:909;left:94"><nobr><span class="ft1">For example, here is a legal configuration file:</span></nobr></DIV>
<DIV style="position:absolute;top:941;left:135"><nobr><span class="ft14">CFG: Debug    1## Verbose compilation<br>RES: Alu.0 </span></nobr></DIV>
<DIV style="position:absolute;top:955;left:248"><nobr><span class="ft10">2## 2 ALUs on cluster 0</span></nobr></DIV>
<DIV style="position:absolute;top:968;left:135"><nobr><span class="ft14">RES: Memory.0 1## 1 Mem port on cluster 0<br>DEL: AluR.0 </span></nobr></DIV>
<DIV style="position:absolute;top:982;left:248"><nobr><span class="ft10">3## 3-cycle integer ops on cluster 0</span></nobr></DIV>
<DIV style="position:absolute;top:995;left:135"><nobr><span class="ft14">DEL: CmpGr.0  3## 3-cycle compare ops on cluster 0<br>REG: $r0     32## Use 32 general purpose registers<br>REG: $b0      2## Use 2 branch registers</span></nobr></DIV>
<DIV style="position:absolute;top:1092;left:81"><nobr><span class="ft28">1. For readers that are more familiar with the GNU C (<i>gcc)</i> compiler, C99 inline hints are very similar to what <i>gcc</i> supports.</span></nobr></DIV>
</DIV>
<!-- Page 30 -->
<a name="30"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="white.png" alt="background image">
<DIV style="position:absolute;top:80;left:81"><nobr><span class="ft17"><b>3.5 Custom Instructions</b></span></nobr></DIV>
<DIV style="position:absolute;top:114;left:81"><nobr><span class="ft5">The VEX compiler includes a limited form of support for user-defined operations at the C language level through <i>_asm*()<br></i>intrinsics. Since these intrinsics map directly into VEX intermediate-level operations (and ultimately assembler operations),<br>they are limited to operations that have no side effects, do not access memry and do not modify any hidden state. When the<br>user inserts a call to <i>_asm()</i> in a C program with the proper parameters, the compiler schedules the operation and allocates the<br>registers. In this way, the user can refer to C variables for operands and destinations. The compiler interprets calls to<i>_asm*()</i> in<br>a special way. The implicit function prototypes for the intrinsics (included in the <i>"vexasm.h"</i> header) are:</span></nobr></DIV>
<DIV style="position:absolute;top:236;left:135"><nobr><span class="ft10">/* From "&lt;vex&gt;/usr/include/vexasm.h" */</span></nobr></DIV>
<DIV style="position:absolute;top:263;left:135"><nobr><span class="ft10">typedef unsigned int </span></nobr></DIV>
<DIV style="position:absolute;top:263;left:483"><nobr><span class="ft10">__vexasm1;</span></nobr></DIV>
<DIV style="position:absolute;top:277;left:135"><nobr><span class="ft10">typedef struct {unsigned int n0,n1;} </span></nobr></DIV>
<DIV style="position:absolute;top:277;left:483"><nobr><span class="ft10">__vexasm2;</span></nobr></DIV>
<DIV style="position:absolute;top:290;left:135"><nobr><span class="ft10">typedef struct {unsigned int n0,n1,n2;} </span></nobr></DIV>
<DIV style="position:absolute;top:290;left:483"><nobr><span class="ft10">__vexasm3;</span></nobr></DIV>
<DIV style="position:absolute;top:304;left:135"><nobr><span class="ft10">typedef struct {unsigned int n0,n1,n2,n3;} __vexasm4;</span></nobr></DIV>
<DIV style="position:absolute;top:331;left:135"><nobr><span class="ft14">void      _asm0(int opcode, ...);<br>__vexasm1 _asm1(int opcode, ...);<br>__vexasm2 _asm2(int opcode, ...);<br>__vexasm3 _asm3(int opcode, ...);<br>__vexasm4 _asm4(int opcode, ...);</span></nobr></DIV>
<DIV style="position:absolute;top:429;left:94"><nobr><span class="ft1">The first argument (<i>opcode</i>) is a numeric identifier for the operation; the other (optional) arguments after <i>opcode</i> represent</span></nobr></DIV>
<DIV style="position:absolute;top:447;left:81"><nobr><span class="ft5">the values read by the operation (with a limit of 8). Currently, <i>_asm*() </i>calls can only represent operations with zerot to four<br>return values. Taking the address of an <i>_asm*() </i>function is illegal. The following is an example of <i>_asm*()</i> usage.</span></nobr></DIV>
<DIV style="position:absolute;top:497;left:135"><nobr><span class="ft14">#include &lt;vexasm.h&gt;<br>void foo(int *c, int *a, int *b, int size)<br>{<br>    int p;<br>    for (p = 0; p &lt; size; p++) {<br>        *c++ = (int)_asm1(0x12,*a++,*b++);<br>    }<br>}</span></nobr></DIV>
<DIV style="position:absolute;top:618;left:94"><nobr><span class="ft1">In the above example, we are calling the intrinsic number 0x12 with 2 arguments for all the elements of an array and storing</span></nobr></DIV>
<DIV style="position:absolute;top:636;left:81"><nobr><span class="ft5">its result in a third array. If, for example, the intrinsic 0x12 implements the "average" function, we can think of writing the<br>code in a more readable form, such as:</span></nobr></DIV>
<DIV style="position:absolute;top:686;left:135"><nobr><span class="ft10">#include &lt;vexasm.h&gt;</span></nobr></DIV>
<DIV style="position:absolute;top:713;left:135"><nobr><span class="ft10">#define AVG(a,b) ((int)_asm1(0x12,(a),(b)))</span></nobr></DIV>
<DIV style="position:absolute;top:740;left:135"><nobr><span class="ft14">void average (int *c, int *a, int *b, int size)<br>{<br>    int p;<br>    for (p = 0; p &lt; size; p++) {<br>        c<b>++ = </b>AVG(*a++,*b++);<br>    }<br>}</span></nobr></DIV>
<DIV style="position:absolute;top:847;left:94"><nobr><span class="ft1">This produces the following code for the loop body (for a 1-cluster VEX, unrolled twice). The highlighted instructions are</span></nobr></DIV>
<DIV style="position:absolute;top:865;left:81"><nobr><span class="ft5">the ones that the compiler produces to map the <i>_asm1()</i> intrinsic calls. As we can see, the compiler schedules the code around<br>the intrinsic calls and operates the usual optimizations and register allocation tasks.</span></nobr></DIV>
<DIV style="position:absolute;top:916;left:135"><nobr><span class="ft14">L0?3:<br>        c0    cmplt $b0.0 = $r0.5, 1<br>        c0    ldw.d $r0.3 = 0[$r0.2]<br>        c0    cmplt $b0.1 = $r0.5, $r0.0<br>        c0    add $r0.5 = $r0.5, 2<br>;;            <br>        c0    ldw.d $r0.7 = 0[$r0.4]<br>;;                                                              <br>        c0    ldw.d $r0.8 = 4[$r0.2]<br>        c0    add $r0.2 = $r0.2, 8<br>        c0    brf $b0.0, L1?3    <br>;;                                                               <br>        c0    ldw.d $r0.9 = 4[$r0.4]   <br>        c0    add $r0.4 = $r0.4, 8</span></nobr></DIV>
</DIV>
<!-- Page 31 -->
<a name="31"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="vex031.png" alt="background image">
<DIV style="position:absolute;top:82;left:135"><nobr><span class="ft14">;;                                                              <br>        c0    <b>asm,18</b> $r0.3 = $r0.3, $r0.7<br>;;                                      <br>        c0    stw 0[$r0.6] = $r0.3<br>        c0    brf $b0.1, L2?3<br>;;      <br>        c0    <b>asm,18</b> $r0.8 = $r0.8, $r0.9<br>;;                                                              <br>        c0    stw 4[$r0.6] = $r0.8     <br>        c0    add $r0.6 = $r0.6, 8   <br>        c0    goto L0?3 <br>;;<br>L1$3:</span></nobr></DIV>
<DIV style="position:absolute;top:270;left:94"><nobr><span class="ft1">In terms of resource usage, the compiler built-in assumption is that an <i>_asm*() </i>operation occupies a number of issue slots</span></nobr></DIV>
<DIV style="position:absolute;top:288;left:81"><nobr><span class="ft5">that is the maximum of the number of output registers it produces (with a minimum of one) and half the number of input regis-<br>ters it consumes (with a minimum of one). This default can be overridden with a compiler configuaration file, as described in<br><A href="vex.html#29">Section 3.4 &quot;Machine Model Parameters&quot;.</a> The VEX compiler implicitly assumes two groups of <i>_asm</i> intrinsics: <i>group A</i> (with<br><i>asm  </i>opcodes from 0 to 63) has a default latency of 1 cycle, and <i>group B </i>(with <i>asm</i> opcodes from 64 to 127) has a default<br>latency of 2 cycles. Default latencies can be changed by providing a machine model configuration file to the compiler, as we<br>describe in <i><A href="vex.html#29">Section 3.4 &quot;Machine Model Parameters&quot;</i>.</a></span></nobr></DIV>
<DIV style="position:absolute;top:421;left:81"><nobr><span class="ft7"><b>4 Visualization Tools</b></span></nobr></DIV>
<DIV style="position:absolute;top:463;left:81"><nobr><span class="ft6">Many of the VEX tools are capable of emitting graph information that is compatible with the VCG <i>(Visualization of Compiler<br>Graph</i></span></nobr></DIV>
<DIV style="position:absolute;top:477;left:120"><nobr><span class="ft28">1</span></nobr></DIV>
<DIV style="position:absolute;top:481;left:126"><nobr><span class="ft2"><i>)</i> tools. The compiler can emit the following information in VCG form:</span></nobr></DIV>
<DIV style="position:absolute;top:505;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:506;left:102"><nobr><span class="ft27">Control flow graphs<A href=""> (Figure 9</a>) for each of the procedures of a compilation unit, through the "<i>-fdraw-cfg</i>" command-line<br>option.</span></nobr></DIV>
<DIV style="position:absolute;top:548;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:549;left:102"><nobr><span class="ft33">DAGs <A href="">(Figure 10)</a> for each of the individual traces of the first procedure of a compilation unit, through the <i>"-fdraw-<br>dag=&lt;trace_num&gt;"</i> and <i>"-fdag-file=&lt;name&gt;"</i> command-line options.</span></nobr></DIV>
<DIV style="position:absolute;top:592;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:593;left:102"><nobr><span class="ft1">Compacted schedules<A href=""> (Figure 11) i</a>n VCG form can be produced from any VEX assembler file by using the <i>schplot</i> utility</span></nobr></DIV>
<DIV style="position:absolute;top:616;left:102"><nobr><span class="ft1">(in <i>&lt;vex&gt;/bin/schplot</i>).</span></nobr></DIV>
<DIV style="position:absolute;top:1077;left:81"><nobr><span class="ft30">1. VCG stands for "Visualization of Compiler Graphs", and is a tool (designed primarily by George Sanders and used in the ESPRIT project #5399 COM-<br>PARE) that generates and displays a layout of the graphs as they occur typically in compiler construction. </span></nobr></DIV>
<DIV style="position:absolute;top:975;left:145"><nobr><span class="ft13"><b>Figure 10   Example of DAG visualization. </b></span></nobr></DIV>
<DIV style="position:absolute;top:975;left:429"><nobr><span class="ft21">As one could expect, nodes are VEX operations, and</span></nobr></DIV>
<DIV style="position:absolute;top:992;left:145"><nobr><span class="ft26">edges are dependence graphs. The description allows turning on and off edge types (flow, anti, con-<br>straints, etc.) for easier visualization of complex DAGs.</span></nobr></DIV>
</DIV>
<!-- Page 32 -->
<a name="32"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="vex032.png" alt="background image">
<DIV style="position:absolute;top:904;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:905;left:102"><nobr><span class="ft1">Profiling information. To visualize profiling information, the VEX distribution includes the <i>rgg</i> utility (in <i>&lt;vex&gt;/bin/rgg</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:928;left:102"><nobr><span class="ft1">that converts the standard <i>gprof</i> output into a VCG call gra<A href="">ph (Figure 13).</a></span></nobr></DIV>
<DIV style="position:absolute;top:953;left:81"><nobr><span class="ft5">Visualization tools are often a very useful instrument in the development of tuned applications. In particular, profiling visual-<br>ization is an invaluable tool to help determine where to spend time in the source-level optimization of a complex application.<br>Profiling is usually necessary regardless of the target architecture style. For machines with ILP like VEX, once the most<br>important routines are isolated, DAG visualization helps the fine-tuning of the implementation. For example, it easily shows if<br>we are successful in removing dependences: by turning a "deep" DAG into a "shallow" DAG, we can immediately see that we<br>have exposed a larger amount of ILP ().</span></nobr></DIV>
<DIV style="position:absolute;top:447;left:152"><nobr><span class="ft13"><b>Figure 9   Example of control-flow graph visualization. </b></span></nobr></DIV>
<DIV style="position:absolute;top:447;left:514"><nobr><span class="ft21">Nodes are basic blocks of a function, and</span></nobr></DIV>
<DIV style="position:absolute;top:464;left:152"><nobr><span class="ft26">edges are control flow links (branches). The VEX compiler also emits the individual operations inside<br>each block (omitted from this picture for simplicity. The control flow graph can be emitted at various<br>stages, before and after optimization.</span></nobr></DIV>
<DIV style="position:absolute;top:835;left:147"><nobr><span class="ft13"><b>Figure 11   Example of schedule visualization. </b></span></nobr></DIV>
<DIV style="position:absolute;top:835;left:446"><nobr><span class="ft21">This is a pictorial representation of the scheduled VEX</span></nobr></DIV>
<DIV style="position:absolute;top:852;left:147"><nobr><span class="ft26">assembler output. While its primary use is mostly decorative (or educational), it also provides a quick<br>visual impression of the utilization of the machine in a given trace.</span></nobr></DIV>
</DIV>
<!-- Page 33 -->
<a name="33"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="vex033.png" alt="background image">
<DIV style="position:absolute;top:760;left:81"><nobr><span class="ft7"><b>5 The VEX Simulation System</b></span></nobr></DIV>
<DIV style="position:absolute;top:803;left:81"><nobr><span class="ft5">The VEX simulator used a so-called <i>compiled simulation</i> technique. The compiled simulator (CS) translates the VEX binary<br>to the binary of the host computer, by first converting VEX to C, and then invoking the host C compiler to produce a host exe-<br>cutable.</span></nobr></DIV>
<DIV style="position:absolute;top:857;left:94"><nobr><span class="ft1">In addition to the standard semantics of the instructions, CS also emits instrumentation code to count cycles (and other inter-</span></nobr></DIV>
<DIV style="position:absolute;top:875;left:81"><nobr><span class="ft5">esting statistics), as well as code to dump the results to a log file at the end of the simulation (the log file is called <i>`ta.log.###'</i>).<br>Timing instrumentation is turned on with the "<b>-mas_t</b>" flag passed to the compiler driver (or "<b>-mas_ti</b>" and "<b>-mas_td</b>" for<br>finer grain control - see the section on compiler flags). By default, CS also performs a simple one-level cache simulation.</span></nobr></DIV>
<DIV style="position:absolute;top:929;left:94"><nobr><span class="ft1">CS operates on each of the individual VEX assembler (<i>.s</i>) files corresponding to the compilation units of a program and</span></nobr></DIV>
<DIV style="position:absolute;top:947;left:81"><nobr><span class="ft5">translates them back to C by implementing the VEX operation semantics, the calling convention (ABI), and introducing the<br>appropriate instrumentation code. The CS-generated C files are then compiled with the host platform C compiler (e.g., <i>gcc </i>for<br>Linux) and linked with the support libraries that deal with the instrumentation. During linking, the CS <i>ld </i>wrapper ensures that<br>the right libraries are linked in the right order, and performs the necessary "magic" (such as wrapping system functions so that<br>they don't cause problems) for the binary to execute correctly.</span></nobr></DIV>
<DIV style="position:absolute;top:1037;left:94"><nobr><span class="ft1">By default, VEX links in a simple cache simulation library, which models an L1 instruction and data cache. The cache sim-</span></nobr></DIV>
<DIV style="position:absolute;top:1055;left:81"><nobr><span class="ft5">ulator is really a trace simulator, which is embedded in the same binary for performance reasons, but only communicates with<br>the VEX execution engines through simple events that identify memory locations, access types and simulation time. If desired,<br>the default cache simulation can be replaced by a user-defined library which overrides the event-handling routines.</span></nobr></DIV>
<DIV style="position:absolute;top:652;left:145"><nobr><span class="ft13"><b>Figure 12   DAG visualization and ILP. </b></span></nobr></DIV>
<DIV style="position:absolute;top:651;left:391"><nobr><span class="ft21">Both DAGs represent the same simple loop code with or with-</span></nobr></DIV>
<DIV style="position:absolute;top:668;left:145"><nobr><span class="ft26">out the <i>#pragma ivdep</i> (no IV carried dependences). Just looking at the DAGs, it is pretty obvious that<br>the version on the right exposes a much higher degree of ILP (the DAG is "shallow"). In fact, this corre-<br>sponds to a 70% increase in performance (from IPC of 1.55 to 2.65) for a default VEX machine.</span></nobr></DIV>
<DIV style="position:absolute;top:479;left:148"><nobr><span class="ft10">void f1(int *a, int *b, int *c, </span></nobr></DIV>
<DIV style="position:absolute;top:493;left:202"><nobr><span class="ft10">int k, int N)</span></nobr></DIV>
<DIV style="position:absolute;top:506;left:148"><nobr><span class="ft10">{</span></nobr></DIV>
<DIV style="position:absolute;top:520;left:164"><nobr><span class="ft14">int i;<br>#pragma unroll_amount(4,1)</span></nobr></DIV>
<DIV style="position:absolute;top:560;left:164"><nobr><span class="ft10">for (i=0; i &lt; N; ++i) {</span></nobr></DIV>
<DIV style="position:absolute;top:573;left:180"><nobr><span class="ft10">a[i] = (b[i] * k + c[i]) &lt;&lt; N;</span></nobr></DIV>
<DIV style="position:absolute;top:587;left:164"><nobr><span class="ft10">}</span></nobr></DIV>
<DIV style="position:absolute;top:600;left:148"><nobr><span class="ft10">}</span></nobr></DIV>
<DIV style="position:absolute;top:478;left:464"><nobr><span class="ft10">void f1(int *a, int *b, int *c, </span></nobr></DIV>
<DIV style="position:absolute;top:492;left:518"><nobr><span class="ft10">int k, int N)</span></nobr></DIV>
<DIV style="position:absolute;top:505;left:464"><nobr><span class="ft10">{</span></nobr></DIV>
<DIV style="position:absolute;top:519;left:481"><nobr><span class="ft55">int i;<br>#pragma unroll_amount(4,1)<br><b>#pragma ivdep<br></b>for (i=0; i &lt; N; ++i) {</span></nobr></DIV>
<DIV style="position:absolute;top:573;left:497"><nobr><span class="ft10">a[i] = (b[i] * k + c[i]) &lt;&lt; N;</span></nobr></DIV>
<DIV style="position:absolute;top:586;left:481"><nobr><span class="ft10">}</span></nobr></DIV>
<DIV style="position:absolute;top:600;left:464"><nobr><span class="ft10">}</span></nobr></DIV>
<DIV style="position:absolute;top:358;left:447"><nobr><span class="ft10">45 ops/17 cycles -&gt; <b>2.65 IPC</b></span></nobr></DIV>
<DIV style="position:absolute;top:399;left:447"><nobr><span class="ft10">45 ops/29 cycles -&gt; <b>1.55 IPC</b></span></nobr></DIV>
</DIV>
<!-- Page 34 -->
<a name="34"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="vex034.png" alt="background image">
<DIV style="position:absolute;top:661;left:81"><nobr><span class="ft9"><i>Gprof support</i></span></nobr></DIV>
<DIV style="position:absolute;top:686;left:81"><nobr><span class="ft5">The VEX simulator includes "simulated" support for <i>gprof</i>, when invoked with the "<b><i>-mas_G</b></i>" option.Unlike <i>gprof </i>running in<br>the host environment, the VEX <i>gprof</i> instrumentation only adds time to the simulation: it is <i>non-invasive </i>as far as the simula-<br>tion itself is concerned, and it is <i>not based on statistical PC-sampling</i>. At the end of simulation, four files are emitted:<br><i>gmon.out </i>containing profile data that include cache simulation, <i>gmon-nocache.out </i>containing profile data that does not include<br>cache simulation, and <i>gmon-icache.out/gmon-dcache.out </i>containing data for respectively only Instruction cache and only Data<br>cache statistics (this requires using the built-in cache simulator). Programmers can compare the two files to identify the parts<br>of an application that put particular pressure on the D-cache or on the I-cache subsystems. To visualize profile data, users can<br>run the <i>&lt;vex&gt;/bin/rgg </i>utility that converts <i>gprof </i>data into a call graph compatible with the format of the graphical interface<br><i>vcg</i> (also distributed as <i>&lt;vex&gt;/bin/xvcg</i>).</span></nobr></DIV>
<DIV style="position:absolute;top:848;left:94"><nobr><span class="ft1">Note that the compiler also supports the <i>-pg</i> option to emit <i>gprof</i> instrumentation part of the VEX code itself. Unlike the</span></nobr></DIV>
<DIV style="position:absolute;top:866;left:81"><nobr><span class="ft5">instrumentation emitted with <i>-mas_G</i>, this instrumentation is invasive, and models what would be necessary to do for a non-<br>simulated target.</span></nobr></DIV>
<DIV style="position:absolute;top:902;left:94"><nobr><span class="ft1">Profiling flags are most commonly used in conjunction with timing flags (<b><i>-mas_t</b></i>). If the profiling flag is turned of without</span></nobr></DIV>
<DIV style="position:absolute;top:920;left:81"><nobr><span class="ft1">the timing flag, the <i>call tree</i> is emitted at exit, but no timing information is available in the <i>gmon.out</i> files.</span></nobr></DIV>
<DIV style="position:absolute;top:938;left:94"><nobr><span class="ft1">Note that <i>gprof </i>profiling and <i>Profile-Based Optimization </i>are two completely separate and distinct features not to be con-</span></nobr></DIV>
<DIV style="position:absolute;top:956;left:81"><nobr><span class="ft5">fused. Profile-Based Optimization (triggered by ­<i>prob_gen</i> and ­<i>prob_use </i>flags) is a two-step compilation process that allows<br>the compiler to collect branch profile data to drive optimizations in a second phase. Profiling with <i>gprof</i> (triggered by the ­<br><i>mas_G</i> flag), on the other hand, collects routine-level profile data for analysis and there is currently no feedback path to the<br>compiler.</span></nobr></DIV>
<DIV style="position:absolute;top:1043;left:81"><nobr><span class="ft9"><i>Simulating custom instructions</i></span></nobr></DIV>
<DIV style="position:absolute;top:1069;left:81"><nobr><span class="ft5">The VEX compiled simulator parses and converts the code produced by the compiler from <i>_asm*()</i> calls (see<A href="vex.html#30"> Section 3.5<br>&quot;Custom Instructions&quot;)</a>, but does not know about the semantics of the operations themselves. To be able to simulate a user-</span></nobr></DIV>
<DIV style="position:absolute;top:516;left:166"><nobr><span class="ft13"><b>Figure 13   Example of visualization of a profiled call graph. </b></span></nobr></DIV>
<DIV style="position:absolute;top:516;left:548"><nobr><span class="ft21">The <i>rgg</i> utility emits a graph rep-</span></nobr></DIV>
<DIV style="position:absolute;top:533;left:166"><nobr><span class="ft26">resentation of the function-level call graph. Each node in the graph corresponds to a procedure<br>and each edge to a procedure call. Nodes are labeled with relative execution times for them-<br>selves (<i>s=%), </i>for the descendent subgraph (<i>t=%</i>), and are color-coded for importance. Edges are<br>labeled with execution counts, with relative execution time, and have a thickness based on their<br>importance. For example<b>, </b>the <i>rgb_to_cmyk</i> function is called 882 times by <i>imgpipe</i> and amounts<br>to 38.2% of execution time (all in the function itself) of the execution under test.</span></nobr></DIV>
</DIV>
<!-- Page 35 -->
<a name="35"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="white.png" alt="background image">
<DIV style="position:absolute;top:81;left:81"><nobr><span class="ft1">defined library, the simulator defines a standard interface for <i>_asm*()</i> type operations as follows:</span></nobr></DIV>
<DIV style="position:absolute;top:104;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:105;left:102"><nobr><span class="ft27">For each <i>asm</i> operation, it produces a call to the function <i>sim_asm_op*()</i> with the proper arguments. The symbols<br><i>sim_asm_op</i>0--<i>sim_asm_op4</i> are reserved and cannot be used in the user program.</span></nobr></DIV>
<DIV style="position:absolute;top:148;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:149;left:102"><nobr><span class="ft1">The prototypes for the <i>sim_asm_op*</i> symbols are:</span></nobr></DIV>
<DIV style="position:absolute;top:187;left:135"><nobr><span class="ft10">typedef unsigned int </span></nobr></DIV>
<DIV style="position:absolute;top:187;left:483"><nobr><span class="ft10">__vexasm1;</span></nobr></DIV>
<DIV style="position:absolute;top:200;left:135"><nobr><span class="ft10">typedef struct {unsigned int n0,n1;} </span></nobr></DIV>
<DIV style="position:absolute;top:200;left:483"><nobr><span class="ft10">__vexasm2;</span></nobr></DIV>
<DIV style="position:absolute;top:214;left:135"><nobr><span class="ft10">typedef struct {unsigned int n0,n1,n2;} </span></nobr></DIV>
<DIV style="position:absolute;top:214;left:483"><nobr><span class="ft10">__vexasm3;</span></nobr></DIV>
<DIV style="position:absolute;top:227;left:135"><nobr><span class="ft10">typedef struct {unsigned int n0,n1,n2,n3;} __vexasm4;</span></nobr></DIV>
<DIV style="position:absolute;top:254;left:135"><nobr><span class="ft10">void sim_asm_op0(int, </span></nobr></DIV>
<DIV style="position:absolute;top:254;left:353"><nobr><span class="ft10">...);</span></nobr></DIV>
<DIV style="position:absolute;top:268;left:135"><nobr><span class="ft14">__vexasm1 sim_asm_op1(int, ...);<br>__vexasm2 sim_asm_op2(int, ...);<br>__vexasm3 sim_asm_op3(int, ...);<br>__vexasm4 sim_asm_op4(int, ...);</span></nobr></DIV>
<DIV style="position:absolute;top:344;left:94"><nobr><span class="ft1">The users must provide an implementation of <i>sim_asm_op*()</i> for the opcodes used in the program, compile it with the host</span></nobr></DIV>
<DIV style="position:absolute;top:362;left:81"><nobr><span class="ft5">compiler and link the object file to the executable. Otherwise a link error would be generated. A sample implementation of the<br><i>sim_asm_op1()</i> function for the previous example may look like this:</span></nobr></DIV>
<DIV style="position:absolute;top:399;left:135"><nobr><span class="ft14">#include &lt;stdarg.h&gt;<br>#include &lt;stdio.h&gt;</span></nobr></DIV>
<DIV style="position:absolute;top:439;left:135"><nobr><span class="ft10">extern unsigned int sim_asm_op1(</span></nobr></DIV>
<DIV style="position:absolute;top:453;left:162"><nobr><span class="ft14">unsigned int opcode,<br>...)</span></nobr></DIV>
<DIV style="position:absolute;top:480;left:135"><nobr><span class="ft14">{<br>    va_list ap;<br>    unsigned int t, s1, s2;<br>    va_start(ap, opcode);</span></nobr></DIV>
<DIV style="position:absolute;top:547;left:135"><nobr><span class="ft10">    switch(opcode) {</span></nobr></DIV>
<DIV style="position:absolute;top:574;left:135"><nobr><span class="ft10">    case 0x12: /* AVG(s1,s2) */</span></nobr></DIV>
<DIV style="position:absolute;top:588;left:189"><nobr><span class="ft14">s1 = va_arg(ap, unsigned int);<br>s2 = va_arg(ap, unsigned int);<br>t = (s1 + s2) / 2;<br>break;</span></nobr></DIV>
<DIV style="position:absolute;top:655;left:135"><nobr><span class="ft10">    default:</span></nobr></DIV>
<DIV style="position:absolute;top:669;left:189"><nobr><span class="ft10">_linux_fprintf(stderr,</span></nobr></DIV>
<DIV style="position:absolute;top:682;left:216"><nobr><span class="ft14">&quot;Error: opcode %d not supported\n&quot;,<br>opcode);</span></nobr></DIV>
<DIV style="position:absolute;top:709;left:189"><nobr><span class="ft10">_linux_exit(1);</span></nobr></DIV>
<DIV style="position:absolute;top:723;left:135"><nobr><span class="ft14">    }<br>    return t;<br>}</span></nobr></DIV>
<DIV style="position:absolute;top:776;left:94"><nobr><span class="ft1">If we write the <i>sim_asm_op1()</i> implementation in <i>asmlib.c, </i>a sample compilation and simulation sequence to be able to test</span></nobr></DIV>
<DIV style="position:absolute;top:794;left:81"><nobr><span class="ft1">the file <i>average.c </i>is:</span></nobr></DIV>
<DIV style="position:absolute;top:826;left:135"><nobr><span class="ft10">1. Compile the VEX with the _asm() calls:</span></nobr></DIV>
<DIV style="position:absolute;top:840;left:186"><nobr><span class="ft10">&lt;vex&gt;/bin/cc ­c average.c</span></nobr></DIV>
<DIV style="position:absolute;top:867;left:135"><nobr><span class="ft10">2. Compile (natively) the asm library</span></nobr></DIV>
<DIV style="position:absolute;top:880;left:186"><nobr><span class="ft10">gcc ­c asmlib.c</span></nobr></DIV>
<DIV style="position:absolute;top:907;left:135"><nobr><span class="ft10">3. Link (with the VEX compiler) the 2 parts together</span></nobr></DIV>
<DIV style="position:absolute;top:921;left:184"><nobr><span class="ft10">&lt;vex&gt;/bin/cc ­o average average.o asmlib.o</span></nobr></DIV>
<DIV style="position:absolute;top:948;left:135"><nobr><span class="ft10">4. Run the <i>average </i>binary</span></nobr></DIV>
<DIV style="position:absolute;top:989;left:81"><nobr><span class="ft9"><i>Simulating Memory Hierarchy</i></span></nobr></DIV>
<DIV style="position:absolute;top:1014;left:81"><nobr><span class="ft5">As we mentioned above, VEX links a simple cache simulation library by default, which only models a (configurable) L1<br>instruction and data cache. In addition, VEX also contains a basic software development kit (SDK) to replace the built-in<br>cache library with a set of user-defined functions. The SDK is in the form of a set of headers for the API that the VEX simula-<br>tor expects when running VEX code. Because of the way in which dynamically linked library work, the default functions can<br>be overridden by linking a natively compiled library that redefines them. Users must redefine <i>initialization</i> and <i>finalization</i></span></nobr></DIV>
</DIV>
<!-- Page 36 -->
<a name="36"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="vex036.png" alt="background image">
<DIV style="position:absolute;top:81;left:81"><nobr><span class="ft5">routines (called at the begin and end of the simulation), as well as <i>data tracing</i> functions for each of the memory access types.<br>The <i>tracing</i> functions are called at every data memory access (or simulated instruction cache line fetch), but do not affect the<br>execution of the program semantics. In this way, the redefined routines can implement arbitrary behaviors, while preserving<br>the correct program execution. Time is accounted for separately in the execution engine and in the cache simulation model. </span></nobr></DIV>
<DIV style="position:absolute;top:153;left:94"><nobr><span class="ft1">Simulating instruction caches is a particularly challenging task in a compiled simulator, if we want to be able to link with</span></nobr></DIV>
<DIV style="position:absolute;top:171;left:81"><nobr><span class="ft5">modules compiled for the simulation host. In this case, we cannot build a simulated VEX memory model, but we have to keep<br>the one that the host mandates. VEX models instruction caches by simulating a dynamic loader that assigns addresses to every<br>compilation unit as soon as one of its functions is loaded. This deviates from a statically linked model, but still provides signif-<br>icant instruction cache behavior.</span></nobr></DIV>
<DIV style="position:absolute;top:268;left:81"><nobr><span class="ft7"><b>6 Customizing the VEX Toolchain</b></span></nobr></DIV>
<DIV style="position:absolute;top:310;left:81"><nobr><span class="ft5">The idea behind VEX is to provide a flexible environment for architecture exploration of VLIW architectures. As such, it<br>allows users to selectively change the compiler target and many of the simulation parameters. The VEX compiler, in addition<br>to the standard compile-time options (flags), optionally reads a compile-time configuration file where it is possible to define<br>machine resources such as number and latency of functional units, and number of registers for each architected register files.<br>The compiled simulator also optionally reads a configuration file where users can specify execution-time parameters, such as<br>clock and bus cycles, cache parameters (size, associativity, refill latency, etc.) and various advanced options. Finally, VEX<br>includes an extension mechanism by means of which it is possible to introduce user-defined custom instructions (also known<br>as <i>assembler intrinsics</i>). VEX <i>intrinsics</i> are modeled as black boxes, so they need to be explicitly instantiated (through a spe-<br>cial naming convention) in the C sources; once the compiler recognizes them, it optimizes around them, schedules and regis-<br>ters allocates them like any other operation.</span></nobr></DIV>
<DIV style="position:absolute;top:490;left:94"><nobr><span class="ft1">The following sections describe in some detail the three configuration options in VEX. Note that all VEX tools come with a</span></nobr></DIV>
<DIV style="position:absolute;top:508;left:81"><nobr><span class="ft1">default configuration described in <A href="">Table 11.</a></span></nobr></DIV>
<DIV style="position:absolute;top:541;left:152"><nobr><span class="ft13"><b>Table 11: VEX default parameters</b></span></nobr></DIV>
<DIV style="position:absolute;top:573;left:161"><nobr><span class="ft13"><b>Parameter</b></span></nobr></DIV>
<DIV style="position:absolute;top:573;left:269"><nobr><span class="ft13"><b>Description</b></span></nobr></DIV>
<DIV style="position:absolute;top:573;left:440"><nobr><span class="ft13"><b>Default</b></span></nobr></DIV>
<DIV style="position:absolute;top:573;left:559"><nobr><span class="ft13"><b>How to change</b></span></nobr></DIV>
<DIV style="position:absolute;top:601;left:161"><nobr><span class="ft21">Clusters</span></nobr></DIV>
<DIV style="position:absolute;top:601;left:269"><nobr><span class="ft26">VLIW clusters (fully inter-<br>connected groups of units <br>and register files)</span></nobr></DIV>
<DIV style="position:absolute;top:601;left:440"><nobr><span class="ft21">1</span></nobr></DIV>
<DIV style="position:absolute;top:601;left:559"><nobr><span class="ft26">Compile time flag: <i>-width &lt;n&gt;</i> <br>option (only 1, 2 and 4 clusters <br>allowed)</span></nobr></DIV>
<DIV style="position:absolute;top:663;left:161"><nobr><span class="ft21">Issue width</span></nobr></DIV>
<DIV style="position:absolute;top:663;left:269"><nobr><span class="ft26">Total number of opera-<br>tions in a VLIW instruc-<br>tion (cycle)</span></nobr></DIV>
<DIV style="position:absolute;top:663;left:440"><nobr><span class="ft21">4 per cluster</span></nobr></DIV>
<DIV style="position:absolute;top:663;left:559"><nobr><span class="ft21">Compile time machine model</span></nobr></DIV>
<DIV style="position:absolute;top:724;left:161"><nobr><span class="ft21">Integer ALUs</span></nobr></DIV>
<DIV style="position:absolute;top:724;left:269"><nobr><span class="ft26">Units for integer opera-<br>tions, comparisons, shifts</span></nobr></DIV>
<DIV style="position:absolute;top:724;left:440"><nobr><span class="ft26">4 per cluster, <br>1-cycle latency</span></nobr></DIV>
<DIV style="position:absolute;top:724;left:559"><nobr><span class="ft21">Compile time machine model</span></nobr></DIV>
<DIV style="position:absolute;top:769;left:161"><nobr><span class="ft21">Integer MULs</span></nobr></DIV>
<DIV style="position:absolute;top:769;left:269"><nobr><span class="ft26">Units for integer multipli-<br>cations</span></nobr></DIV>
<DIV style="position:absolute;top:769;left:440"><nobr><span class="ft26">2 per cluster, <br>2-cycle latency</span></nobr></DIV>
<DIV style="position:absolute;top:769;left:559"><nobr><span class="ft21">Compile time machine model</span></nobr></DIV>
<DIV style="position:absolute;top:814;left:161"><nobr><span class="ft26">Integer regis-<br>ters (GRs)</span></nobr></DIV>
<DIV style="position:absolute;top:814;left:269"><nobr><span class="ft26">General purpose regis-<br>ters</span></nobr></DIV>
<DIV style="position:absolute;top:814;left:440"><nobr><span class="ft26">64 per cluster, <br>32 bits</span></nobr></DIV>
<DIV style="position:absolute;top:814;left:559"><nobr><span class="ft26">Compile time machine model <br>(GRs can only be decreased)</span></nobr></DIV>
<DIV style="position:absolute;top:859;left:161"><nobr><span class="ft26">Branch regis-<br>ters (BRs)</span></nobr></DIV>
<DIV style="position:absolute;top:859;left:269"><nobr><span class="ft26">Branch condition and <br>predicate registers</span></nobr></DIV>
<DIV style="position:absolute;top:859;left:440"><nobr><span class="ft26">8 per cluster, 1 <br>bit</span></nobr></DIV>
<DIV style="position:absolute;top:859;left:559"><nobr><span class="ft26">Compile time machine model <br>(BRs can only be decreased)</span></nobr></DIV>
<DIV style="position:absolute;top:904;left:161"><nobr><span class="ft21">Link register</span></nobr></DIV>
<DIV style="position:absolute;top:904;left:269"><nobr><span class="ft26">Address for indirect <br>branches</span></nobr></DIV>
<DIV style="position:absolute;top:904;left:440"><nobr><span class="ft26">1 in cluster 0, 32 <br>bits</span></nobr></DIV>
<DIV style="position:absolute;top:904;left:559"><nobr><span class="ft21">Cannot be changed</span></nobr></DIV>
<DIV style="position:absolute;top:949;left:161"><nobr><span class="ft21">Memory load</span></nobr></DIV>
<DIV style="position:absolute;top:949;left:269"><nobr><span class="ft21">Units to load from mem</span></nobr></DIV>
<DIV style="position:absolute;top:949;left:440"><nobr><span class="ft26">1 per cluster, 3-<br>cycle latency</span></nobr></DIV>
<DIV style="position:absolute;top:949;left:559"><nobr><span class="ft21">Compile time machine model</span></nobr></DIV>
<DIV style="position:absolute;top:994;left:161"><nobr><span class="ft21">Memory store</span></nobr></DIV>
<DIV style="position:absolute;top:994;left:269"><nobr><span class="ft21">Units to store to mem</span></nobr></DIV>
<DIV style="position:absolute;top:994;left:440"><nobr><span class="ft26">1 per cluster, 1-<br>cycle latency</span></nobr></DIV>
<DIV style="position:absolute;top:994;left:559"><nobr><span class="ft21">Compile time machine model</span></nobr></DIV>
<DIV style="position:absolute;top:1039;left:161"><nobr><span class="ft21">Memory pft</span></nobr></DIV>
<DIV style="position:absolute;top:1039;left:269"><nobr><span class="ft21">Units to prefetch mem</span></nobr></DIV>
<DIV style="position:absolute;top:1039;left:440"><nobr><span class="ft21">1 per cluster</span></nobr></DIV>
<DIV style="position:absolute;top:1039;left:559"><nobr><span class="ft21">Compile time machine model</span></nobr></DIV>
<DIV style="position:absolute;top:1068;left:161"><nobr><span class="ft21">Copy units</span></nobr></DIV>
<DIV style="position:absolute;top:1068;left:269"><nobr><span class="ft26">Src/dst for intercluster <br>copy operations</span></nobr></DIV>
<DIV style="position:absolute;top:1068;left:440"><nobr><span class="ft26">1 src + 1 dst per <br>cluster, 1-cycle</span></nobr></DIV>
<DIV style="position:absolute;top:1068;left:559"><nobr><span class="ft21">Compile time machine model</span></nobr></DIV>
</DIV>
<!-- Page 37 -->
<a name="37"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="white.png" alt="background image">
<DIV style="position:absolute;top:81;left:81"><nobr><span class="ft9"><i>Clusters</i></span></nobr></DIV>
<DIV style="position:absolute;top:106;left:81"><nobr><span class="ft9"><i>B</i></span></nobr></DIV>
<DIV style="position:absolute;top:106;left:91"><nobr><span class="ft1">y default, the VEX compiler generates code for a one-cluster VEX architecture. The option <b><i>-width n</b></i> changes the number of</span></nobr></DIV>
<DIV style="position:absolute;top:124;left:81"><nobr><span class="ft1">clusters to <i>n, </i>which must be either 1, 2, or 4.</span></nobr></DIV>
<DIV style="position:absolute;top:157;left:81"><nobr><span class="ft9"><i>Machine Model Resources</i></span></nobr></DIV>
<DIV style="position:absolute;top:183;left:81"><nobr><span class="ft5">Here we describe the properties that are relevant for the VEX-specific machine description. Most of these should be supported<br>with the compiler producing correct code. They are classified in:</span></nobr></DIV>
<DIV style="position:absolute;top:224;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:225;left:102"><nobr><span class="ft3"><b>Computational Machine Elements</b>: properties for <i>DEL</i> directives</span></nobr></DIV>
<DIV style="position:absolute;top:250;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:251;left:102"><nobr><span class="ft3"><b>Register Bank Machine Elements</b>: properties for <i>REG</i> directives</span></nobr></DIV>
<DIV style="position:absolute;top:275;left:81"><nobr><span class="ft8"><b>·</b></span></nobr></DIV>
<DIV style="position:absolute;top:276;left:102"><nobr><span class="ft3"><b>Machine Resources</b>: properties for <i>RES</i> directives</span></nobr></DIV>
<DIV style="position:absolute;top:300;left:94"><nobr><span class="ft1">Note that some of these properties are cluster-specific. The example below shows properties for cluster 0 (suffix '.0'). To get</span></nobr></DIV>
<DIV style="position:absolute;top:318;left:81"><nobr><span class="ft5">the same properties for the other identical clusters, replace prefix/suffix accordingly (for example: <i>DEL:CmpGr.1</i> is for cluster<br>1, <i>RES:Alu.2 </i>is for cluster 2, etc.).</span></nobr></DIV>
<DIV style="position:absolute;top:361;left:81"><nobr><span class="ft3"><b>Computational MEs </b>can be used in a "DEL" directive:</span></nobr></DIV>
<DIV style="position:absolute;top:394;left:135"><nobr><span class="ft10">AluR.0</span></nobr></DIV>
<DIV style="position:absolute;top:394;left:264"><nobr><span class="ft10">Integer Op, Immediate on Src1</span></nobr></DIV>
<DIV style="position:absolute;top:407;left:135"><nobr><span class="ft10">Alu.0</span></nobr></DIV>
<DIV style="position:absolute;top:407;left:264"><nobr><span class="ft10">Integer Op, Immediate on Src2</span></nobr></DIV>
<DIV style="position:absolute;top:421;left:135"><nobr><span class="ft10">CmpGr.0 </span></nobr></DIV>
<DIV style="position:absolute;top:421;left:264"><nobr><span class="ft10">Compare to general register / select</span></nobr></DIV>
<DIV style="position:absolute;top:434;left:135"><nobr><span class="ft10">CmpBr.0 </span></nobr></DIV>
<DIV style="position:absolute;top:434;left:264"><nobr><span class="ft10">Compare to branch</span></nobr></DIV>
<DIV style="position:absolute;top:448;left:135"><nobr><span class="ft14">Select.0 Select<br>Mulitply.0 Multiply<br>Load.0 </span></nobr></DIV>
<DIV style="position:absolute;top:475;left:264"><nobr><span class="ft10">Load Word to GR</span></nobr></DIV>
<DIV style="position:absolute;top:488;left:135"><nobr><span class="ft10">LoadLr.0</span></nobr></DIV>
<DIV style="position:absolute;top:488;left:264"><nobr><span class="ft10">Load Word to LR</span></nobr></DIV>
<DIV style="position:absolute;top:502;left:135"><nobr><span class="ft14">Pft.0 Prefetch<br>Asm1L.0 </span></nobr></DIV>
<DIV style="position:absolute;top:515;left:264"><nobr><span class="ft10">User-defined asm, Group A, 1 Slot</span></nobr></DIV>
<DIV style="position:absolute;top:529;left:135"><nobr><span class="ft14">Asm2L.0         User-defined asm, Group A, 2 Slots<br>Asm3L.0         User-defined asm, Group A, 3 Slots<br>Asm4L.0         User-defined asm, Group A, 4 Slots<br>Asm1H.0         User-defined asm, Group B, 1 Slot<br>Asm2H.0         User-defined asm, Group B, 2 Slots<br>Asm3H.0         User-defined asm, Group B, 3 Slots<br>Asm4H.0         User-defined asm, Group B, 4 Slots<br>CpGrBr.0        Copy GR to BR<br>CpBrGr.0        Copy BR to GR<br>CpGrLr.0        Copy GR to LR<br>CpLrGr.0        Copy LR to GR<br>Spill.0</span></nobr></DIV>
<DIV style="position:absolute;top:677;left:264"><nobr><span class="ft10">Spill (Store)</span></nobr></DIV>
<DIV style="position:absolute;top:691;left:135"><nobr><span class="ft10">Restore.0</span></nobr></DIV>
<DIV style="position:absolute;top:691;left:264"><nobr><span class="ft10">Restore GR (Load)</span></nobr></DIV>
<DIV style="position:absolute;top:704;left:135"><nobr><span class="ft10">RestoreLr.0</span></nobr></DIV>
<DIV style="position:absolute;top:704;left:264"><nobr><span class="ft10">Restore LR (Load)</span></nobr></DIV>
<DIV style="position:absolute;top:738;left:81"><nobr><span class="ft3"><b>Register Bank MEs </b>can be used in a "REG" directive:</span></nobr></DIV>
<DIV style="position:absolute;top:770;left:135"><nobr><span class="ft14">$r0          General Purpose Register Bank<br>$b0          Branch Register Bank</span></nobr></DIV>
<DIV style="position:absolute;top:817;left:81"><nobr><span class="ft3"><b>Machine Resources </b>can be used in a "RES" directive.</span></nobr></DIV>
<DIV style="position:absolute;top:850;left:135"><nobr><span class="ft55"><b>Global Resources<br></b>IssueWidth</span></nobr></DIV>
<DIV style="position:absolute;top:863;left:264"><nobr><span class="ft10">Total issued operations (&gt; 0)</span></nobr></DIV>
<DIV style="position:absolute;top:877;left:135"><nobr><span class="ft10">MemStore</span></nobr></DIV>
<DIV style="position:absolute;top:877;left:264"><nobr><span class="ft10">Total Store Ops (&gt; 0)</span></nobr></DIV>
<DIV style="position:absolute;top:890;left:135"><nobr><span class="ft10">MemLoad </span></nobr></DIV>
<DIV style="position:absolute;top:890;left:264"><nobr><span class="ft10">Total Load Ops (&gt; 0)</span></nobr></DIV>
<DIV style="position:absolute;top:917;left:135"><nobr><span class="ft55"><b>Cluster Resources<br></b>Alu.0 </span></nobr></DIV>
<DIV style="position:absolute;top:931;left:240"><nobr><span class="ft10">Integer ALU slots (&gt;= 2)</span></nobr></DIV>
<DIV style="position:absolute;top:944;left:135"><nobr><span class="ft10">AluR.0 </span></nobr></DIV>
<DIV style="position:absolute;top:944;left:240"><nobr><span class="ft10">Integer ALU slots - imm. on src1 (&gt;= 2)</span></nobr></DIV>
<DIV style="position:absolute;top:958;left:135"><nobr><span class="ft10">Mpy.0</span></nobr></DIV>
<DIV style="position:absolute;top:958;left:240"><nobr><span class="ft10">Multiply slots (&gt; 0)</span></nobr></DIV>
<DIV style="position:absolute;top:971;left:135"><nobr><span class="ft10">CopySrc.0 </span></nobr></DIV>
<DIV style="position:absolute;top:971;left:240"><nobr><span class="ft10">Copy-Source slots (&gt; 0)</span></nobr></DIV>
<DIV style="position:absolute;top:985;left:135"><nobr><span class="ft10">CopyDst.0 </span></nobr></DIV>
<DIV style="position:absolute;top:985;left:240"><nobr><span class="ft10">Copy-Dest slots (&gt; 0)</span></nobr></DIV>
<DIV style="position:absolute;top:998;left:135"><nobr><span class="ft10">Memory.0</span></nobr></DIV>
<DIV style="position:absolute;top:998;left:240"><nobr><span class="ft10">Memory load slots (&gt; 0)</span></nobr></DIV>
<DIV style="position:absolute;top:1039;left:81"><nobr><span class="ft9"><i>Memory Hierarchy Parameters</i></span></nobr></DIV>
<DIV style="position:absolute;top:1065;left:81"><nobr><span class="ft5">The built-in cache simulator in the Compiled Simulator currently supports a method to set most of the relevant parameters for<br>the simulated memory and bus.. The method to instruct the compiled simulator about the configuration parameters is through a</span></nobr></DIV>
</DIV>
<!-- Page 38 -->
<a name="38"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="vex038.png" alt="background image">
<DIV style="position:absolute;top:81;left:81"><nobr><span class="ft1">configuration file made of <i>&lt;property&gt; &lt;value&gt;</i> pairs. An example follows.</span></nobr></DIV>
<DIV style="position:absolute;top:113;left:135"><nobr><span class="ft14">CoreCkFreq           500<br>BusCkFreq            200<br>lg2CacheSize</span></nobr></DIV>
<DIV style="position:absolute;top:140;left:305"><nobr><span class="ft10">15 # (CacheSize = 32768)</span></nobr></DIV>
<DIV style="position:absolute;top:154;left:135"><nobr><span class="ft14">lg2Sets              2  # (Sets = 4)<br>lg2LineSize          5  # (LineSize = 32)<br>MissPenalty          25<br>WBPenalty            22<br>lg2StrSize           9  # (StrSize = 512)<br>lg2StrSets           4  # (StrSets = 16)<br>lg2StrLineSize       5  # (StrLineSize = 32)<br>StrMissPenalty       25<br>StrWBPenalty         22<br>lg2ICacheSize </span></nobr></DIV>
<DIV style="position:absolute;top:275;left:305"><nobr><span class="ft10">15 # (ICacheSize = 32768)</span></nobr></DIV>
<DIV style="position:absolute;top:289;left:135"><nobr><span class="ft14">lg2ICacheSets        0  # (ICacheSets = 1)<br>lg2ICacheLineSize    6  # (ICacheLineSize = 64)<br>ICachePenalty        30<br>NumCaches         </span></nobr></DIV>
<DIV style="position:absolute;top:329;left:305"><nobr><span class="ft10">1</span></nobr></DIV>
<DIV style="position:absolute;top:343;left:135"><nobr><span class="ft14">StreamEnable         FALSE<br>PrefetchEnable       TRUE<br>LockEnable           FALSE<br>ProfGranularity      1.000000</span></nobr></DIV>
<DIV style="position:absolute;top:409;left:94"><nobr><span class="ft1">In the following table we describe the individual parameters in detail.</span></nobr></DIV>
<DIV style="position:absolute;top:856;left:94"><nobr><span class="ft1">The compiled simulator looks for a file called <i>vex.cfg</i> in the invocation directory and parses it according to the syntax above,</span></nobr></DIV>
<DIV style="position:absolute;top:874;left:81"><nobr><span class="ft5">if the file is present. Alternatively, it is possible to use the environment variable <i>VEXCFG</i> to pass the name of the simulation<br>configuration file.</span></nobr></DIV>
<DIV style="position:absolute;top:935;left:81"><nobr><span class="ft7"><b>7 Examples of tool usage</b></span></nobr></DIV>
<DIV style="position:absolute;top:978;left:81"><nobr><span class="ft5">This last section lists some sample use of the VEX tools to cover the most likely scenarios for software development, experi-<br>mentation and architecture exploration through the VEX toolset. The example assume familiarity with the Linux operating<br>system and command-line shells. All examples assume that the VEX toolchain is installed in <i>/home/vex</i>.</span></nobr></DIV>
<DIV style="position:absolute;top:1051;left:81"><nobr><span class="ft17"><b>7.1 Compile and run</b></span></nobr></DIV>
<DIV style="position:absolute;top:1084;left:81"><nobr><span class="ft1">The first example is a simple "compile-and-run" sequence of a program composed of two compilation units <i>file1.o </i>and <i>file2.o</i></span></nobr></DIV>
<DIV style="position:absolute;top:442;left:158"><nobr><span class="ft13"><b>Table 12: Parameters for the built-in VEX cache simulator</b></span></nobr></DIV>
<DIV style="position:absolute;top:468;left:162"><nobr><span class="ft31"><i>CoreCkFreq</i></span></nobr></DIV>
<DIV style="position:absolute;top:467;left:294"><nobr><span class="ft21">The frequency of the core clock, in MHz</span></nobr></DIV>
<DIV style="position:absolute;top:487;left:162"><nobr><span class="ft31"><i>BusCkFreq</i></span></nobr></DIV>
<DIV style="position:absolute;top:487;left:294"><nobr><span class="ft21">The frequency of the bus clock, in MHz</span></nobr></DIV>
<DIV style="position:absolute;top:506;left:162"><nobr><span class="ft31"><i>lg2CacheSize</i></span></nobr></DIV>
<DIV style="position:absolute;top:506;left:294"><nobr><span class="ft21">The log2 of the data cache size in bytes (e.g., 10 =&gt; 1KB)</span></nobr></DIV>
<DIV style="position:absolute;top:526;left:162"><nobr><span class="ft31"><i>lg2Sets</i></span></nobr></DIV>
<DIV style="position:absolute;top:526;left:294"><nobr><span class="ft21">The log2 of the data cache associativity (e.g, 2 =&gt; 4-way set-associative)</span></nobr></DIV>
<DIV style="position:absolute;top:546;left:162"><nobr><span class="ft31"><i>lg2LineSize</i></span></nobr></DIV>
<DIV style="position:absolute;top:546;left:294"><nobr><span class="ft21">The log2 of the data cache line size in bytes (e.g. 8 =&gt; 64B)</span></nobr></DIV>
<DIV style="position:absolute;top:565;left:162"><nobr><span class="ft31"><i>MissPenalty</i></span></nobr></DIV>
<DIV style="position:absolute;top:565;left:294"><nobr><span class="ft21">The stall penalty of a data cache miss in core cycles</span></nobr></DIV>
<DIV style="position:absolute;top:585;left:162"><nobr><span class="ft31"><i>WBPenalty</i></span></nobr></DIV>
<DIV style="position:absolute;top:584;left:294"><nobr><span class="ft21">The stall penalty of a data cache writeback in core cycles</span></nobr></DIV>
<DIV style="position:absolute;top:604;left:162"><nobr><span class="ft31"><i>PrefetchEnable</i></span></nobr></DIV>
<DIV style="position:absolute;top:604;left:294"><nobr><span class="ft21">Enable prefetching (TRUE or FALSE)</span></nobr></DIV>
<DIV style="position:absolute;top:623;left:162"><nobr><span class="ft31"><i>NumCaches</i></span></nobr></DIV>
<DIV style="position:absolute;top:623;left:294"><nobr><span class="ft21">Number of caches in the architecture. </span></nobr></DIV>
<DIV style="position:absolute;top:643;left:162"><nobr><span class="ft31"><i>StreamEnable</i></span></nobr></DIV>
<DIV style="position:absolute;top:643;left:294"><nobr><span class="ft21">Enable the stream buffer (TRUE or FALSE)</span></nobr></DIV>
<DIV style="position:absolute;top:663;left:162"><nobr><span class="ft31"><i>lg2StrSize</i></span></nobr></DIV>
<DIV style="position:absolute;top:663;left:294"><nobr><span class="ft21">The log2 of the stream buffer size in bytes (e.g., 10 =&gt; 1KB)</span></nobr></DIV>
<DIV style="position:absolute;top:682;left:162"><nobr><span class="ft31"><i>lg2StrSets</i></span></nobr></DIV>
<DIV style="position:absolute;top:682;left:294"><nobr><span class="ft21">The log2 of the stream buffer associativity (e.g, 2 =&gt; 4-way set-associative)</span></nobr></DIV>
<DIV style="position:absolute;top:702;left:162"><nobr><span class="ft31"><i>lg2StrLineSize</i></span></nobr></DIV>
<DIV style="position:absolute;top:701;left:294"><nobr><span class="ft21">The log2 of the stream buffer line size in bytes (e.g. 8 =&gt; 64B)</span></nobr></DIV>
<DIV style="position:absolute;top:721;left:162"><nobr><span class="ft31"><i>StrMissPenalty</i></span></nobr></DIV>
<DIV style="position:absolute;top:721;left:294"><nobr><span class="ft21">The stall penalty of a stream buffer miss in core cycles</span></nobr></DIV>
<DIV style="position:absolute;top:740;left:162"><nobr><span class="ft31"><i>StrWBPenalty</i></span></nobr></DIV>
<DIV style="position:absolute;top:740;left:294"><nobr><span class="ft21">The stall penalty of a stream buffer writeback in core cycles</span></nobr></DIV>
<DIV style="position:absolute;top:760;left:162"><nobr><span class="ft31"><i>g2ICacheSize</i></span></nobr></DIV>
<DIV style="position:absolute;top:760;left:294"><nobr><span class="ft21">The log2 of the instruction cache size in bytes (e.g., 10 =&gt; 1KB)</span></nobr></DIV>
<DIV style="position:absolute;top:780;left:162"><nobr><span class="ft31"><i>lg2ICacheSets</i></span></nobr></DIV>
<DIV style="position:absolute;top:780;left:294"><nobr><span class="ft21">The log2 of the I-cache associativity (e.g, 2 =&gt; 4-way set-associative)</span></nobr></DIV>
<DIV style="position:absolute;top:799;left:162"><nobr><span class="ft31"><i>lg2ICacheLineSize</i></span></nobr></DIV>
<DIV style="position:absolute;top:799;left:294"><nobr><span class="ft21">The log2 of the I-cache line size in bytes (e.g. 8 =&gt; 64B)</span></nobr></DIV>
<DIV style="position:absolute;top:819;left:162"><nobr><span class="ft31"><i>IcachePenalty</i></span></nobr></DIV>
<DIV style="position:absolute;top:818;left:294"><nobr><span class="ft21">The stall penalty of an instruction cache miss in core cycles</span></nobr></DIV>
</DIV>
<!-- Page 39 -->
<a name="39"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
	.ft60{font-size:11px;line-height:13px;font-family:Times;color:#000000;}
-->
</STYLE>
<IMG width="918" height="1188" src="white.png" alt="background image">
<DIV style="position:absolute;top:81;left:81"><nobr><span class="ft1">and the math library (<i>-lm</i>), instructing the compiler to maximize optimization (<i>-O4</i>) and keep the assembler file around (<i>-ms</i>).</span></nobr></DIV>
<DIV style="position:absolute;top:113;left:135"><nobr><span class="ft14">## Compile individual modules<br>/home/vex/bin/cc -ms -O4 ­c file1.c<br>/home/vex/bin/cc -ms -O4 ­c file2.c</span></nobr></DIV>
<DIV style="position:absolute;top:167;left:135"><nobr><span class="ft14">## Link (with math library)<br>/home/bin/cc ­o test file1.o file2.o -lm</span></nobr></DIV>
<DIV style="position:absolute;top:208;left:135"><nobr><span class="ft14">## Run the program<br>./test</span></nobr></DIV>
<DIV style="position:absolute;top:247;left:81"><nobr><span class="ft5">This command sequence, in addition to any side effect (like terminal output) that the execution of <i>test</i> produces, generates two<br>VEX assembler files (<i>file1.s </i>and <i>file2.s</i>), two host (Linux) object files containing the compiled version of the CS-instrumented<br>VEX assembler files (<i>file1.o </i>and <i>file2.o</i>), a host executable file containing the instrumented version of the executable compiled<br>simulator for the code (<i>test</i>) and a simulation logfile (<i>ta.log.000</i>) containing the statistics corresponding to the simulation of<br>the execution of <i>test</i> on the default VEX platform.</span></nobr></DIV>
<DIV style="position:absolute;top:337;left:94"><nobr><span class="ft1">The assembler files are useful to check the static behavior of the compiler, and can be analyzed with the <i>pcntl</i> utility which</span></nobr></DIV>
<DIV style="position:absolute;top:355;left:81"><nobr><span class="ft1">collects static compile information from a VEX assembler file. For example, if we invoke</span></nobr></DIV>
<DIV style="position:absolute;top:388;left:135"><nobr><span class="ft60">## Analyze <i>file1.s<br></i>/home/vex/bin/pcntl file1.s</span></nobr></DIV>
<DIV style="position:absolute;top:427;left:94"><nobr><span class="ft1">we obtain a breakdown of every function in the assembler file, and every compilation <i>trace</i> per function, with the vital sta-</span></nobr></DIV>
<DIV style="position:absolute;top:445;left:81"><nobr><span class="ft5">tistics (instructions per cycle, number of scheduled cycles, number of scheduled operations and NOPs, number of copies for a<br>multicycle configuration, and so on). The listing also includes cumulative statistics that can be used as a first approximation to<br>evaluate the effectiveness of code reorganizations or different combinations of compiler flags.</span></nobr></DIV>
<DIV style="position:absolute;top:514;left:135"><nobr><span class="ft14">Procedure: rgb_to_cmyk_and_dither::<br> Trace    IPC Cycles   Oper   Copy    Nop<br>-----------------------------------------<br>     3   1.58     12     19      0      1<br>     1   3.33    232    773      0      0<br>     7   1.00      1      1      0      0<br>     6   1.00      1      1      0      0<br>     5   1.00      1      1      0      0<br>     4   0.50      2      1      0      0<br>Operations   = 796<br>Instructions = 249<br>Reg. moves   = 0<br>Nops         = 1<br>Avg ILP = 3.19679</span></nobr></DIV>
<DIV style="position:absolute;top:715;left:94"><nobr><span class="ft1">The simulation output file, as described, contains a set of self-explanatory statistics, such as cycles (total, execution, stalls,</span></nobr></DIV>
<DIV style="position:absolute;top:733;left:81"><nobr><span class="ft5">operations, equivalent time), branch statistics (executed, taken, conditional, unconditional), instruction memory statistics (esti-<br>mated code size, hits/misses) data memory statistics (hits/misses, bus conflicts, copybacks), bus statistics (bandwidth usage<br>fraction), as well as cumulative figures (overall IPC with and without accounting for stalls) and simulation statistics (simula-<br>tion time, equivalent "MIPS" speed). The output of a simulation run is the primary tool to guide experimentation.</span></nobr></DIV>
<DIV style="position:absolute;top:824;left:81"><nobr><span class="ft17"><b>7.2 Profiling</b></span></nobr></DIV>
<DIV style="position:absolute;top:858;left:81"><nobr><span class="ft6">A common use of the VEX tools is with the <i>gprof</i> profiling tool. By using the same example of <i><A href="vex.html#38">Section 7.1 &quot;Compile and run&quot;<br></i></a>we can insert profiling instrumentation (at the simulation level) through the <i>-mas_G </i>flag:</span></nobr></DIV>
<DIV style="position:absolute;top:908;left:135"><nobr><span class="ft14"># Compile individual modules with CS profiling<br>/home/vex/bin/cc -ms -mas_G -O4 ­c file1.c<br>/home/vex/bin/cc -ms -mas_G -O4 ­c file2.c</span></nobr></DIV>
<DIV style="position:absolute;top:962;left:135"><nobr><span class="ft14">## Link (with math library)<br>/home/bin/cc -mas_G -o test file1.o file2.o -lm</span></nobr></DIV>
<DIV style="position:absolute;top:1003;left:135"><nobr><span class="ft14">## Run the program<br>./test</span></nobr></DIV>
<DIV style="position:absolute;top:1042;left:94"><nobr><span class="ft1">The run of the profiled CS binary, in addition to the standard simulation output, also produces a set of data files for <i>gprof</i>,</span></nobr></DIV>
<DIV style="position:absolute;top:1060;left:81"><nobr><span class="ft6">including  <i>gmon.out  </i>(containing the data for the overall execution), <i>gmon-nocache.out</i>,  <i>gmon-icache.out</i> and <i>gmon-<br>dcache.out </i>(containing respectively the data for the execution assuming infinite caches, the instruction cache only, and the data</span></nobr></DIV>
</DIV>
<!-- Page 40 -->
<a name="40"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="white.png" alt="background image">
<DIV style="position:absolute;top:81;left:81"><nobr><span class="ft5">cache only). The latter three are particularly useful to identify pathological situations that affect the instruction or data caches<br>for a specific benchmark. By running the standard <i>gprof</i> utility on the instrumented binary, we can get individual statistics<br>from the <i>gmon*.out</i> files.</span></nobr></DIV>
<DIV style="position:absolute;top:149;left:135"><nobr><span class="ft14"># Get overall execution statistics<br>gprof test gmon.out</span></nobr></DIV>
<DIV style="position:absolute;top:190;left:135"><nobr><span class="ft14"># Get execution statistics assuming infinite caches<br>gprof test gmon-nocache.out</span></nobr></DIV>
<DIV style="position:absolute;top:230;left:135"><nobr><span class="ft14"># Get execution statistics on instruction cache<br>gprof test gmon-icache.out</span></nobr></DIV>
<DIV style="position:absolute;top:271;left:135"><nobr><span class="ft14"># Get overall execution on data cache<br>gprof test gmon-dcache.out</span></nobr></DIV>
<DIV style="position:absolute;top:310;left:94"><nobr><span class="ft1">In addition to the <i>gprof </i>data files, an instrumented profiled run also produces a flattened version of the function profile, with</span></nobr></DIV>
<DIV style="position:absolute;top:328;left:81"><nobr><span class="ft1">broken down statistics for the number of cycles spent in the instruction and data cache for each executed functions.</span></nobr></DIV>
<DIV style="position:absolute;top:365;left:135"><nobr><span class="ft40">Flat profile (cycles)<br>       Total       D-cache       I-cache  Function<br>   142934306      20005200        983340  rgb_to_cmyk<br>    89338101      23394096        622665  dither<br>    41688760       3077172        400635  interpolate_x<br>    34709205      12166200        238410  interpolate_y<br>    24579498       1818396         57375  write_ppm_row<br>    10075928       1472580         22005  ycc_rgb_convert<br>     5548602        510300         21600  jpeg_idct_islow<br>     3494605        963936         52740  h2v2_fancy_upsample<br>     2743026        192132         53595  decode_mcu<br>     1350417         43092          3915  jpeg_fill_bit_buffer<br>      671699         17028        248625  decompress_onepass<br>      167867         81000         44325  imgpipe<br>      131632         38232         69615  process_data_context_main<br>      109835         47520         14850  sep_upsample<br>       69817          9828          2340  jpeg_huff_decode<br>       69082         36540         15165  jpeg_read_scanlines</span></nobr></DIV>
<DIV style="position:absolute;top:635;left:208"><nobr><span class="ft10">... ... ... </span></nobr></DIV>
<DIV style="position:absolute;top:635;left:474"><nobr><span class="ft10">...</span></nobr></DIV>
<DIV style="position:absolute;top:664;left:94"><nobr><span class="ft1">Finally, it is possible to produce a graphical representation of the call graph (as described in<A href="vex.html#31"> Section 4 &quot;Visualization Tools&quot;)</a></span></nobr></DIV>
<DIV style="position:absolute;top:682;left:81"><nobr><span class="ft1">with the <i>rgg </i>tool</span></nobr></DIV>
<DIV style="position:absolute;top:715;left:135"><nobr><span class="ft14"># Generate visual call graph, excluding cache effects<br># and filtering out functions taking less than 1%</span></nobr></DIV>
<DIV style="position:absolute;top:755;left:135"><nobr><span class="ft10">/home/vex/bin/rgg test -m gmon-nocache.out -m 0.01</span></nobr></DIV>
<DIV style="position:absolute;top:787;left:81"><nobr><span class="ft17"><b>7.3 Custom architectures</b></span></nobr></DIV>
<DIV style="position:absolute;top:820;left:81"><nobr><span class="ft1">The support for customization in VEX is present at three different levels</span></nobr></DIV>
<DIV style="position:absolute;top:838;left:94"><nobr><span class="ft1">1.</span></nobr></DIV>
<DIV style="position:absolute;top:838;left:121"><nobr><span class="ft3"><b>Custom instructions</b>, inserted through <i>_asm()</i> intrinsics and simulated through a custom host-level library</span></nobr></DIV>
<DIV style="position:absolute;top:856;left:94"><nobr><span class="ft1">2.</span></nobr></DIV>
<DIV style="position:absolute;top:856;left:121"><nobr><span class="ft6"><b>Custom clusters, resources and latencies</b>, controlled through a compile-time configuration file (<i>-fmm=&lt;machine-<br>model&gt;</i>)</span></nobr></DIV>
<DIV style="position:absolute;top:892;left:94"><nobr><span class="ft1">3.</span></nobr></DIV>
<DIV style="position:absolute;top:892;left:121"><nobr><span class="ft5"><b>Custom memory architecture</b>, where simple deviations from the default model are captured through the CS configu-<br>ration file (<i>vex.cfg</i>), and complex memory architectures require writing a user-level instrumentation routine.</span></nobr></DIV>
<DIV style="position:absolute;top:928;left:94"><nobr><span class="ft1">As we described in<A href="vex.html#30"> Section 3.5 &quot;Custom Instructions&quot;,</a> we can instantiate custom instructions simply by including the <i>vex-</i></span></nobr></DIV>
<DIV style="position:absolute;top:946;left:81"><nobr><span class="ft5"><i>asm.h</i> header file and by using the <i>_asm(...) </i>syntax. This instantiates a "black-box" assembler instructions that the compiler<br>schedules based on the resource pattern and delay information that we define. Additionally, the compiler also requires a sepa-<br>rate simulation library that contains the helper code to implement the semantics of the custom instruction. If our simulation<br>library is called <i>asmlib.c</i>, the following command sequence compiles our canonical example.</span></nobr></DIV>
<DIV style="position:absolute;top:1019;left:135"><nobr><span class="ft14"># Compile (VEX compiler) individual modules<br>/home/vex/bin/cc -ms -O3 ­c file1.c<br>/home/vex/bin/cc -ms -O3 ­c file2.c</span></nobr></DIV>
<DIV style="position:absolute;top:1073;left:135"><nobr><span class="ft14"># Compile (host compiler) simulation library<br>gcc -c asmlib.c</span></nobr></DIV>
</DIV>
<!-- Page 41 -->
<a name="41"></a>
<DIV style="position:relative;width:918;height:1188;">
<STYLE type="text/css">
<!--
-->
</STYLE>
<IMG width="918" height="1188" src="white.png" alt="background image">
<DIV style="position:absolute;top:95;left:135"><nobr><span class="ft14">## Link (with math library and assembler library)<br>/home/bin/cc ­o test file1.o file2.o -lm asmlib.o</span></nobr></DIV>
<DIV style="position:absolute;top:139;left:94"><nobr><span class="ft1">If we want to instruct the compiler to target a custom machine model, we can pass the <i>-fmm=&lt;machine-model&gt;</i> flag during</span></nobr></DIV>
<DIV style="position:absolute;top:157;left:81"><nobr><span class="ft5">the compilation phase, or we can use the <i>-width &lt;clusters&gt;</i> to model a clustered architecture. A common experiment (for<br>example, to create a reference baseline) is to model a single-issue RISC-like target, which we can simply do by creating a<br><i>risc.mm</i> file containing the following directives (limit issue slots to one operation, reduce registers to 32):</span></nobr></DIV>
<DIV style="position:absolute;top:212;left:135"><nobr><span class="ft14">RES: IssueWidth 1<br>REG: $r0 32</span></nobr></DIV>
<DIV style="position:absolute;top:252;left:81"><nobr><span class="ft1">and passing the right flags to the compiler:</span></nobr></DIV>
<DIV style="position:absolute;top:271;left:135"><nobr><span class="ft14"># Compile modules with "risc" machine model<br>/home/vex/bin/cc -ms -O3 -fmm=risc.mm ­c file1.c<br>/home/vex/bin/cc -ms -O3 -fmm=risc.mm ­c file2.c</span></nobr></DIV>
<DIV style="position:absolute;top:324;left:94"><nobr><span class="ft1">At the other end of the extreme, we can try to model a very wide architecture (4 clusters, 32 issue slots, 32 memory opera-</span></nobr></DIV>
<DIV style="position:absolute;top:342;left:81"><nobr><span class="ft5">tions, 32 multipliers, 32 send/receive paths) which will most likely provide an upper bound to performance. To this aim, we<br>can generate a <i>verywide.mm</i> configuration file, containing:</span></nobr></DIV>
<DIV style="position:absolute;top:379;left:135"><nobr><span class="ft14">RES: IssueWidth 32<br>RES: MemLoad 32<br>RES: MemStore 32<br>RES: MemPft 32<br>RES: Alu.0 32<br>RES: Mpy.0 32<br>RES: CopySrc.0 32<br>RES: CopyDst.0 32<br>RES: Memory.0 32<br>RES: Alu.1 32<br>RES: Mpy.1 32<br>RES: CopySrc.1 32<br>RES: CopyDst.1 32<br>RES: Memory.1 32<br>RES: Alu.2 32<br>RES: Mpy.2 32<br>RES: CopySrc.2 32<br>RES: CopyDst.2 32<br>RES: Memory.2 32<br>RES: Alu.3 32<br>RES: Mpy.3 32<br>RES: CopySrc.3 32<br>RES: CopyDst.3 32<br>RES: Memory.3 32</span></nobr></DIV>
<DIV style="position:absolute;top:715;left:81"><nobr><span class="ft1">and invoking the compiler with the proper flag:</span></nobr></DIV>
<DIV style="position:absolute;top:734;left:135"><nobr><span class="ft14"># Compile modules with "risc" machine model<br>/home/vex/bin/cc -ms -O3 -fmm=verywide.mm ­c file1.c<br>/home/vex/bin/cc -ms -O3 -fmm=verywide.mm ­c file2.c</span></nobr></DIV>
<DIV style="position:absolute;top:787;left:94"><nobr><span class="ft1">Finally, when we invoke the CS-generated binary, we can also change the runtime simulation statistics by writing a <i>vex.cfg</i></span></nobr></DIV>
<DIV style="position:absolute;top:805;left:81"><nobr><span class="ft5">file for CS. At simulation time, we can change cache configuration, core and bus frequency, and -- in general -- any parame-<br>ter that does not require recompilation. For example, if we want to model a machine with 64KB data cache (4-way), 16KB<br>instruction cache (2-way), 1GHz core clock, 200MHz memory bus clock, we can write a <i>vex.cfg</i> file containing:</span></nobr></DIV>
<DIV style="position:absolute;top:860;left:135"><nobr><span class="ft14">CoreCkFreq           500<br>BusCkFreq            200<br>lg2CacheSize         16 # 64KB dcache<br>lg2Sets              4  # 4-way dcache<br>lg2ICacheSize </span></nobr></DIV>
<DIV style="position:absolute;top:914;left:305"><nobr><span class="ft10">14 # 16KB icache</span></nobr></DIV>
<DIV style="position:absolute;top:928;left:135"><nobr><span class="ft10">lg2ICacheSets        1  # 2-way icache</span></nobr></DIV>
<DIV style="position:absolute;top:954;left:81"><nobr><span class="ft1">Then, we can simply invoke the simulation of our benchmark</span></nobr></DIV>
<DIV style="position:absolute;top:973;left:135"><nobr><span class="ft14">## Run the program<br>./test</span></nobr></DIV>
<DIV style="position:absolute;top:1012;left:81"><nobr><span class="ft1">and look at the <i>ta.log.&lt;nnn&gt;</i> output file to analyze the statistics corresponding to the new configuration defined in <i>vex.cfg</i>.</span></nobr></DIV>
</DIV>
<hr>
</HTML>

