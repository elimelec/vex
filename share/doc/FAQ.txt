###
### VEX README file
### $Id: FAQ.txt,v 1.3 2004/10/25 11:03:12 frb Exp $
###

Q: What is the directory structure of the VEX distribution

A: The top-level vex distribution (default location /opt/vex) includes 4 subdirectories

   bin/         executables and scripts (for example: cc); VEX end users should only
                invoke the commands that are located in vex/bin directory 
   lib/         libraries and helpers (for example libc.a, libm.a ccom); this includes
                support files that are most likely not visible to the end users, as 
                they get invoked or used during compilation and simulation
   include/     header files for compiling VEX applications; roughly speaking this is
                a scaled down replacement of the /usr/include directory where the 
                headers have been customized - where needed - for the VEX compiler
   share/       configuration example, API use example, sources (GPL components) and 
                application examples

   The 'share' directory itself contains examples, documentation and sources

        ################### EXAMPLES ######################
        api/    Examples of how to write simple programs that use the VEX APIs, 
                including writing your own cache simulator, installing special 
                handlers for certain VEX operations, and adding custom instructions.
        apps/   Application examples, described in Chapter 11 of the book, with sources
                makefiles, sample data, and sample runs
        asm/    A simple flex/bison parser for the VEX assembler, to be used as a 
                starting point for excercises or other research activities

        ################### SUPPORT AND DOCUMENTATION ######################
        csim/   Sources of the VEX Compiled Simulator (CS) support library. This allows
                rebuilding "lib/ldcs.a" which is what gets linked with every executable
                generated by CS. Should only be used if the binary VEX distribution
                is not compatible with a specific linux installation, or for very 
                advanced users. Change and use at your own risk.
        doc/    Documentation directory, currently containing an HTML version of the 
                VEX manual.

        ################### SOURCE DISTRIBUTIONS ######################
        cpp/    GPL sources of the modified 'cpp' (C preprocessor). For updates or later
                version, see http://gcc.gnu.org
        libs/   Sources of the publicly available C libraries (libc) and 
                math libraries (libm)
        vcg/    GPL sources of the VCG (Visualization of Compiler Graphs) component.
                For updates and latest versions, see 
                http://rw4.cs.uni-sb.de/~sander/html/gsvcg1.html

---

Q: Do I have to install VEX in a specific directory?

A: You should be able to install the VEX distribution in any directory, and you do
   not need root privileges to run it. For a system-wide installation, we recommend
   installing it in /opt/vex (the default for the RPM package). The tarball can be 
   expanded in any directory.

---

Q: Does VEX depend on any specific system configuration?

A: We have tested VEX on many "modern" Linux configuration, and our "golden" platform
   is a Mandrake 8.1 system (for which we ship an RPM). The compiled simulator relies 
   on gcc to be installed (and callable as "gcc"), and any version of gcc >= 2.95 
   ought to work ok. The compiler also relies on the existance of a world-writable 
   /tmp scratch directory with reasonable free space. There is no need to set any 
   environment variable. The VEX distribution can be moved in any directory, but 
   individual components cannot be pulled out of the distribution directory.

---

Q: What's a probability directory, probability info?

A: The VEX compiler can (optionally) use edge-profile information to
pick better traces. This requires a two-pass compilation (compile with
-prob_gen, run, and compile with -prob_use). See the book and 'cc -help'
for usage details.

---

Q: Are man pages for cc, as, ld and other VEX tools available?

A: Most of the tools dump usage information when invoked with '-help'
or '--help'. No man page is available, in addition to what is in the
book Appendix. 

---

Q: What goes into my shell startup script? E.g., platform-specific
environment variables?

A: VEX does not rely on environment variables.

---

Q: Can I call my own atexit functions for a VEX simulation?

A: If the 'atexit()' function is supposed to be compiled for VEX and
simulated, you can use the 'atexit()' C-library call in the way ANSI
C describes. If what you want to do is invoke a function 'atexit()' of
the VEX compiled simulator, what you probably need is to implement your
own simulation routines. You can do this, by using the simulation API,
and you can find an example of API usage in the 'api' directory of the
VEX distribution.

---

Q: Where does the cache simulation live?  How do I build my own?

A: The default VEX cache simulator is precompiled in the shared library
'cachelib.sl' and linked by default. You can write your own cache
simulator through the compiled simulator API (see example in the 'api'
directory of the VEX distribution).

---

Q: If I want to mark a particular phase of the program, what's the
command?

A: If you implement your own simulation API, and are willing to live
with the overhead of a simulated function call, you can define your own
'tracing' and 'marking' functions in the compiled simulator API (see an
example in api/cachesim.c). Note that the host/simulator cross-calling
mechanism is limited (see next question).

---

Q: In general, what sorts of simulator/host calls can I put into the
source code?

A: One advantage of using compiled simulation is that you can mix host
and simulated code. However, due to endianess mismatches (x86 is LE,
VEX is BE), it is safe to only pass a few number of scalar arguments
(less than 8). Passing structures, strings and varargs is likely to
produce unpredictable results.

---

Q: How do I get access to the guts of the assembler, e.g. to do the
   "design your own encoding" exercise?

A: In the vex/share/asm directory, we include a simple assembler parser
   (flex/bison grammars) with an example that dumps most of the VEX
   assembler information. On top of that, you should be able to build 
   your own complexity without too much effort. This is currently designed
   as a one-pass assembler, so for more elaborate analysis, some intermediate
   representation may be necessary.

--- 

Q: What library routines are available; what can I override?  what's the API?
   memory access simulation (I$, D$, or both, or prefetch) branch prediction 
   simulation access point to be called every bundle

A: VEX ships with a simple cache (1-level) simulation library. In the o
   "vex/share/api" directory, we include an example on how to override the
   cache-simulation entry points (memory traces) with a user-defined routine.
   At this time, VEX does not support a dynamic branch predictor directly.
   However, it may be possible to insert an assembler filter (see next question)
   to achieve similar effects. The API directory includes a trivial example of
   a branch "tracker".

--- 

Q: Can I make the CS add new instrumentation calls into certain opcodes?
        E.g., "user_defined_fn_called_whenever_mul()"?

A: Not in a straightforward manner. The only builtin provision to capture 
   operations in user-defined functions is for memory operations (see 
   vex/share/api examples). For other operations, through manual editing of the 
   "as" script, it may be possible to insert a filter (e.g., a sed script) that 
   changes the default invocation of some of the "execution" macros of an operation.
   Then, with the "-Tapath/to/modified/as" flag to the compiler, it is possible to 
   transparently invoke the modified assembler. CS includes a set of dummy handles 
   to capture control flow operations (branch,goto,call,return,entry).

